{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FEMpy FEMpy is my attempt to implement a basic object-oriented finite element method in python FEMpy uses scipy's sparse matrix implementation to enable scaling to problems with many (>100k) degrees of freedom. Wherever possible, operations use numpy vectorisation or numba JIT compiling for speed, there's still plenty of room for improvement though! How to install Inside the FEMpy root directory run: pip install . Or, if you want to make changes to the code: pip install -e . If you want to build documentation locally, or run the unit tests, make sure to install the necessary dependencies: pip install -e . [ docs, dev ] And then run: make build","title":"Home"},{"location":"#fempy","text":"FEMpy is my attempt to implement a basic object-oriented finite element method in python FEMpy uses scipy's sparse matrix implementation to enable scaling to problems with many (>100k) degrees of freedom. Wherever possible, operations use numpy vectorisation or numba JIT compiling for speed, there's still plenty of room for improvement though!","title":"FEMpy"},{"location":"#how-to-install","text":"Inside the FEMpy root directory run: pip install . Or, if you want to make changes to the code: pip install -e . If you want to build documentation locally, or run the unit tests, make sure to install the necessary dependencies: pip install -e . [ docs, dev ] And then run: make build","title":"How to install"},{"location":"Elements/Element/","text":"Element Parent Class __init__ ( self , numNodes , numDimensions , numDisplacements = None ) special Instantiate an Element object Parameters: Name Type Description Default numNodes int Number of nodes in each element required numDimensions int Number of spatial dimensions the element models required numDisplacements int Number of displacements at each node, by default this is set equal to the number of spatial dimensions None Source code in FEMpy/Element.py def __init__ ( self , numNodes , numDimensions , numDisplacements = None ): \"\"\"Instantiate an Element object Parameters ---------- numNodes : int Number of nodes in each element numDimensions : int Number of spatial dimensions the element models numDisplacements : int, optional Number of displacements at each node, by default this is set equal to the number of spatial dimensions \"\"\" self . numNodes = numNodes self . numDim = numDimensions self . numDisp = numDimensions if numDisplacements is None else numDisplacements self . numDOF = numNodes * self . numDisp self . name = f \" { self . numNodes } Node- { self . numDisp } Disp- { self . numDim } D-Element\" # --- Define fast jacobian determinant function based on number of dimensions --- if self . numDim == 1 : self . jacDet = det1 self . jacInv = inv1 elif self . numDim == 2 : self . jacDet = det2 self . jacInv = inv2 elif self . numDim == 3 : self . jacDet = det3 self . jacInv = inv3 bodyForceIntegrad ( self , f , paramCoord , nodeCoords ) Source code in FEMpy/Element.py def bodyForceIntegrad ( self , f , paramCoord , nodeCoords ): # Compute shape functions and Jacobian determinant at parametric coordinates N = self . getShapeFunctions ( paramCoord ) J = self . getJacobian ( paramCoord , nodeCoords ) detJ = self . jacDet ( J ) # Transform parametric to real coordinates in order to compute body force components realCoord = self . getRealCoord ( paramCoord , nodeCoords ) F = f ( realCoord ) Fb = self . _computeNTFProduct ( F , N ) return ( Fb . T * detJ ) . T getBMat ( self , paramCoords , nodeCoords , constitutive ) Compute the element B matrix at a set of parametric coordinates The B matrix is the matrix that converts nodal DOF's to strains strain = B*q K = int (B^T * D * B) dv Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required nodeCoords numNode x numDim array Element node real coordinates required Returns: Type Description n x numStrain x (numNode*numDim) array The B matrices, B[i] returns the 2D B matrix at the ith parametric point Source code in FEMpy/Element.py def getBMat ( self , paramCoords , nodeCoords , constitutive ): \"\"\"Compute the element B matrix at a set of parametric coordinates The B matrix is the matrix that converts nodal DOF's to strains strain = B*q K = int (B^T * D * B) dv Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at nodeCoords : numNode x numDim array Element node real coordinates Returns ------- B : n x numStrain x (numNode*numDim) array The B matrices, B[i] returns the 2D B matrix at the ith parametric point \"\"\" NPrime = self . getNPrime ( paramCoords , nodeCoords ) return self . _makeBMat ( NPrime , constitutive ) getJacobian ( self , paramCoords , nodeCoords ) Get the element Jacobians at a set of parametric coordinates Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required nodeCoords numNode x numDim array Element node real coordinates required Returns: Type Description n x numDim x numDim array The Jacobians at each point Source code in FEMpy/Element.py def getJacobian ( self , paramCoords , nodeCoords ): \"\"\"Get the element Jacobians at a set of parametric coordinates Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at nodeCoords : numNode x numDim array Element node real coordinates Returns ------- Jac : n x numDim x numDim array The Jacobians at each point \"\"\" return self . getShapeFunctionDerivs ( paramCoords ) @ nodeCoords getMassIntegrand ( self , paramCoords , nodeCoords , constitutive ) Source code in FEMpy/Element.py def getMassIntegrand ( self , paramCoords , nodeCoords , constitutive ): N = self . getShapeFunctions ( paramCoords ) NMat = self . _makeNMat ( N ) J = self . getJacobian ( paramCoords , nodeCoords ) detJ = self . jacDet ( J ) NTN = np . swapaxes ( NMat , 1 , 2 ) @ NMat * constitutive . rho return ( NTN . T * detJ ) . T getMassMat ( self , nodeCoords , constitutive , n = None ) Source code in FEMpy/Element.py def getMassMat ( self , nodeCoords , constitutive , n = None ): if n is None : n = self . order + 1 if self . numDim == 1 : f = lambda x1 : self . getMassIntegrand ( np . array ([ x1 ]) . T , nodeCoords , constitutive ) # noqa: E731 return gaussQuad1d ( f = f , n = n ) if self . numDim == 2 : f = lambda x1 , x2 : self . getMassIntegrand ( np . array ([ x1 , x2 ]) . T , nodeCoords , constitutive ) # noqa: E731 return gaussQuad2d ( f = f , n = n ) if self . numDim == 3 : f = lambda x1 , x2 , x3 : self . getMassIntegrand ( # noqa: E731 np . array ([ x1 , x2 , x3 ]) . T , nodeCoords , constitutive ) return gaussQuad3d ( f , n ) getNPrime ( self , paramCoords , nodeCoords ) Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the real coordinates (x,y,z) Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required nodeCoords numNode x numDim array Element node real coordinates required Returns: Type Description n x numDim x numNode array [description] Source code in FEMpy/Element.py def getNPrime ( self , paramCoords , nodeCoords ): \"\"\"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the real coordinates (x,y,z) Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at nodeCoords : numNode x numDim array Element node real coordinates Returns ------- NPrime : n x numDim x numNode array [description] \"\"\" NPrimeParam = self . getShapeFunctionDerivs ( paramCoords ) # The Jacobian is NPrimeParam * nodeCoords so we don't need to waste time recomputing NPrimeParam inside the # getJacobian function return self . jacInv ( NPrimeParam @ nodeCoords ) @ NPrimeParam getParamCoord ( self , realCoords , nodeCoords , maxIter = 10 , tol = 1e-08 ) Find the parametric coordinates within an element corresponding to a point in real space Note this function only currently works for finding the parametric coordinates of one point inside one element Parameters: Name Type Description Default realCoords array of length numDim Real coordinates to find the paranmetric coordinates of the desired point required nodeCoords numNode x numDim array Element node real coordinates required maxIter int Maximum number of search iterations, by default 4 10 Returns: Type Description array of length numDim Parametric coordinates of the desired point Source code in FEMpy/Element.py def getParamCoord ( self , realCoords , nodeCoords , maxIter = 10 , tol = 1e-8 ): \"\"\"Find the parametric coordinates within an element corresponding to a point in real space Note this function only currently works for finding the parametric coordinates of one point inside one element Parameters ---------- realCoords : array of length numDim Real coordinates to find the paranmetric coordinates of the desired point nodeCoords : numNode x numDim array Element node real coordinates maxIter : int, optional Maximum number of search iterations, by default 4 Returns ------- x : array of length numDim Parametric coordinates of the desired point \"\"\" # x = np.zeros(self.numDim) # for i in range(maxIter): # res = realCoords - self.getRealCoord(np.array([x]), nodeCoords).flatten() # if np.max(np.abs(res)) < tol: # break # else: # jacT = self.getJacobian(np.array([x]), nodeCoords)[0].T # x += np.linalg.solve(jacT, res) # return x def resFunc ( x ): return realCoords - self . getRealCoord ( np . array ([ x ]), nodeCoords ) . flatten () sol = root ( resFunc , np . zeros ( self . numDim ), method = \"krylov\" , tol = tol ) return sol . x getRandParamCoord ( self , n = 1 ) Generate a set of random parametric coordinates By default this method assumes that the valid range for all parametric coordinates is [-1, 1]. For elements where this is not the case, this method should be reimplemented. Parameters: Name Type Description Default n int number of points to generate, by default 1 1 Returns: Type Description n x numDim array isoparametric coordinates, one row for each point Source code in FEMpy/Element.py def getRandParamCoord ( self , n = 1 ): \"\"\"Generate a set of random parametric coordinates By default this method assumes that the valid range for all parametric coordinates is [-1, 1]. For elements where this is not the case, this method should be reimplemented. Parameters ---------- n : int, optional number of points to generate, by default 1 Returns ------- paramCoords : n x numDim array isoparametric coordinates, one row for each point \"\"\" return np . atleast_2d ( np . random . rand ( n , self . numDim )) getRandomNodeCoords ( self ) Generate a random, but valid, set of node coordinates for an element This method should be implemented for each element. Returns: Type Description numNode x numDim array Node coordinates Source code in FEMpy/Element.py @abc . abstractmethod def getRandomNodeCoords ( self ): \"\"\"Generate a random, but valid, set of node coordinates for an element This method should be implemented for each element. Returns ------- nodeCoords : numNode x numDim array Node coordinates \"\"\" raise NotImplementedError getRealCoord ( self , paramCoords , nodeCoords ) Compute the real coordinates of a point in isoparametric space Parameters: Name Type Description Default paramCoords n x numDim array isoparametric coordinates, one row for each point in isoparametric space to be converted required nodeCoords numNode x numDim array Element node real coordinates required Returns: Type Description n x nD array Point coordinates in real space Source code in FEMpy/Element.py def getRealCoord ( self , paramCoords , nodeCoords ): \"\"\"Compute the real coordinates of a point in isoparametric space Parameters ---------- paramCoords : n x numDim array isoparametric coordinates, one row for each point in isoparametric space to be converted nodeCoords : numNode x numDim array Element node real coordinates Returns ------- coords : n x nD array Point coordinates in real space \"\"\" N = self . getShapeFunctions ( paramCoords ) return N [:, : self . numNodes ] @ nodeCoords getShapeFunctionDerivs ( self , paramCoords ) Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) This function must be implemented in any child classes Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numDim x numNode array Shape function values, N i [k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate Source code in FEMpy/Element.py @abc . abstractmethod def getShapeFunctionDerivs ( self , paramCoords ): \"\"\"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) This function must be implemented in any child classes Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- NPrimeParam : n x numDim x numNode array Shape function values, N[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" raise NotImplementedError getShapeFunctions ( self , paramCoords ) Compute shape function values at a set of parametric coordinates This function must be implemented in any child classes Parameters: Name Type Description Default paramCoords n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numNode array Shape function values, N i is the value of the jth shape function at the ith point Source code in FEMpy/Element.py @abc . abstractmethod def getShapeFunctions ( self , paramCoords ): \"\"\"Compute shape function values at a set of parametric coordinates This function must be implemented in any child classes Parameters ---------- paramCoords : n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- N : n x numNode array Shape function values, N[i][j] is the value of the jth shape function at the ith point \"\"\" raise NotImplementedError getStiffnessIntegrand ( self , paramCoords , nodeCoords , constitutive ) Source code in FEMpy/Element.py def getStiffnessIntegrand ( self , paramCoords , nodeCoords , constitutive ): B = self . getBMat ( paramCoords , nodeCoords , constitutive ) J = self . getJacobian ( paramCoords , nodeCoords ) detJ = self . jacDet ( J ) BDB = np . swapaxes ( B , 1 , 2 ) @ constitutive . DMat @ B return ( BDB . T * detJ ) . T getStiffnessMat ( self , nodeCoords , constitutive , n = None ) Source code in FEMpy/Element.py def getStiffnessMat ( self , nodeCoords , constitutive , n = None ): if n is None : n = self . order + 1 if self . numDim == 1 : f = lambda x1 : self . getStiffnessIntegrand ( np . array ([ x1 ]) . T , nodeCoords , constitutive ) # noqa: E731 return gaussQuad1d ( f = f , n = n ) if self . numDim == 2 : f = lambda x1 , x2 : self . getStiffnessIntegrand ( np . array ([ x1 , x2 ]) . T , nodeCoords , constitutive ) # noqa: E731 return gaussQuad2d ( f = f , n = n ) if self . numDim == 3 : f = lambda x1 , x2 , x3 : self . getStiffnessIntegrand ( # noqa: E731 np . array ([ x1 , x2 , x3 ]) . T , nodeCoords , constitutive ) return gaussQuad3d ( f , n ) getStrain ( self , paramCoords , nodeCoords , constitutive , uNodes ) Source code in FEMpy/Element.py def getStrain ( self , paramCoords , nodeCoords , constitutive , uNodes ): BMat = self . getBMat ( paramCoords , nodeCoords , constitutive ) return BMat @ uNodes . flatten () getStress ( self , paramCoords , nodeCoords , constitutive , uNodes ) Source code in FEMpy/Element.py def getStress ( self , paramCoords , nodeCoords , constitutive , uNodes ): return self . getStrain ( paramCoords , nodeCoords , constitutive , uNodes ) @ constitutive . DMat getU ( self , paramCoords , uNodes ) Compute the displacements at a set of parametric coordinates Parameters: Name Type Description Default paramCoords n x numDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required uNodes numNode x numDim array Nodal displacements required Returns: Type Description n x numDim array Array of displacement values, u[i,j] is the jth displacement component at the ith point Source code in FEMpy/Element.py def getU ( self , paramCoords , uNodes ): \"\"\"Compute the displacements at a set of parametric coordinates Parameters ---------- paramCoords : n x numDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at uNodes : numNode x numDim array Nodal displacements Returns ------- u : n x numDim array Array of displacement values, u[i,j] is the jth displacement component at the ith point \"\"\" N = self . getShapeFunctions ( paramCoords ) return N @ uNodes getUPrime ( self , paramCoords , nodeCoords , uNodes ) Compute the displacement derivatives at a set of parametric coordinates Parameters: Name Type Description Default paramCoords n x numDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required nodeCoords numNode x numDim array Element node real coordinates required uNodes numNode x numDim array Nodal displacements required Returns: Type Description n x numDim x numNode array [description] Source code in FEMpy/Element.py def getUPrime ( self , paramCoords , nodeCoords , uNodes ): \"\"\"Compute the displacement derivatives at a set of parametric coordinates Parameters ---------- paramCoords : n x numDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at nodeCoords : numNode x numDim array Element node real coordinates uNodes : numNode x numDim array Nodal displacements Returns ------- NPrime : n x numDim x numNode array [description] \"\"\" NPrime = self . getNPrime ( paramCoords , nodeCoords ) return NPrime @ uNodes integrateBodyForce ( self , f , nodeCoords , n = 1 ) Compute equivalent nodal forces due to body forces through numerical integration Parameters: Name Type Description Default f Body force function Should accept an nP x numDim array as input and output a nP x numDisp array, ie f(x)[i] returns the body force components at the ith point queried required nodeCoords numNode x numDim array Element node real coordinates required n int Number of integration points, can be a single value or a list with a value for each direction, by default 1 1 Returns: Type Description numNode x numDisp array Equivalent nodal loads due to body force Source code in FEMpy/Element.py def integrateBodyForce ( self , f , nodeCoords , n = 1 ): \"\"\"Compute equivalent nodal forces due to body forces through numerical integration Parameters ---------- f : Body force function Should accept an nP x numDim array as input and output a nP x numDisp array, ie f(x)[i] returns the body force components at the ith point queried nodeCoords : numNode x numDim array Element node real coordinates n : int, optional Number of integration points, can be a single value or a list with a value for each direction, by default 1 Returns ------- Fb : numNode x numDisp array Equivalent nodal loads due to body force \"\"\" if self . numDim == 1 : bodyForceFunc = lambda x1 : self . bodyForceIntegrad ( f , np . array ([ x1 ]) . T , nodeCoords ) # noqa: E731 return gaussQuad1d ( bodyForceFunc , n ) if self . numDim == 2 : bodyForceFunc = lambda x1 , x2 : self . bodyForceIntegrad ( f , np . array ([ x1 , x2 ]) . T , nodeCoords ) # noqa: E731 return gaussQuad2d ( bodyForceFunc , n ) if self . numDim == 3 : bodyForceFunc = lambda x1 , x2 , x3 : self . bodyForceIntegrad ( # noqa: E731 f , np . array ([ x1 , x2 , x3 ]) . T , nodeCoords ) return gaussQuad3d ( bodyForceFunc , n ) testGetParamCoord ( self , n = 10 , maxIter = 40 , tol = 1e-10 ) Test the getParamCoord method This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getParamCoord match the original random values. Parameters: Name Type Description Default n int Number of random coordinates to generate, by default 10 10 Source code in FEMpy/Element.py def testGetParamCoord ( self , n = 10 , maxIter = 40 , tol = 1e-10 ): \"\"\"Test the getParamCoord method This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getParamCoord match the original random values. Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 \"\"\" paramCoord = self . getRandParamCoord ( n ) nodeCoords = self . getRandomNodeCoords () realCoords = self . getRealCoord ( paramCoord , nodeCoords ) error = np . zeros_like ( realCoords ) for i in range ( n ): error [ i ] = paramCoord [ i ] - self . getParamCoord ( realCoords [ i ], nodeCoords , maxIter = maxIter , tol = tol ) return error testShapeFunctionDerivatives ( self , n = 10 ) Test the implementation of the shape function derivatives using the complex-step method Parameters: Name Type Description Default n int Number of random coordinates to generate, by default 10 10 Source code in FEMpy/Element.py def testShapeFunctionDerivatives ( self , n = 10 ): \"\"\"Test the implementation of the shape function derivatives using the complex-step method Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 \"\"\" paramCoords = self . getRandParamCoord ( n ) coordPert = np . zeros_like ( paramCoords , dtype = \"complex128\" ) dN = self . getShapeFunctionDerivs ( paramCoords ) dNApprox = np . zeros_like ( dN ) for i in range ( self . numDim ): np . copyto ( coordPert , paramCoords ) coordPert [:, i ] += 1e-200 * 1 j dNApprox [:, i , :] = 1e200 * np . imag ( self . getShapeFunctions ( coordPert )) return dN - dNApprox testShapeFunctionSum ( self , n = 10 ) Test the basic property that shape function values should sum to 1 everywhere within an element Parameters: Name Type Description Default n int Number of points to test at, by default 10 10 Source code in FEMpy/Element.py def testShapeFunctionSum ( self , n = 10 ): \"\"\"Test the basic property that shape function values should sum to 1 everywhere within an element Parameters ---------- n : int, optional Number of points to test at, by default 10 \"\"\" paramCoords = self . getRandParamCoord ( n ) N = self . getShapeFunctions ( paramCoords ) return np . sum ( N , axis = 1 )","title":"Generic Element"},{"location":"Elements/Element/#element-parent-class","text":"","title":"Element Parent Class"},{"location":"Elements/Element/#FEMpy.Element.Element.__init__","text":"Instantiate an Element object Parameters: Name Type Description Default numNodes int Number of nodes in each element required numDimensions int Number of spatial dimensions the element models required numDisplacements int Number of displacements at each node, by default this is set equal to the number of spatial dimensions None Source code in FEMpy/Element.py def __init__ ( self , numNodes , numDimensions , numDisplacements = None ): \"\"\"Instantiate an Element object Parameters ---------- numNodes : int Number of nodes in each element numDimensions : int Number of spatial dimensions the element models numDisplacements : int, optional Number of displacements at each node, by default this is set equal to the number of spatial dimensions \"\"\" self . numNodes = numNodes self . numDim = numDimensions self . numDisp = numDimensions if numDisplacements is None else numDisplacements self . numDOF = numNodes * self . numDisp self . name = f \" { self . numNodes } Node- { self . numDisp } Disp- { self . numDim } D-Element\" # --- Define fast jacobian determinant function based on number of dimensions --- if self . numDim == 1 : self . jacDet = det1 self . jacInv = inv1 elif self . numDim == 2 : self . jacDet = det2 self . jacInv = inv2 elif self . numDim == 3 : self . jacDet = det3 self . jacInv = inv3","title":"__init__()"},{"location":"Elements/Element/#FEMpy.Element.Element.bodyForceIntegrad","text":"Source code in FEMpy/Element.py def bodyForceIntegrad ( self , f , paramCoord , nodeCoords ): # Compute shape functions and Jacobian determinant at parametric coordinates N = self . getShapeFunctions ( paramCoord ) J = self . getJacobian ( paramCoord , nodeCoords ) detJ = self . jacDet ( J ) # Transform parametric to real coordinates in order to compute body force components realCoord = self . getRealCoord ( paramCoord , nodeCoords ) F = f ( realCoord ) Fb = self . _computeNTFProduct ( F , N ) return ( Fb . T * detJ ) . T","title":"bodyForceIntegrad()"},{"location":"Elements/Element/#FEMpy.Element.Element.getBMat","text":"Compute the element B matrix at a set of parametric coordinates The B matrix is the matrix that converts nodal DOF's to strains strain = B*q K = int (B^T * D * B) dv Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required nodeCoords numNode x numDim array Element node real coordinates required Returns: Type Description n x numStrain x (numNode*numDim) array The B matrices, B[i] returns the 2D B matrix at the ith parametric point Source code in FEMpy/Element.py def getBMat ( self , paramCoords , nodeCoords , constitutive ): \"\"\"Compute the element B matrix at a set of parametric coordinates The B matrix is the matrix that converts nodal DOF's to strains strain = B*q K = int (B^T * D * B) dv Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at nodeCoords : numNode x numDim array Element node real coordinates Returns ------- B : n x numStrain x (numNode*numDim) array The B matrices, B[i] returns the 2D B matrix at the ith parametric point \"\"\" NPrime = self . getNPrime ( paramCoords , nodeCoords ) return self . _makeBMat ( NPrime , constitutive )","title":"getBMat()"},{"location":"Elements/Element/#FEMpy.Element.Element.getJacobian","text":"Get the element Jacobians at a set of parametric coordinates Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required nodeCoords numNode x numDim array Element node real coordinates required Returns: Type Description n x numDim x numDim array The Jacobians at each point Source code in FEMpy/Element.py def getJacobian ( self , paramCoords , nodeCoords ): \"\"\"Get the element Jacobians at a set of parametric coordinates Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at nodeCoords : numNode x numDim array Element node real coordinates Returns ------- Jac : n x numDim x numDim array The Jacobians at each point \"\"\" return self . getShapeFunctionDerivs ( paramCoords ) @ nodeCoords","title":"getJacobian()"},{"location":"Elements/Element/#FEMpy.Element.Element.getMassIntegrand","text":"Source code in FEMpy/Element.py def getMassIntegrand ( self , paramCoords , nodeCoords , constitutive ): N = self . getShapeFunctions ( paramCoords ) NMat = self . _makeNMat ( N ) J = self . getJacobian ( paramCoords , nodeCoords ) detJ = self . jacDet ( J ) NTN = np . swapaxes ( NMat , 1 , 2 ) @ NMat * constitutive . rho return ( NTN . T * detJ ) . T","title":"getMassIntegrand()"},{"location":"Elements/Element/#FEMpy.Element.Element.getMassMat","text":"Source code in FEMpy/Element.py def getMassMat ( self , nodeCoords , constitutive , n = None ): if n is None : n = self . order + 1 if self . numDim == 1 : f = lambda x1 : self . getMassIntegrand ( np . array ([ x1 ]) . T , nodeCoords , constitutive ) # noqa: E731 return gaussQuad1d ( f = f , n = n ) if self . numDim == 2 : f = lambda x1 , x2 : self . getMassIntegrand ( np . array ([ x1 , x2 ]) . T , nodeCoords , constitutive ) # noqa: E731 return gaussQuad2d ( f = f , n = n ) if self . numDim == 3 : f = lambda x1 , x2 , x3 : self . getMassIntegrand ( # noqa: E731 np . array ([ x1 , x2 , x3 ]) . T , nodeCoords , constitutive ) return gaussQuad3d ( f , n )","title":"getMassMat()"},{"location":"Elements/Element/#FEMpy.Element.Element.getNPrime","text":"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the real coordinates (x,y,z) Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required nodeCoords numNode x numDim array Element node real coordinates required Returns: Type Description n x numDim x numNode array [description] Source code in FEMpy/Element.py def getNPrime ( self , paramCoords , nodeCoords ): \"\"\"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the real coordinates (x,y,z) Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at nodeCoords : numNode x numDim array Element node real coordinates Returns ------- NPrime : n x numDim x numNode array [description] \"\"\" NPrimeParam = self . getShapeFunctionDerivs ( paramCoords ) # The Jacobian is NPrimeParam * nodeCoords so we don't need to waste time recomputing NPrimeParam inside the # getJacobian function return self . jacInv ( NPrimeParam @ nodeCoords ) @ NPrimeParam","title":"getNPrime()"},{"location":"Elements/Element/#FEMpy.Element.Element.getParamCoord","text":"Find the parametric coordinates within an element corresponding to a point in real space Note this function only currently works for finding the parametric coordinates of one point inside one element Parameters: Name Type Description Default realCoords array of length numDim Real coordinates to find the paranmetric coordinates of the desired point required nodeCoords numNode x numDim array Element node real coordinates required maxIter int Maximum number of search iterations, by default 4 10 Returns: Type Description array of length numDim Parametric coordinates of the desired point Source code in FEMpy/Element.py def getParamCoord ( self , realCoords , nodeCoords , maxIter = 10 , tol = 1e-8 ): \"\"\"Find the parametric coordinates within an element corresponding to a point in real space Note this function only currently works for finding the parametric coordinates of one point inside one element Parameters ---------- realCoords : array of length numDim Real coordinates to find the paranmetric coordinates of the desired point nodeCoords : numNode x numDim array Element node real coordinates maxIter : int, optional Maximum number of search iterations, by default 4 Returns ------- x : array of length numDim Parametric coordinates of the desired point \"\"\" # x = np.zeros(self.numDim) # for i in range(maxIter): # res = realCoords - self.getRealCoord(np.array([x]), nodeCoords).flatten() # if np.max(np.abs(res)) < tol: # break # else: # jacT = self.getJacobian(np.array([x]), nodeCoords)[0].T # x += np.linalg.solve(jacT, res) # return x def resFunc ( x ): return realCoords - self . getRealCoord ( np . array ([ x ]), nodeCoords ) . flatten () sol = root ( resFunc , np . zeros ( self . numDim ), method = \"krylov\" , tol = tol ) return sol . x","title":"getParamCoord()"},{"location":"Elements/Element/#FEMpy.Element.Element.getRandParamCoord","text":"Generate a set of random parametric coordinates By default this method assumes that the valid range for all parametric coordinates is [-1, 1]. For elements where this is not the case, this method should be reimplemented. Parameters: Name Type Description Default n int number of points to generate, by default 1 1 Returns: Type Description n x numDim array isoparametric coordinates, one row for each point Source code in FEMpy/Element.py def getRandParamCoord ( self , n = 1 ): \"\"\"Generate a set of random parametric coordinates By default this method assumes that the valid range for all parametric coordinates is [-1, 1]. For elements where this is not the case, this method should be reimplemented. Parameters ---------- n : int, optional number of points to generate, by default 1 Returns ------- paramCoords : n x numDim array isoparametric coordinates, one row for each point \"\"\" return np . atleast_2d ( np . random . rand ( n , self . numDim ))","title":"getRandParamCoord()"},{"location":"Elements/Element/#FEMpy.Element.Element.getRandomNodeCoords","text":"Generate a random, but valid, set of node coordinates for an element This method should be implemented for each element. Returns: Type Description numNode x numDim array Node coordinates Source code in FEMpy/Element.py @abc . abstractmethod def getRandomNodeCoords ( self ): \"\"\"Generate a random, but valid, set of node coordinates for an element This method should be implemented for each element. Returns ------- nodeCoords : numNode x numDim array Node coordinates \"\"\" raise NotImplementedError","title":"getRandomNodeCoords()"},{"location":"Elements/Element/#FEMpy.Element.Element.getRealCoord","text":"Compute the real coordinates of a point in isoparametric space Parameters: Name Type Description Default paramCoords n x numDim array isoparametric coordinates, one row for each point in isoparametric space to be converted required nodeCoords numNode x numDim array Element node real coordinates required Returns: Type Description n x nD array Point coordinates in real space Source code in FEMpy/Element.py def getRealCoord ( self , paramCoords , nodeCoords ): \"\"\"Compute the real coordinates of a point in isoparametric space Parameters ---------- paramCoords : n x numDim array isoparametric coordinates, one row for each point in isoparametric space to be converted nodeCoords : numNode x numDim array Element node real coordinates Returns ------- coords : n x nD array Point coordinates in real space \"\"\" N = self . getShapeFunctions ( paramCoords ) return N [:, : self . numNodes ] @ nodeCoords","title":"getRealCoord()"},{"location":"Elements/Element/#FEMpy.Element.Element.getShapeFunctionDerivs","text":"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) This function must be implemented in any child classes Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numDim x numNode array Shape function values, N i [k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate Source code in FEMpy/Element.py @abc . abstractmethod def getShapeFunctionDerivs ( self , paramCoords ): \"\"\"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) This function must be implemented in any child classes Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- NPrimeParam : n x numDim x numNode array Shape function values, N[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" raise NotImplementedError","title":"getShapeFunctionDerivs()"},{"location":"Elements/Element/#FEMpy.Element.Element.getShapeFunctions","text":"Compute shape function values at a set of parametric coordinates This function must be implemented in any child classes Parameters: Name Type Description Default paramCoords n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numNode array Shape function values, N i is the value of the jth shape function at the ith point Source code in FEMpy/Element.py @abc . abstractmethod def getShapeFunctions ( self , paramCoords ): \"\"\"Compute shape function values at a set of parametric coordinates This function must be implemented in any child classes Parameters ---------- paramCoords : n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- N : n x numNode array Shape function values, N[i][j] is the value of the jth shape function at the ith point \"\"\" raise NotImplementedError","title":"getShapeFunctions()"},{"location":"Elements/Element/#FEMpy.Element.Element.getStiffnessIntegrand","text":"Source code in FEMpy/Element.py def getStiffnessIntegrand ( self , paramCoords , nodeCoords , constitutive ): B = self . getBMat ( paramCoords , nodeCoords , constitutive ) J = self . getJacobian ( paramCoords , nodeCoords ) detJ = self . jacDet ( J ) BDB = np . swapaxes ( B , 1 , 2 ) @ constitutive . DMat @ B return ( BDB . T * detJ ) . T","title":"getStiffnessIntegrand()"},{"location":"Elements/Element/#FEMpy.Element.Element.getStiffnessMat","text":"Source code in FEMpy/Element.py def getStiffnessMat ( self , nodeCoords , constitutive , n = None ): if n is None : n = self . order + 1 if self . numDim == 1 : f = lambda x1 : self . getStiffnessIntegrand ( np . array ([ x1 ]) . T , nodeCoords , constitutive ) # noqa: E731 return gaussQuad1d ( f = f , n = n ) if self . numDim == 2 : f = lambda x1 , x2 : self . getStiffnessIntegrand ( np . array ([ x1 , x2 ]) . T , nodeCoords , constitutive ) # noqa: E731 return gaussQuad2d ( f = f , n = n ) if self . numDim == 3 : f = lambda x1 , x2 , x3 : self . getStiffnessIntegrand ( # noqa: E731 np . array ([ x1 , x2 , x3 ]) . T , nodeCoords , constitutive ) return gaussQuad3d ( f , n )","title":"getStiffnessMat()"},{"location":"Elements/Element/#FEMpy.Element.Element.getStrain","text":"Source code in FEMpy/Element.py def getStrain ( self , paramCoords , nodeCoords , constitutive , uNodes ): BMat = self . getBMat ( paramCoords , nodeCoords , constitutive ) return BMat @ uNodes . flatten ()","title":"getStrain()"},{"location":"Elements/Element/#FEMpy.Element.Element.getStress","text":"Source code in FEMpy/Element.py def getStress ( self , paramCoords , nodeCoords , constitutive , uNodes ): return self . getStrain ( paramCoords , nodeCoords , constitutive , uNodes ) @ constitutive . DMat","title":"getStress()"},{"location":"Elements/Element/#FEMpy.Element.Element.getU","text":"Compute the displacements at a set of parametric coordinates Parameters: Name Type Description Default paramCoords n x numDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required uNodes numNode x numDim array Nodal displacements required Returns: Type Description n x numDim array Array of displacement values, u[i,j] is the jth displacement component at the ith point Source code in FEMpy/Element.py def getU ( self , paramCoords , uNodes ): \"\"\"Compute the displacements at a set of parametric coordinates Parameters ---------- paramCoords : n x numDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at uNodes : numNode x numDim array Nodal displacements Returns ------- u : n x numDim array Array of displacement values, u[i,j] is the jth displacement component at the ith point \"\"\" N = self . getShapeFunctions ( paramCoords ) return N @ uNodes","title":"getU()"},{"location":"Elements/Element/#FEMpy.Element.Element.getUPrime","text":"Compute the displacement derivatives at a set of parametric coordinates Parameters: Name Type Description Default paramCoords n x numDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required nodeCoords numNode x numDim array Element node real coordinates required uNodes numNode x numDim array Nodal displacements required Returns: Type Description n x numDim x numNode array [description] Source code in FEMpy/Element.py def getUPrime ( self , paramCoords , nodeCoords , uNodes ): \"\"\"Compute the displacement derivatives at a set of parametric coordinates Parameters ---------- paramCoords : n x numDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at nodeCoords : numNode x numDim array Element node real coordinates uNodes : numNode x numDim array Nodal displacements Returns ------- NPrime : n x numDim x numNode array [description] \"\"\" NPrime = self . getNPrime ( paramCoords , nodeCoords ) return NPrime @ uNodes","title":"getUPrime()"},{"location":"Elements/Element/#FEMpy.Element.Element.integrateBodyForce","text":"Compute equivalent nodal forces due to body forces through numerical integration Parameters: Name Type Description Default f Body force function Should accept an nP x numDim array as input and output a nP x numDisp array, ie f(x)[i] returns the body force components at the ith point queried required nodeCoords numNode x numDim array Element node real coordinates required n int Number of integration points, can be a single value or a list with a value for each direction, by default 1 1 Returns: Type Description numNode x numDisp array Equivalent nodal loads due to body force Source code in FEMpy/Element.py def integrateBodyForce ( self , f , nodeCoords , n = 1 ): \"\"\"Compute equivalent nodal forces due to body forces through numerical integration Parameters ---------- f : Body force function Should accept an nP x numDim array as input and output a nP x numDisp array, ie f(x)[i] returns the body force components at the ith point queried nodeCoords : numNode x numDim array Element node real coordinates n : int, optional Number of integration points, can be a single value or a list with a value for each direction, by default 1 Returns ------- Fb : numNode x numDisp array Equivalent nodal loads due to body force \"\"\" if self . numDim == 1 : bodyForceFunc = lambda x1 : self . bodyForceIntegrad ( f , np . array ([ x1 ]) . T , nodeCoords ) # noqa: E731 return gaussQuad1d ( bodyForceFunc , n ) if self . numDim == 2 : bodyForceFunc = lambda x1 , x2 : self . bodyForceIntegrad ( f , np . array ([ x1 , x2 ]) . T , nodeCoords ) # noqa: E731 return gaussQuad2d ( bodyForceFunc , n ) if self . numDim == 3 : bodyForceFunc = lambda x1 , x2 , x3 : self . bodyForceIntegrad ( # noqa: E731 f , np . array ([ x1 , x2 , x3 ]) . T , nodeCoords ) return gaussQuad3d ( bodyForceFunc , n )","title":"integrateBodyForce()"},{"location":"Elements/Element/#FEMpy.Element.Element.testGetParamCoord","text":"Test the getParamCoord method This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getParamCoord match the original random values. Parameters: Name Type Description Default n int Number of random coordinates to generate, by default 10 10 Source code in FEMpy/Element.py def testGetParamCoord ( self , n = 10 , maxIter = 40 , tol = 1e-10 ): \"\"\"Test the getParamCoord method This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getParamCoord match the original random values. Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 \"\"\" paramCoord = self . getRandParamCoord ( n ) nodeCoords = self . getRandomNodeCoords () realCoords = self . getRealCoord ( paramCoord , nodeCoords ) error = np . zeros_like ( realCoords ) for i in range ( n ): error [ i ] = paramCoord [ i ] - self . getParamCoord ( realCoords [ i ], nodeCoords , maxIter = maxIter , tol = tol ) return error","title":"testGetParamCoord()"},{"location":"Elements/Element/#FEMpy.Element.Element.testShapeFunctionDerivatives","text":"Test the implementation of the shape function derivatives using the complex-step method Parameters: Name Type Description Default n int Number of random coordinates to generate, by default 10 10 Source code in FEMpy/Element.py def testShapeFunctionDerivatives ( self , n = 10 ): \"\"\"Test the implementation of the shape function derivatives using the complex-step method Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 \"\"\" paramCoords = self . getRandParamCoord ( n ) coordPert = np . zeros_like ( paramCoords , dtype = \"complex128\" ) dN = self . getShapeFunctionDerivs ( paramCoords ) dNApprox = np . zeros_like ( dN ) for i in range ( self . numDim ): np . copyto ( coordPert , paramCoords ) coordPert [:, i ] += 1e-200 * 1 j dNApprox [:, i , :] = 1e200 * np . imag ( self . getShapeFunctions ( coordPert )) return dN - dNApprox","title":"testShapeFunctionDerivatives()"},{"location":"Elements/Element/#FEMpy.Element.Element.testShapeFunctionSum","text":"Test the basic property that shape function values should sum to 1 everywhere within an element Parameters: Name Type Description Default n int Number of points to test at, by default 10 10 Source code in FEMpy/Element.py def testShapeFunctionSum ( self , n = 10 ): \"\"\"Test the basic property that shape function values should sum to 1 everywhere within an element Parameters ---------- n : int, optional Number of points to test at, by default 10 \"\"\" paramCoords = self . getRandParamCoord ( n ) N = self . getShapeFunctions ( paramCoords ) return np . sum ( N , axis = 1 )","title":"testShapeFunctionSum()"},{"location":"Elements/Lagrange1dElement/","text":"1D Line Element An arbitrary order 1D finite element using Lagrange polynomial shape functions __init__ ( self , order ) special Initialise an arbitrary order 1D finite element Parameters: Name Type Description Default order int Shape function polynomial order required Source code in FEMpy/Lagrange1dElement.py def __init__ ( self , order ): \"\"\"Initialise an arbitrary order 1D finite element Parameters ---------- order : int Shape function polynomial order \"\"\" self . order = order super () . __init__ ( numNodes = order + 1 , numDimensions = 1 ) self . name = f \"Order { self . order } -Lagrange1D\" getMassMat ( self , nodeCoords , constitutive , n = None ) Source code in FEMpy/Lagrange1dElement.py def getMassMat ( self , nodeCoords , constitutive , n = None ): return super () . getMassMat ( nodeCoords , constitutive , n = n ) * constitutive . A getRandomNodeCoords ( self ) Generate a random, but valid, set of node coordinates for an element For a 1D element, we simply create evenly spaced points from 0 to one, add some slight random noise and then apply a random scaling factor Returns: Type Description numNode x numDim array Node coordinates Source code in FEMpy/Lagrange1dElement.py def getRandomNodeCoords ( self ): \"\"\"Generate a random, but valid, set of node coordinates for an element For a 1D element, we simply create evenly spaced points from 0 to one, add some slight random noise and then apply a random scaling factor Returns ------- nodeCoords : numNode x numDim array Node coordinates \"\"\" nodeCoords = np . random . rand ( self . numNodes , 1 ) * 0.1 nodeCoords [:, 0 ] += np . linspace ( 0 , 1 , self . numNodes ) return nodeCoords * np . random . rand ( 1 ) getShapeFunctionDerivs ( self , paramCoords ) Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) This function returns a zero array and should be re-implemented in any child classes Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numDim x numNode array Shape function values, N i is the value of the jth shape function at the ith point Source code in FEMpy/Lagrange1dElement.py def getShapeFunctionDerivs ( self , paramCoords ): \"\"\"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) This function returns a zero array and should be re-implemented in any child classes Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- NPrime : n x numDim x numNode array Shape function values, N[i][j] is the value of the jth shape function at the ith point \"\"\" NPrime = np . zeros (( np . shape ( paramCoords )[ 0 ], np . shape ( paramCoords )[ 1 ], self . numNodes )) NPrime [:, 0 , :] = LagrangePoly1dDeriv ( paramCoords , n = self . order + 1 ) return NPrime getShapeFunctions ( self , paramCoords ) Compute shape function values at a set of parametric coordinates This function returns a zero array and should be re-implemented in any child classes Parameters: Name Type Description Default paramCoords n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numNode array Shape function values, N i is the value of the jth shape function at the ith point Source code in FEMpy/Lagrange1dElement.py def getShapeFunctions ( self , paramCoords ): \"\"\"Compute shape function values at a set of parametric coordinates This function returns a zero array and should be re-implemented in any child classes Parameters ---------- paramCoords : n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- N : n x numNode array Shape function values, N[i][j] is the value of the jth shape function at the ith point \"\"\" return LagrangePoly1d ( paramCoords , n = self . order + 1 ) getStiffnessMat ( self , nodeCoords , constitutive , n = None ) Source code in FEMpy/Lagrange1dElement.py def getStiffnessMat ( self , nodeCoords , constitutive , n = None ): return super () . getStiffnessMat ( nodeCoords , constitutive , n = n ) * constitutive . A","title":"1D Line Element"},{"location":"Elements/Lagrange1dElement/#1d-line-element","text":"An arbitrary order 1D finite element using Lagrange polynomial shape functions","title":"1D Line Element"},{"location":"Elements/Lagrange1dElement/#FEMpy.Lagrange1dElement.Lagrange1dElement.__init__","text":"Initialise an arbitrary order 1D finite element Parameters: Name Type Description Default order int Shape function polynomial order required Source code in FEMpy/Lagrange1dElement.py def __init__ ( self , order ): \"\"\"Initialise an arbitrary order 1D finite element Parameters ---------- order : int Shape function polynomial order \"\"\" self . order = order super () . __init__ ( numNodes = order + 1 , numDimensions = 1 ) self . name = f \"Order { self . order } -Lagrange1D\"","title":"__init__()"},{"location":"Elements/Lagrange1dElement/#FEMpy.Lagrange1dElement.Lagrange1dElement.getMassMat","text":"Source code in FEMpy/Lagrange1dElement.py def getMassMat ( self , nodeCoords , constitutive , n = None ): return super () . getMassMat ( nodeCoords , constitutive , n = n ) * constitutive . A","title":"getMassMat()"},{"location":"Elements/Lagrange1dElement/#FEMpy.Lagrange1dElement.Lagrange1dElement.getRandomNodeCoords","text":"Generate a random, but valid, set of node coordinates for an element For a 1D element, we simply create evenly spaced points from 0 to one, add some slight random noise and then apply a random scaling factor Returns: Type Description numNode x numDim array Node coordinates Source code in FEMpy/Lagrange1dElement.py def getRandomNodeCoords ( self ): \"\"\"Generate a random, but valid, set of node coordinates for an element For a 1D element, we simply create evenly spaced points from 0 to one, add some slight random noise and then apply a random scaling factor Returns ------- nodeCoords : numNode x numDim array Node coordinates \"\"\" nodeCoords = np . random . rand ( self . numNodes , 1 ) * 0.1 nodeCoords [:, 0 ] += np . linspace ( 0 , 1 , self . numNodes ) return nodeCoords * np . random . rand ( 1 )","title":"getRandomNodeCoords()"},{"location":"Elements/Lagrange1dElement/#FEMpy.Lagrange1dElement.Lagrange1dElement.getShapeFunctionDerivs","text":"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) This function returns a zero array and should be re-implemented in any child classes Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numDim x numNode array Shape function values, N i is the value of the jth shape function at the ith point Source code in FEMpy/Lagrange1dElement.py def getShapeFunctionDerivs ( self , paramCoords ): \"\"\"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) This function returns a zero array and should be re-implemented in any child classes Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- NPrime : n x numDim x numNode array Shape function values, N[i][j] is the value of the jth shape function at the ith point \"\"\" NPrime = np . zeros (( np . shape ( paramCoords )[ 0 ], np . shape ( paramCoords )[ 1 ], self . numNodes )) NPrime [:, 0 , :] = LagrangePoly1dDeriv ( paramCoords , n = self . order + 1 ) return NPrime","title":"getShapeFunctionDerivs()"},{"location":"Elements/Lagrange1dElement/#FEMpy.Lagrange1dElement.Lagrange1dElement.getShapeFunctions","text":"Compute shape function values at a set of parametric coordinates This function returns a zero array and should be re-implemented in any child classes Parameters: Name Type Description Default paramCoords n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numNode array Shape function values, N i is the value of the jth shape function at the ith point Source code in FEMpy/Lagrange1dElement.py def getShapeFunctions ( self , paramCoords ): \"\"\"Compute shape function values at a set of parametric coordinates This function returns a zero array and should be re-implemented in any child classes Parameters ---------- paramCoords : n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- N : n x numNode array Shape function values, N[i][j] is the value of the jth shape function at the ith point \"\"\" return LagrangePoly1d ( paramCoords , n = self . order + 1 )","title":"getShapeFunctions()"},{"location":"Elements/Lagrange1dElement/#FEMpy.Lagrange1dElement.Lagrange1dElement.getStiffnessMat","text":"Source code in FEMpy/Lagrange1dElement.py def getStiffnessMat ( self , nodeCoords , constitutive , n = None ): return super () . getStiffnessMat ( nodeCoords , constitutive , n = n ) * constitutive . A","title":"getStiffnessMat()"},{"location":"Elements/QuadElement/","text":"2D Quad Element __init__ ( self , order = 1 , numDisplacements = 2 ) special Instantiate an arbitrary order 2d quadrilateral finite element Note that this element does not use the typical CCW node ordering, to make it simpler to work with arbitrary element orders, the nodes are ordered left to right followed by bottom to top, so for a 1 st order element the ordering is: 1) Bottom left 2) Bottom Right 3) Top left 4) Top right Parameters: Name Type Description Default order int Element order, by default 1 1 numDisplacements int Number of variables at each node, by default 2 2 Source code in FEMpy/QuadElement.py def __init__ ( self , order = 1 , numDisplacements = 2 ): \"\"\"Instantiate an arbitrary order 2d quadrilateral finite element Note that this element does not use the typical CCW node ordering, to make it simpler to work with arbitrary element orders, the nodes are ordered left to right followed by bottom to top, so for a 1st order element the ordering is: 1) Bottom left 2) Bottom Right 3) Top left 4) Top right Parameters ---------- order : int, optional Element order, by default 1 numDisplacements : int, optional Number of variables at each node, by default 2 \"\"\" self . order = order nodes = ( order + 1 ) ** 2 super () . __init__ ( numNodes = nodes , numDimensions = 2 , numDisplacements = numDisplacements ) # bottom, right, top, left order, # 0 means psi varies along edge, 1 means eta varies along edge self . edgeFreeCoord = [ 0 , 1 , 0 , 1 ] # value of the fixed coordinate on each edge self . edgeFixedCoord = [ - 1.0 , 1.0 , 1.0 , - 1.0 ] self . name = f \"Order { self . order } -LagrangeQuad\" getRandomNodeCoords ( self ) Generate a random, but valid, set of node coordinates for an element For the Quad element, we simply create a grid of evenly spaced points then add some random noise to each point before applying a random scaling and rotation Returns: Type Description numNode x numDim array Node coordinates Source code in FEMpy/QuadElement.py def getRandomNodeCoords ( self ): \"\"\"Generate a random, but valid, set of node coordinates for an element For the Quad element, we simply create a grid of evenly spaced points then add some random noise to each point before applying a random scaling and rotation Returns ------- nodeCoords : numNode x numDim array Node coordinates \"\"\" xy = np . linspace ( 0 , 1 , self . order + 1 ) nodeCoords = np . random . rand (( self . order + 1 ) ** 2 , self . numDim ) * 0.1 nodeCoords [:, 0 ] += np . tile ( xy , self . order + 1 ) nodeCoords [:, 1 ] += np . repeat ( xy , self . order + 1 ) nodeCoords *= np . random . rand ( 1 ) theta = np . random . rand ( 1 ) * np . pi R = np . array ([[ np . cos ( theta ), - np . sin ( theta )], [ np . sin ( theta ), np . cos ( theta )]])[:, :, 0 ] return ( R @ nodeCoords . T ) . T getShapeFunctionDerivs ( self , paramCoords ) Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numDim x numNode array Shape function values, N i [k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate Source code in FEMpy/QuadElement.py def getShapeFunctionDerivs ( self , paramCoords ): \"\"\"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- NPrime : n x numDim x numNode array Shape function values, N[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" return LP . LagrangePoly2dDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 ) getShapeFunctions ( self , paramCoords ) Compute shape function values at a set of parametric coordinates Parameters: Name Type Description Default paramCoords n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numNode array Shape function values, N i is the value of the jth shape function at the ith point Source code in FEMpy/QuadElement.py def getShapeFunctions ( self , paramCoords ): \"\"\"Compute shape function values at a set of parametric coordinates Parameters ---------- paramCoords : n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- N : n x numNode array Shape function values, N[i][j] is the value of the jth shape function at the ith point \"\"\" return LP . LagrangePoly2d ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 ) getStiffnessMat ( self , nodeCoords , constitutive , n = None ) Source code in FEMpy/QuadElement.py def getStiffnessMat ( self , nodeCoords , constitutive , n = None ): # TODO: this function should not presume the constitutive object has a thickness, what if you want to use this # quad element for something else, like 2D heat transfer where there's no thickness return super () . getStiffnessMat ( nodeCoords , constitutive , n = n ) * constitutive . t integrateBodyForce ( self , f , nodeCoords , constitutive , n = 1 ) Compute equivalent nodal forces due to body forces through numerical integration Parameters: Name Type Description Default f Body force function Should accept an nP x numDim array as input and output a nP x numDisp array, ie f(x)[i] returns the body force components at the ith point queried required nodeCoords numNode x numDim array Element node real coordinates required n int Number of integration points, can be a single value or a list with a value for each direction, by default 1 1 Returns: Type Description numNode x numDisp array Equivalent nodal loads due to body force Source code in FEMpy/QuadElement.py def integrateBodyForce ( self , f , nodeCoords , constitutive , n = 1 ): # TODO: this function should not presume the constitutive object has a thickness, what if you want to use this # quad element for something else, like 2D heat transfer where there's no thickness return super () . integrateBodyForce ( f , nodeCoords , n = n ) * constitutive . t integrateTraction ( self , f , nodeCoords , constitutive , edges = None , n = 1 ) Compute equivalent nodal forces due to body forces through numerical integration Parameters: Name Type Description Default f Body force function Should accept an nP x numDim array as input and output a nP x numDisp array, ie f(x)[i] returns the body force components at the ith point queried required nodeCoords numNode x numDim array Element node real coordinates required n int Number of integration points, can be a single value or a list with a value for each direction, by default 1 1 constitutive [type] [description] required edges list [description], by default [1,2,3,4] None Returns: Type Description numNode x numDisp array Equivalent nodal loads due to traction forces force Source code in FEMpy/QuadElement.py def integrateTraction ( self , f , nodeCoords , constitutive , edges = None , n = 1 ): \"\"\"Compute equivalent nodal forces due to body forces through numerical integration Parameters ---------- f : Body force function Should accept an nP x numDim array as input and output a nP x numDisp array, ie f(x)[i] returns the body force components at the ith point queried nodeCoords : numNode x numDim array Element node real coordinates n : int, optional Number of integration points, can be a single value or a list with a value for each direction, by default 1 constitutive : [type] [description] edges : list, optional [description], by default [1,2,3,4] Returns ------- Fb : numNode x numDisp array Equivalent nodal loads due to traction forces force \"\"\" if edges is None : edges = [ 0 , 1 , 2 , 3 ] if isinstance ( edges , ( int , np . integer )): edges = [ edges ] Ft = np . zeros (( self . numNodes , self . numDisp )) for e in edges : if self . edgeFreeCoord [ e ] == 0 : func = lambda x1 : self . tractionIntegrand ( # noqa: E731 f , np . array ([ x1 , self . edgeFixedCoord [ e ] * np . ones_like ( x1 )]) . T , nodeCoords , e ) else : func = lambda x2 : self . tractionIntegrand ( # noqa: E731 f , np . array ([ self . edgeFixedCoord [ e ] * np . ones_like ( x2 ), x2 ]) . T , nodeCoords , e ) Ft += gaussQuad1d ( func , n ) return Ft * constitutive . t tractionIntegrand ( self , f , paramCoord , nodeCoords , edgeNum ) Source code in FEMpy/QuadElement.py def tractionIntegrand ( self , f , paramCoord , nodeCoords , edgeNum ): # Compute shape functions and Jacobian determinant at parametric coordinates N = self . getShapeFunctions ( paramCoord ) J = self . getJacobian ( paramCoord , nodeCoords ) detJStar = np . linalg . norm ( J [:, self . edgeFreeCoord [ edgeNum ], :], axis =- 1 ) # Transform parametric to real coordinates in order to compute body force components realCoord = self . getRealCoord ( paramCoord , nodeCoords ) F = f ( realCoord ) # Compute N^T fb at each point Fb = self . _computeNTFProduct ( F , N ) return ( Fb . T * detJStar ) . T","title":"2D Quad"},{"location":"Elements/QuadElement/#2d-quad-element","text":"","title":"2D Quad Element"},{"location":"Elements/QuadElement/#FEMpy.QuadElement.QuadElement.__init__","text":"Instantiate an arbitrary order 2d quadrilateral finite element Note that this element does not use the typical CCW node ordering, to make it simpler to work with arbitrary element orders, the nodes are ordered left to right followed by bottom to top, so for a 1 st order element the ordering is: 1) Bottom left 2) Bottom Right 3) Top left 4) Top right Parameters: Name Type Description Default order int Element order, by default 1 1 numDisplacements int Number of variables at each node, by default 2 2 Source code in FEMpy/QuadElement.py def __init__ ( self , order = 1 , numDisplacements = 2 ): \"\"\"Instantiate an arbitrary order 2d quadrilateral finite element Note that this element does not use the typical CCW node ordering, to make it simpler to work with arbitrary element orders, the nodes are ordered left to right followed by bottom to top, so for a 1st order element the ordering is: 1) Bottom left 2) Bottom Right 3) Top left 4) Top right Parameters ---------- order : int, optional Element order, by default 1 numDisplacements : int, optional Number of variables at each node, by default 2 \"\"\" self . order = order nodes = ( order + 1 ) ** 2 super () . __init__ ( numNodes = nodes , numDimensions = 2 , numDisplacements = numDisplacements ) # bottom, right, top, left order, # 0 means psi varies along edge, 1 means eta varies along edge self . edgeFreeCoord = [ 0 , 1 , 0 , 1 ] # value of the fixed coordinate on each edge self . edgeFixedCoord = [ - 1.0 , 1.0 , 1.0 , - 1.0 ] self . name = f \"Order { self . order } -LagrangeQuad\"","title":"__init__()"},{"location":"Elements/QuadElement/#FEMpy.QuadElement.QuadElement.getRandomNodeCoords","text":"Generate a random, but valid, set of node coordinates for an element For the Quad element, we simply create a grid of evenly spaced points then add some random noise to each point before applying a random scaling and rotation Returns: Type Description numNode x numDim array Node coordinates Source code in FEMpy/QuadElement.py def getRandomNodeCoords ( self ): \"\"\"Generate a random, but valid, set of node coordinates for an element For the Quad element, we simply create a grid of evenly spaced points then add some random noise to each point before applying a random scaling and rotation Returns ------- nodeCoords : numNode x numDim array Node coordinates \"\"\" xy = np . linspace ( 0 , 1 , self . order + 1 ) nodeCoords = np . random . rand (( self . order + 1 ) ** 2 , self . numDim ) * 0.1 nodeCoords [:, 0 ] += np . tile ( xy , self . order + 1 ) nodeCoords [:, 1 ] += np . repeat ( xy , self . order + 1 ) nodeCoords *= np . random . rand ( 1 ) theta = np . random . rand ( 1 ) * np . pi R = np . array ([[ np . cos ( theta ), - np . sin ( theta )], [ np . sin ( theta ), np . cos ( theta )]])[:, :, 0 ] return ( R @ nodeCoords . T ) . T","title":"getRandomNodeCoords()"},{"location":"Elements/QuadElement/#FEMpy.QuadElement.QuadElement.getShapeFunctionDerivs","text":"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numDim x numNode array Shape function values, N i [k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate Source code in FEMpy/QuadElement.py def getShapeFunctionDerivs ( self , paramCoords ): \"\"\"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- NPrime : n x numDim x numNode array Shape function values, N[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" return LP . LagrangePoly2dDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 )","title":"getShapeFunctionDerivs()"},{"location":"Elements/QuadElement/#FEMpy.QuadElement.QuadElement.getShapeFunctions","text":"Compute shape function values at a set of parametric coordinates Parameters: Name Type Description Default paramCoords n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numNode array Shape function values, N i is the value of the jth shape function at the ith point Source code in FEMpy/QuadElement.py def getShapeFunctions ( self , paramCoords ): \"\"\"Compute shape function values at a set of parametric coordinates Parameters ---------- paramCoords : n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- N : n x numNode array Shape function values, N[i][j] is the value of the jth shape function at the ith point \"\"\" return LP . LagrangePoly2d ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 )","title":"getShapeFunctions()"},{"location":"Elements/QuadElement/#FEMpy.QuadElement.QuadElement.getStiffnessMat","text":"Source code in FEMpy/QuadElement.py def getStiffnessMat ( self , nodeCoords , constitutive , n = None ): # TODO: this function should not presume the constitutive object has a thickness, what if you want to use this # quad element for something else, like 2D heat transfer where there's no thickness return super () . getStiffnessMat ( nodeCoords , constitutive , n = n ) * constitutive . t","title":"getStiffnessMat()"},{"location":"Elements/QuadElement/#FEMpy.QuadElement.QuadElement.integrateBodyForce","text":"Compute equivalent nodal forces due to body forces through numerical integration Parameters: Name Type Description Default f Body force function Should accept an nP x numDim array as input and output a nP x numDisp array, ie f(x)[i] returns the body force components at the ith point queried required nodeCoords numNode x numDim array Element node real coordinates required n int Number of integration points, can be a single value or a list with a value for each direction, by default 1 1 Returns: Type Description numNode x numDisp array Equivalent nodal loads due to body force Source code in FEMpy/QuadElement.py def integrateBodyForce ( self , f , nodeCoords , constitutive , n = 1 ): # TODO: this function should not presume the constitutive object has a thickness, what if you want to use this # quad element for something else, like 2D heat transfer where there's no thickness return super () . integrateBodyForce ( f , nodeCoords , n = n ) * constitutive . t","title":"integrateBodyForce()"},{"location":"Elements/QuadElement/#FEMpy.QuadElement.QuadElement.integrateTraction","text":"Compute equivalent nodal forces due to body forces through numerical integration Parameters: Name Type Description Default f Body force function Should accept an nP x numDim array as input and output a nP x numDisp array, ie f(x)[i] returns the body force components at the ith point queried required nodeCoords numNode x numDim array Element node real coordinates required n int Number of integration points, can be a single value or a list with a value for each direction, by default 1 1 constitutive [type] [description] required edges list [description], by default [1,2,3,4] None Returns: Type Description numNode x numDisp array Equivalent nodal loads due to traction forces force Source code in FEMpy/QuadElement.py def integrateTraction ( self , f , nodeCoords , constitutive , edges = None , n = 1 ): \"\"\"Compute equivalent nodal forces due to body forces through numerical integration Parameters ---------- f : Body force function Should accept an nP x numDim array as input and output a nP x numDisp array, ie f(x)[i] returns the body force components at the ith point queried nodeCoords : numNode x numDim array Element node real coordinates n : int, optional Number of integration points, can be a single value or a list with a value for each direction, by default 1 constitutive : [type] [description] edges : list, optional [description], by default [1,2,3,4] Returns ------- Fb : numNode x numDisp array Equivalent nodal loads due to traction forces force \"\"\" if edges is None : edges = [ 0 , 1 , 2 , 3 ] if isinstance ( edges , ( int , np . integer )): edges = [ edges ] Ft = np . zeros (( self . numNodes , self . numDisp )) for e in edges : if self . edgeFreeCoord [ e ] == 0 : func = lambda x1 : self . tractionIntegrand ( # noqa: E731 f , np . array ([ x1 , self . edgeFixedCoord [ e ] * np . ones_like ( x1 )]) . T , nodeCoords , e ) else : func = lambda x2 : self . tractionIntegrand ( # noqa: E731 f , np . array ([ self . edgeFixedCoord [ e ] * np . ones_like ( x2 ), x2 ]) . T , nodeCoords , e ) Ft += gaussQuad1d ( func , n ) return Ft * constitutive . t","title":"integrateTraction()"},{"location":"Elements/QuadElement/#FEMpy.QuadElement.QuadElement.tractionIntegrand","text":"Source code in FEMpy/QuadElement.py def tractionIntegrand ( self , f , paramCoord , nodeCoords , edgeNum ): # Compute shape functions and Jacobian determinant at parametric coordinates N = self . getShapeFunctions ( paramCoord ) J = self . getJacobian ( paramCoord , nodeCoords ) detJStar = np . linalg . norm ( J [:, self . edgeFreeCoord [ edgeNum ], :], axis =- 1 ) # Transform parametric to real coordinates in order to compute body force components realCoord = self . getRealCoord ( paramCoord , nodeCoords ) F = f ( realCoord ) # Compute N^T fb at each point Fb = self . _computeNTFProduct ( F , N ) return ( Fb . T * detJStar ) . T","title":"tractionIntegrand()"},{"location":"Elements/SerendipityQuad/","text":"Serendipity Quad Element An 8 noded quadratic quad element, also known as a seredipity quad __init__ ( self , numDisplacements = 2 ) special Source code in FEMpy/SerendipityQuad.py def __init__ ( self , numDisplacements = 2 ): # --- Initialise a 9 noded quad and then change the number of nodes to 8 --- super () . __init__ ( order = 2 , numDisplacements = numDisplacements ) self . numNodes = 8 self . numDOF = self . numNodes * numDisplacements self . name = \"SerendipityQuad\" getRandomNodeCoords ( self ) Generate a random, but valid, set of node coordinates for an element Here we simply call the getRandomNodeCoords method of the parent 2 nd order QuadElement class and then remove the central point, the points need to be reordered too because the 2 nd order QuadElement points are not in CCW order as the Serendipity quad points are Returns: Type Description numNode x numDim array Node coordinates Source code in FEMpy/SerendipityQuad.py def getRandomNodeCoords ( self ): \"\"\"Generate a random, but valid, set of node coordinates for an element Here we simply call the getRandomNodeCoords method of the parent 2nd order QuadElement class and then remove the central point, the points need to be reordered too because the 2nd order QuadElement points are not in CCW order as the Serendipity quad points are Returns ------- nodeCoords : numNode x numDim array Node coordinates \"\"\" nodeCoords = super () . getRandomNodeCoords () return nodeCoords [[ 0 , 2 , 8 , 6 , 1 , 5 , 7 , 3 ]] getShapeFunctionDerivs ( self , paramCoords ) Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numDim x numNode array Shape function derivative values, N i [k] is the value of the derivative of the kth shape function in the jth direction at the ith point Source code in FEMpy/SerendipityQuad.py def getShapeFunctionDerivs ( self , paramCoords ): \"\"\"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- NPrime : n x numDim x numNode array Shape function derivative values, N[i][j][k] is the value of the derivative of the kth shape function in the jth direction at the ith point \"\"\" return serendipityShapeFuncDerivs ( paramCoords [:, 0 ], paramCoords [:, 1 ]) getShapeFunctions ( self , paramCoords ) Compute shape function values at a set of parametric coordinates Parameters: Name Type Description Default paramCoords n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numNode array Shape function values, N i is the value of the jth shape function at the ith point Source code in FEMpy/SerendipityQuad.py def getShapeFunctions ( self , paramCoords ): \"\"\"Compute shape function values at a set of parametric coordinates Parameters ---------- paramCoords : n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- N : n x numNode array Shape function values, N[i][j] is the value of the jth shape function at the ith point \"\"\" return serendipityShapeFuncs ( paramCoords [:, 0 ], paramCoords [:, 1 ])","title":"Serendipity Quad"},{"location":"Elements/SerendipityQuad/#serendipity-quad-element","text":"An 8 noded quadratic quad element, also known as a seredipity quad","title":"Serendipity Quad Element"},{"location":"Elements/SerendipityQuad/#FEMpy.SerendipityQuad.serendipityQuadElement.__init__","text":"Source code in FEMpy/SerendipityQuad.py def __init__ ( self , numDisplacements = 2 ): # --- Initialise a 9 noded quad and then change the number of nodes to 8 --- super () . __init__ ( order = 2 , numDisplacements = numDisplacements ) self . numNodes = 8 self . numDOF = self . numNodes * numDisplacements self . name = \"SerendipityQuad\"","title":"__init__()"},{"location":"Elements/SerendipityQuad/#FEMpy.SerendipityQuad.serendipityQuadElement.getRandomNodeCoords","text":"Generate a random, but valid, set of node coordinates for an element Here we simply call the getRandomNodeCoords method of the parent 2 nd order QuadElement class and then remove the central point, the points need to be reordered too because the 2 nd order QuadElement points are not in CCW order as the Serendipity quad points are Returns: Type Description numNode x numDim array Node coordinates Source code in FEMpy/SerendipityQuad.py def getRandomNodeCoords ( self ): \"\"\"Generate a random, but valid, set of node coordinates for an element Here we simply call the getRandomNodeCoords method of the parent 2nd order QuadElement class and then remove the central point, the points need to be reordered too because the 2nd order QuadElement points are not in CCW order as the Serendipity quad points are Returns ------- nodeCoords : numNode x numDim array Node coordinates \"\"\" nodeCoords = super () . getRandomNodeCoords () return nodeCoords [[ 0 , 2 , 8 , 6 , 1 , 5 , 7 , 3 ]]","title":"getRandomNodeCoords()"},{"location":"Elements/SerendipityQuad/#FEMpy.SerendipityQuad.serendipityQuadElement.getShapeFunctionDerivs","text":"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) Parameters: Name Type Description Default paramCoords n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numDim x numNode array Shape function derivative values, N i [k] is the value of the derivative of the kth shape function in the jth direction at the ith point Source code in FEMpy/SerendipityQuad.py def getShapeFunctionDerivs ( self , paramCoords ): \"\"\"Compute shape function derivatives at a set of parametric coordinates These are the derivatives of the shape functions with respect to the parametric coordinates (si, eta, gamma) Parameters ---------- paramCoords : n x nD array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- NPrime : n x numDim x numNode array Shape function derivative values, N[i][j][k] is the value of the derivative of the kth shape function in the jth direction at the ith point \"\"\" return serendipityShapeFuncDerivs ( paramCoords [:, 0 ], paramCoords [:, 1 ])","title":"getShapeFunctionDerivs()"},{"location":"Elements/SerendipityQuad/#FEMpy.SerendipityQuad.serendipityQuadElement.getShapeFunctions","text":"Compute shape function values at a set of parametric coordinates Parameters: Name Type Description Default paramCoords n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at required Returns: Type Description n x numNode array Shape function values, N i is the value of the jth shape function at the ith point Source code in FEMpy/SerendipityQuad.py def getShapeFunctions ( self , paramCoords ): \"\"\"Compute shape function values at a set of parametric coordinates Parameters ---------- paramCoords : n x nDim array isoparametric coordinates, one row for each point in isoparametric space to compute the Jacobian at Returns ------- N : n x numNode array Shape function values, N[i][j] is the value of the jth shape function at the ith point \"\"\" return serendipityShapeFuncs ( paramCoords [:, 0 ], paramCoords [:, 1 ])","title":"getShapeFunctions()"},{"location":"LinAlg/LinAlg/","text":"Efficient Jacobian Linear Algebra Routines When computing derivatives and integrals on elements we need to repeatedly compute the determinant or inverse of the element's Jacobian. Since these Jacobians are small (max 3x3) FEMpy uses the manual implementations below for these inverse and determinant calculations. With the help of numba, these routines are approximately 1-2 orders of magnitude quicker than numpy's linalg.det and linalg.inv functions. det1 ( A ) Compute the determinants of a series of 1x1 matrices. Parameters: Name Type Description Default A nx1x1 array_like Arrays to compute detrminents of required Returns: Type Description array of length n Matrix determinants Source code in FEMpy/LinAlg.py def det1 ( A ): \"\"\"Compute the determinants of a series of 1x1 matrices. Parameters ---------- A : nx1x1 array_like Arrays to compute detrminents of Returns ------- dets : array of length n Matrix determinants \"\"\" return A . flatten () det2 ( A ) Compute the determinants of a series of 2x2 matrices. Parameters: Name Type Description Default A nx2x2 array_like Arrays to compute detrminents of required Returns: Type Description array of length n Matrix determinants Source code in FEMpy/LinAlg.py @njit ( cache = True , fastmath = True ) def det2 ( A ): \"\"\"Compute the determinants of a series of 2x2 matrices. Parameters ---------- A : nx2x2 array_like Arrays to compute detrminents of Returns ------- dets : array of length n Matrix determinants \"\"\" n = np . shape ( A )[ 0 ] dets = np . zeros ( n ) for i in range ( n ): dets [ i ] = A [ i , 0 , 0 ] * A [ i , 1 , 1 ] - A [ i , 0 , 1 ] * A [ i , 1 , 0 ] return dets det3 ( A ) Compute the determinants of a series of 3x3 matrices. Parameters: Name Type Description Default A nx3x3 array_like Arrays to compute detrminents of required Returns: Type Description array of length n Matrix determinants Source code in FEMpy/LinAlg.py @njit ( cache = True , fastmath = True ) def det3 ( A ): \"\"\"Compute the determinants of a series of 3x3 matrices. Parameters ---------- A : nx3x3 array_like Arrays to compute detrminents of Returns ------- dets : array of length n Matrix determinants \"\"\" n = np . shape ( A )[ 0 ] dets = np . zeros ( n ) for i in range ( n ): dets [ i ] = ( A [ i , 0 , 0 ] * ( A [ i , 1 , 1 ] * A [ i , 2 , 2 ] - A [ i , 1 , 2 ] * A [ i , 2 , 1 ]) - A [ i , 0 , 1 ] * ( A [ i , 1 , 0 ] * A [ i , 2 , 2 ] - A [ i , 1 , 2 ] * A [ i , 2 , 0 ]) + A [ i , 0 , 2 ] * ( A [ i , 1 , 0 ] * A [ i , 2 , 1 ] - A [ i , 1 , 1 ] * A [ i , 2 , 0 ]) ) return dets inv1 ( A ) Compute the inverses of a series of 1x1 matrices. Parameters: Name Type Description Default A nx1x1 array_like Arrays to compute detrminents of required Returns: Type Description nx1x1 array Matrix inverses Source code in FEMpy/LinAlg.py def inv1 ( A ): \"\"\"Compute the inverses of a series of 1x1 matrices. Parameters ---------- A : nx1x1 array_like Arrays to compute detrminents of Returns ------- dets : nx1x1 array Matrix inverses \"\"\" return 1.0 / A inv2 ( A ) Compute the inverses of a series of 2x2 matrices. Parameters: Name Type Description Default A nx2x2 array_like Arrays to compute detrminents of required Returns: Type Description nx2x2 array Matrix inverses Source code in FEMpy/LinAlg.py @njit ( cache = True , fastmath = True ) def inv2 ( A ): \"\"\"Compute the inverses of a series of 2x2 matrices. Parameters ---------- A : nx2x2 array_like Arrays to compute detrminents of Returns ------- dets : nx2x2 array Matrix inverses \"\"\" invdets = 1.0 / det2 ( A ) n = len ( invdets ) invs = np . zeros (( n , 2 , 2 )) for i in range ( n ): invs [ i , 0 , 0 ] = invdets [ i ] * A [ i , 1 , 1 ] invs [ i , 1 , 1 ] = invdets [ i ] * A [ i , 0 , 0 ] invs [ i , 0 , 1 ] = - invdets [ i ] * A [ i , 0 , 1 ] invs [ i , 1 , 0 ] = - invdets [ i ] * A [ i , 1 , 0 ] return invs inv3 ( A ) Compute the inverses of a series of 3x3 matrices. Parameters: Name Type Description Default A nx3x3 array_like Arrays to compute detrminents of required Returns: Type Description nx3x3 array Matrix inverses Source code in FEMpy/LinAlg.py @njit ( cache = True , fastmath = True ) def inv3 ( A ): \"\"\"Compute the inverses of a series of 3x3 matrices. Parameters ---------- A : nx3x3 array_like Arrays to compute detrminents of Returns ------- dets : nx3x3 array Matrix inverses \"\"\" invdets = 1.0 / det3 ( A ) n = len ( invdets ) invs = np . zeros (( n , 3 , 3 )) for i in range ( n ): invs [ i , 0 , 0 ] = invdets [ i ] * ( A [ i , 1 , 1 ] * A [ i , 2 , 2 ] - A [ i , 1 , 2 ] * A [ i , 2 , 1 ]) invs [ i , 0 , 1 ] = - invdets [ i ] * ( A [ i , 0 , 1 ] * A [ i , 2 , 2 ] - A [ i , 0 , 2 ] * A [ i , 2 , 1 ]) invs [ i , 0 , 2 ] = invdets [ i ] * ( A [ i , 0 , 1 ] * A [ i , 1 , 2 ] - A [ i , 0 , 2 ] * A [ i , 1 , 1 ]) invs [ i , 1 , 0 ] = - invdets [ i ] * ( A [ i , 1 , 0 ] * A [ i , 2 , 2 ] - A [ i , 1 , 2 ] * A [ i , 2 , 0 ]) invs [ i , 1 , 1 ] = invdets [ i ] * ( A [ i , 0 , 0 ] * A [ i , 2 , 2 ] - A [ i , 0 , 2 ] * A [ i , 2 , 0 ]) invs [ i , 1 , 2 ] = - invdets [ i ] * ( A [ i , 0 , 0 ] * A [ i , 1 , 2 ] - A [ i , 0 , 2 ] * A [ i , 1 , 0 ]) invs [ i , 2 , 0 ] = invdets [ i ] * ( A [ i , 1 , 0 ] * A [ i , 2 , 1 ] - A [ i , 1 , 1 ] * A [ i , 2 , 0 ]) invs [ i , 2 , 1 ] = - invdets [ i ] * ( A [ i , 0 , 0 ] * A [ i , 2 , 1 ] - A [ i , 0 , 1 ] * A [ i , 2 , 0 ]) invs [ i , 2 , 2 ] = invdets [ i ] * ( A [ i , 0 , 0 ] * A [ i , 1 , 1 ] - A [ i , 0 , 1 ] * A [ i , 1 , 0 ]) return invs","title":"Linear Algebra"},{"location":"LinAlg/LinAlg/#efficient-jacobian-linear-algebra-routines","text":"When computing derivatives and integrals on elements we need to repeatedly compute the determinant or inverse of the element's Jacobian. Since these Jacobians are small (max 3x3) FEMpy uses the manual implementations below for these inverse and determinant calculations. With the help of numba, these routines are approximately 1-2 orders of magnitude quicker than numpy's linalg.det and linalg.inv functions.","title":"Efficient Jacobian Linear Algebra Routines"},{"location":"LinAlg/LinAlg/#FEMpy.LinAlg.det1","text":"Compute the determinants of a series of 1x1 matrices. Parameters: Name Type Description Default A nx1x1 array_like Arrays to compute detrminents of required Returns: Type Description array of length n Matrix determinants Source code in FEMpy/LinAlg.py def det1 ( A ): \"\"\"Compute the determinants of a series of 1x1 matrices. Parameters ---------- A : nx1x1 array_like Arrays to compute detrminents of Returns ------- dets : array of length n Matrix determinants \"\"\" return A . flatten ()","title":"det1()"},{"location":"LinAlg/LinAlg/#FEMpy.LinAlg.det2","text":"Compute the determinants of a series of 2x2 matrices. Parameters: Name Type Description Default A nx2x2 array_like Arrays to compute detrminents of required Returns: Type Description array of length n Matrix determinants Source code in FEMpy/LinAlg.py @njit ( cache = True , fastmath = True ) def det2 ( A ): \"\"\"Compute the determinants of a series of 2x2 matrices. Parameters ---------- A : nx2x2 array_like Arrays to compute detrminents of Returns ------- dets : array of length n Matrix determinants \"\"\" n = np . shape ( A )[ 0 ] dets = np . zeros ( n ) for i in range ( n ): dets [ i ] = A [ i , 0 , 0 ] * A [ i , 1 , 1 ] - A [ i , 0 , 1 ] * A [ i , 1 , 0 ] return dets","title":"det2()"},{"location":"LinAlg/LinAlg/#FEMpy.LinAlg.det3","text":"Compute the determinants of a series of 3x3 matrices. Parameters: Name Type Description Default A nx3x3 array_like Arrays to compute detrminents of required Returns: Type Description array of length n Matrix determinants Source code in FEMpy/LinAlg.py @njit ( cache = True , fastmath = True ) def det3 ( A ): \"\"\"Compute the determinants of a series of 3x3 matrices. Parameters ---------- A : nx3x3 array_like Arrays to compute detrminents of Returns ------- dets : array of length n Matrix determinants \"\"\" n = np . shape ( A )[ 0 ] dets = np . zeros ( n ) for i in range ( n ): dets [ i ] = ( A [ i , 0 , 0 ] * ( A [ i , 1 , 1 ] * A [ i , 2 , 2 ] - A [ i , 1 , 2 ] * A [ i , 2 , 1 ]) - A [ i , 0 , 1 ] * ( A [ i , 1 , 0 ] * A [ i , 2 , 2 ] - A [ i , 1 , 2 ] * A [ i , 2 , 0 ]) + A [ i , 0 , 2 ] * ( A [ i , 1 , 0 ] * A [ i , 2 , 1 ] - A [ i , 1 , 1 ] * A [ i , 2 , 0 ]) ) return dets","title":"det3()"},{"location":"LinAlg/LinAlg/#FEMpy.LinAlg.inv1","text":"Compute the inverses of a series of 1x1 matrices. Parameters: Name Type Description Default A nx1x1 array_like Arrays to compute detrminents of required Returns: Type Description nx1x1 array Matrix inverses Source code in FEMpy/LinAlg.py def inv1 ( A ): \"\"\"Compute the inverses of a series of 1x1 matrices. Parameters ---------- A : nx1x1 array_like Arrays to compute detrminents of Returns ------- dets : nx1x1 array Matrix inverses \"\"\" return 1.0 / A","title":"inv1()"},{"location":"LinAlg/LinAlg/#FEMpy.LinAlg.inv2","text":"Compute the inverses of a series of 2x2 matrices. Parameters: Name Type Description Default A nx2x2 array_like Arrays to compute detrminents of required Returns: Type Description nx2x2 array Matrix inverses Source code in FEMpy/LinAlg.py @njit ( cache = True , fastmath = True ) def inv2 ( A ): \"\"\"Compute the inverses of a series of 2x2 matrices. Parameters ---------- A : nx2x2 array_like Arrays to compute detrminents of Returns ------- dets : nx2x2 array Matrix inverses \"\"\" invdets = 1.0 / det2 ( A ) n = len ( invdets ) invs = np . zeros (( n , 2 , 2 )) for i in range ( n ): invs [ i , 0 , 0 ] = invdets [ i ] * A [ i , 1 , 1 ] invs [ i , 1 , 1 ] = invdets [ i ] * A [ i , 0 , 0 ] invs [ i , 0 , 1 ] = - invdets [ i ] * A [ i , 0 , 1 ] invs [ i , 1 , 0 ] = - invdets [ i ] * A [ i , 1 , 0 ] return invs","title":"inv2()"},{"location":"LinAlg/LinAlg/#FEMpy.LinAlg.inv3","text":"Compute the inverses of a series of 3x3 matrices. Parameters: Name Type Description Default A nx3x3 array_like Arrays to compute detrminents of required Returns: Type Description nx3x3 array Matrix inverses Source code in FEMpy/LinAlg.py @njit ( cache = True , fastmath = True ) def inv3 ( A ): \"\"\"Compute the inverses of a series of 3x3 matrices. Parameters ---------- A : nx3x3 array_like Arrays to compute detrminents of Returns ------- dets : nx3x3 array Matrix inverses \"\"\" invdets = 1.0 / det3 ( A ) n = len ( invdets ) invs = np . zeros (( n , 3 , 3 )) for i in range ( n ): invs [ i , 0 , 0 ] = invdets [ i ] * ( A [ i , 1 , 1 ] * A [ i , 2 , 2 ] - A [ i , 1 , 2 ] * A [ i , 2 , 1 ]) invs [ i , 0 , 1 ] = - invdets [ i ] * ( A [ i , 0 , 1 ] * A [ i , 2 , 2 ] - A [ i , 0 , 2 ] * A [ i , 2 , 1 ]) invs [ i , 0 , 2 ] = invdets [ i ] * ( A [ i , 0 , 1 ] * A [ i , 1 , 2 ] - A [ i , 0 , 2 ] * A [ i , 1 , 1 ]) invs [ i , 1 , 0 ] = - invdets [ i ] * ( A [ i , 1 , 0 ] * A [ i , 2 , 2 ] - A [ i , 1 , 2 ] * A [ i , 2 , 0 ]) invs [ i , 1 , 1 ] = invdets [ i ] * ( A [ i , 0 , 0 ] * A [ i , 2 , 2 ] - A [ i , 0 , 2 ] * A [ i , 2 , 0 ]) invs [ i , 1 , 2 ] = - invdets [ i ] * ( A [ i , 0 , 0 ] * A [ i , 1 , 2 ] - A [ i , 0 , 2 ] * A [ i , 1 , 0 ]) invs [ i , 2 , 0 ] = invdets [ i ] * ( A [ i , 1 , 0 ] * A [ i , 2 , 1 ] - A [ i , 1 , 1 ] * A [ i , 2 , 0 ]) invs [ i , 2 , 1 ] = - invdets [ i ] * ( A [ i , 0 , 0 ] * A [ i , 2 , 1 ] - A [ i , 0 , 1 ] * A [ i , 2 , 0 ]) invs [ i , 2 , 2 ] = invdets [ i ] * ( A [ i , 0 , 0 ] * A [ i , 1 , 1 ] - A [ i , 0 , 1 ] * A [ i , 1 , 0 ]) return invs","title":"inv3()"}]}