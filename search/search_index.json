{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FEMpy","text":"<p>FEMpy is my attempt to implement a basic object-oriented finite element method in python that's as fast and flexible as possible.</p> <p></p> <p>FEMpy uses Numba JIT compilation extensively to perform fast, multithread operations over many elements at once. It uses scipy's sparse matrix implementation and can use the super-fast Paradiso solver from Intel's MKL to assemble and solve problems with 500,000 degrees of freedom in a few seconds.</p> <p></p>"},{"location":"#how-to-install","title":"How to install","text":"<p>Inside the FEMpy root directory run: <pre><code>pip install .\n</code></pre> Or, if you want to make changes to the code: <pre><code>pip install -e .\n</code></pre></p> <p>To run unit tests. <pre><code>testflo -n 1 -v .\n</code></pre></p>"},{"location":"ConstitutiveModels/ConstitutiveModel/","title":"Constitutive Model Base Class","text":"<p>The base class for all FEMpy constitutive models</p> <p>The constitutive model defines the underlying PDE being solved. Currently, this base class is defined for solid mechanics problems, but in future it may be extended for other PDE types.</p> <p>It contains information on:</p> <ul> <li>The number of spatial dimensions the model is valid for</li> <li>The number and names of the PDE states</li> <li>The number and names of the stresses and strains for this model</li> <li>The number and names of the design variables associated with the PDE</li> <li>The names of functions which can be computed for this constitutive model (e.g mass, Von Mises stress etc)</li> </ul> <p>And contains methods to:</p> <ul> <li>Given the coordinates, state value, state gradient, and design variables at a point, compute:<ul> <li>The strain components</li> <li>The sensitivities of the strain components</li> <li>The stress components</li> <li>The sensitivities of the stress components</li> <li>The pointwise mass</li> <li>The volume integral scaling parameter (e.g thickness for 2D plane models or \\(2 \\pi r\\) for 2D axisymmetric problems)</li> <li>The weak form residual</li> <li>The weak form residual Jacobian</li> <li>Other arbitrary output values (e.g failure criterion)</li> </ul> </li> </ul> Source code in <code>FEMpy/Constitutive/ConstitutiveModel.py</code> <pre><code>class ConstitutiveModel:\n    \"\"\"The base class for all FEMpy constitutive models\n\n    The constitutive model defines the underlying PDE being solved. Currently, this base class is defined for\n    solid mechanics problems, but in future it may be extended for other PDE types.\n\n    It contains information on:\n\n    - The number of spatial dimensions the model is valid for\n    - The number and names of the PDE states\n    - The number and names of the stresses and strains for this model\n    - The number and names of the design variables associated with the PDE\n    - The names of functions which can be computed for this constitutive model (e.g mass, Von Mises stress etc)\n\n    And contains methods to:\n\n    - Given the coordinates, state value, state gradient, and design variables at a point, compute:\n        - The strain components\n        - The sensitivities of the strain components\n        - The stress components\n        - The sensitivities of the stress components\n        - The pointwise mass\n        - The volume integral scaling parameter (e.g thickness for 2D plane models or $2 \\pi r$ for 2D axisymmetric problems)\n        - The weak form residual\n        - The weak form residual Jacobian\n        - Other arbitrary output values (e.g failure criterion)\n    \"\"\"\n\n    def __init__(self, numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear=True) -&gt; None:\n        \"\"\"_summary_\n\n\n\n        Parameters\n        ----------\n        numDim : int\n            Number of spatial dimensions the model is valid for\n        stateNames : list of str\n            Names for each state variable\n        strainNames : list of str\n            Names for each strain component\n        stressNames : list of str\n            Names for each stress component\n        designVars : dict\n            A nested dictionary of design variables, with the key being the name of the design variable and the value\n            being a dictionary that contains various pieces of information about that DV, including:\n                - \"defaultValue\" : The default value of that DV\n        functionNames : list of str\n            The names of functions that can be computed with this constitutive model\n        linear : bool, optional\n            Whether the constitutive model is linear or not, a.k.a whether the weak residual is a linear function of the states/state gradients, by default True\n        \"\"\"\n        self.numDim = numDim\n\n        self.stateNames = stateNames\n        self.numStates = len(stateNames)\n\n        self.strainNames = strainNames\n        self.numStrains = len(strainNames)\n        if len(stressNames) != self.numStrains:\n            raise ValueError(\"Number of strains must equal number of stresses\")\n        self.stressNames = stressNames\n\n        self.designVariables = designVars\n        self.numDesignVariables = len(designVars)\n\n        self.functionNames = functionNames\n\n        self.lowerCaseFuncNames = [func.lower() for func in self.functionNames]\n\n        self.isLinear = linear\n\n    # ==============================================================================\n    # Abstract methods: To be implemented by derived classes\n    # ==============================================================================\n    @abc.abstractmethod\n    def computeStrains(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one\n\n\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dictionary of len(numpoints) array\n            design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStrains array\n            Strain components at each point\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def computeStrainStateGradSens(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n        sensitivity of the strains to the state gradient at each one\n\n\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dictionary of len(numpoints) array\n            design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStrains x numStates x numDim array\n            Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def computeStresses(self, strains, dvs):\n        \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one\n\n\n\n        Parameters\n        ----------\n        strains : numPoints x numStrains array\n            Strain components at each point\n        dvs : dictionary of len(numpoints) array\n            design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStresses array\n            Stress components at each point\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def computeStressStrainSens(self, strains, dvs):\n        \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one\n\n\n\n        Parameters\n        ----------\n        strains : numPoints x numStrains array\n            Strain components at each point\n        dvs : dictionary of len(numpoints) array\n            design variable values at each point\n\n        Returns\n        -------\n        sens : numPoints x numStrains x numStates x numDim array\n            Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def computeVolumeScaling(self, coords, dvs):\n        \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one\n\n        The volume scaling parameter is used to scale functions that are integrated over the element to get a true\n        volume integral. For example, in a 2D plane stress model, we need to multiply by the thickness of the element\n        to get a true volume integral. In a 2D axisymmetric model, we need to multiply by 2*pi*r to get a true volume\n        integral.\n\n        Parameters\n        ----------\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dictionary of len(numpoints) array\n            design variable values at each point\n\n        Returns\n        -------\n        numPoints length array\n            Volume scaling parameter at each point\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def getFunction(self, name):\n        \"\"\"Return a function that can be computed for this constitutive model\n\n        Parameters\n        ----------\n        name : str\n            Name of the function to compute\n\n        Returns\n        -------\n        callable\n            A function that can be called to compute the desired function at a bunch of points with the signature,\n            `f(states, stateGradients, coords, dvs)`, where:\n\n            - states is a numPoints x numStates array\n            - stateGradients is a numPoints x numStates x numDim array\n            - coords is a numPoints x numDim array\n            - dvs is a dictionary of numPoints length arrays\n        \"\"\"\n\n        raise NotImplementedError\n\n    # ==============================================================================\n    # Public methods\n    # ==============================================================================\n    def computeWeakResiduals(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual integrand\n\n        For a solid mechanics problem, the weak residual, derived from the virtual work principle is:\n\n        $R = \\int r dV = \\int (du'/dq)^T  (d\\epsilon/du')^T  \\sigma  \\\\theta d\\Omega$\n\n        Where:\n\n        - $du'/dq$ is the sensitivity of the state gradient to the nodal state values, this is handled by the element\n        - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient\n        - $\\sigma$ are the stresses\n        - $\\\\theta$ is the volume scaling parameter\n        - $\\Omega$ is the element\n\n        This function computes $(de/du')^T * \\sigma * \\\\theta$ at each point\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dictionary of len(numpoints) array\n            design variable values at each point\n\n        Returns\n        -------\n        residuals : numPoints x self.numDim x self.numStates array\n            Weak residual integrand at each point\n        \"\"\"\n        numPoints = coords.shape[0]\n        strain = self.computeStrains(states, stateGradients, coords, dvs)\n        stress = self.computeStresses(strain, dvs)\n        scale = self.computeVolumeScaling(coords, dvs)\n\n        strainSens = self.computeStrainStateGradSens(states, stateGradients, coords, dvs)\n\n        residuals = np.zeros((numPoints, self.numDim, self.numStates))\n        _computeWeakResidualProduct(strainSens, stress, scale, residuals)\n        return residuals\n\n        # return np.einsum(\"pesd,pe,p-&gt;pds\", strainSens, stress, scale, optimize=[\"einsum_path\", (0, 1), (0, 1)])\n\n    def computeWeakResidualJacobian(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n        weak residual jacobian integrand\n\n        $j = (d\\epsilon/du')^T \\\\times d\\sigma/d\\epsilon \\\\times d\\epsilon/du'$\n\n        Where:\n\n        - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient\n        - $d\\sigma/d\\epsilon$ the sensitivity of the stress to the strain gradient\n\n        This function computes `de/du'^T * sigma * scale` at each point\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dictionary of len(numpoints) array\n            design variable values at each point\n\n        Returns\n        -------\n        Jacobians : numPoints x numDim x numStates x numStates x numDim array\n            The sensibility of the weak residual integrand components to the state gradients at each point\n        \"\"\"\n        strainSens = self.computeStrainStateGradSens(states, stateGradients, coords, dvs)\n        strain = self.computeStrains(states, stateGradients, coords, dvs)\n        stressSens = self.computeStressStrainSens(strain, dvs)\n        scale = self.computeVolumeScaling(coords, dvs)\n        numPoints = states.shape[0]\n        # strainSens = strainSens.reshape(numPoints, self.numStrains, self.numStates * self.numDim)\n        # Jacobian = _computeWeakJacobianProduct(strainSens, stressSens, scale)\n        # points = p\n        # strains = e\n        # stress = o\n        # states = s\n        # dim = d\n        # Jacobians = np.einsum(\n        #     \"posd,poe,peSD,p-&gt;pdsSD\",\n        #     strainSens,\n        #     stressSens,\n        #     strainSens,\n        #     scale,\n        #     optimize=[\"einsum_path\", (1, 3), (0, 2), (0, 1)],\n        # )\n        Jacobians = np.zeros((numPoints, self.numDim, self.numStates, self.numStates, self.numDim))\n        _computeWeakJacobianProduct(strainSens, stressSens, scale, Jacobians)\n\n        return Jacobians\n</code></pre>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.__init__","title":"<code>__init__(numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear=True)</code>","text":"<p>summary</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.__init__--parameters","title":"Parameters","text":"<p>numDim : int     Number of spatial dimensions the model is valid for stateNames : list of str     Names for each state variable strainNames : list of str     Names for each strain component stressNames : list of str     Names for each stress component designVars : dict     A nested dictionary of design variables, with the key being the name of the design variable and the value     being a dictionary that contains various pieces of information about that DV, including:         - \"defaultValue\" : The default value of that DV functionNames : list of str     The names of functions that can be computed with this constitutive model linear : bool, optional     Whether the constitutive model is linear or not, a.k.a whether the weak residual is a linear function of the states/state gradients, by default True</p> Source code in <code>FEMpy/Constitutive/ConstitutiveModel.py</code> <pre><code>def __init__(self, numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear=True) -&gt; None:\n    \"\"\"_summary_\n\n\n\n    Parameters\n    ----------\n    numDim : int\n        Number of spatial dimensions the model is valid for\n    stateNames : list of str\n        Names for each state variable\n    strainNames : list of str\n        Names for each strain component\n    stressNames : list of str\n        Names for each stress component\n    designVars : dict\n        A nested dictionary of design variables, with the key being the name of the design variable and the value\n        being a dictionary that contains various pieces of information about that DV, including:\n            - \"defaultValue\" : The default value of that DV\n    functionNames : list of str\n        The names of functions that can be computed with this constitutive model\n    linear : bool, optional\n        Whether the constitutive model is linear or not, a.k.a whether the weak residual is a linear function of the states/state gradients, by default True\n    \"\"\"\n    self.numDim = numDim\n\n    self.stateNames = stateNames\n    self.numStates = len(stateNames)\n\n    self.strainNames = strainNames\n    self.numStrains = len(strainNames)\n    if len(stressNames) != self.numStrains:\n        raise ValueError(\"Number of strains must equal number of stresses\")\n    self.stressNames = stressNames\n\n    self.designVariables = designVars\n    self.numDesignVariables = len(designVars)\n\n    self.functionNames = functionNames\n\n    self.lowerCaseFuncNames = [func.lower() for func in self.functionNames]\n\n    self.isLinear = linear\n</code></pre>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStrainStateGradSens","title":"<code>computeStrainStateGradSens(states, stateGradients, coords, dvs)</code>  <code>abstractmethod</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStrainStateGradSens--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dictionary of len(numpoints) array     design variable values at each point</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStrainStateGradSens--returns","title":"Returns","text":"<p>numPoints x numStrains x numStates x numDim array     Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l</p> Source code in <code>FEMpy/Constitutive/ConstitutiveModel.py</code> <pre><code>@abc.abstractmethod\ndef computeStrainStateGradSens(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n    sensitivity of the strains to the state gradient at each one\n\n\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dictionary of len(numpoints) array\n        design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStrains x numStates x numDim array\n        Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStrains","title":"<code>computeStrains(states, stateGradients, coords, dvs)</code>  <code>abstractmethod</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStrains--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dictionary of len(numpoints) array     design variable values at each point</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStrains--returns","title":"Returns","text":"<p>numPoints x numStrains array     Strain components at each point</p> Source code in <code>FEMpy/Constitutive/ConstitutiveModel.py</code> <pre><code>@abc.abstractmethod\ndef computeStrains(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one\n\n\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dictionary of len(numpoints) array\n        design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStrains array\n        Strain components at each point\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStressStrainSens","title":"<code>computeStressStrainSens(strains, dvs)</code>  <code>abstractmethod</code>","text":"<p>Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStressStrainSens--parameters","title":"Parameters","text":"<p>strains : numPoints x numStrains array     Strain components at each point dvs : dictionary of len(numpoints) array     design variable values at each point</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStressStrainSens--returns","title":"Returns","text":"<p>sens : numPoints x numStrains x numStates x numDim array     Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l</p> Source code in <code>FEMpy/Constitutive/ConstitutiveModel.py</code> <pre><code>@abc.abstractmethod\ndef computeStressStrainSens(self, strains, dvs):\n    \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one\n\n\n\n    Parameters\n    ----------\n    strains : numPoints x numStrains array\n        Strain components at each point\n    dvs : dictionary of len(numpoints) array\n        design variable values at each point\n\n    Returns\n    -------\n    sens : numPoints x numStrains x numStates x numDim array\n        Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStresses","title":"<code>computeStresses(strains, dvs)</code>  <code>abstractmethod</code>","text":"<p>Given the strains and design variables at a bunch of points, compute the stresses at each one</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStresses--parameters","title":"Parameters","text":"<p>strains : numPoints x numStrains array     Strain components at each point dvs : dictionary of len(numpoints) array     design variable values at each point</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStresses--returns","title":"Returns","text":"<p>numPoints x numStresses array     Stress components at each point</p> Source code in <code>FEMpy/Constitutive/ConstitutiveModel.py</code> <pre><code>@abc.abstractmethod\ndef computeStresses(self, strains, dvs):\n    \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one\n\n\n\n    Parameters\n    ----------\n    strains : numPoints x numStrains array\n        Strain components at each point\n    dvs : dictionary of len(numpoints) array\n        design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStresses array\n        Stress components at each point\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeVolumeScaling","title":"<code>computeVolumeScaling(coords, dvs)</code>  <code>abstractmethod</code>","text":"<p>Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one</p> <p>The volume scaling parameter is used to scale functions that are integrated over the element to get a true volume integral. For example, in a 2D plane stress model, we need to multiply by the thickness of the element to get a true volume integral. In a 2D axisymmetric model, we need to multiply by 2pir to get a true volume integral.</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeVolumeScaling--parameters","title":"Parameters","text":"<p>coords : numPoints x numDim array     Coordinates of each point dvs : dictionary of len(numpoints) array     design variable values at each point</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeVolumeScaling--returns","title":"Returns","text":"<p>numPoints length array     Volume scaling parameter at each point</p> Source code in <code>FEMpy/Constitutive/ConstitutiveModel.py</code> <pre><code>@abc.abstractmethod\ndef computeVolumeScaling(self, coords, dvs):\n    \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one\n\n    The volume scaling parameter is used to scale functions that are integrated over the element to get a true\n    volume integral. For example, in a 2D plane stress model, we need to multiply by the thickness of the element\n    to get a true volume integral. In a 2D axisymmetric model, we need to multiply by 2*pi*r to get a true volume\n    integral.\n\n    Parameters\n    ----------\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dictionary of len(numpoints) array\n        design variable values at each point\n\n    Returns\n    -------\n    numPoints length array\n        Volume scaling parameter at each point\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeWeakResidualJacobian","title":"<code>computeWeakResidualJacobian(states, stateGradients, coords, dvs)</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual jacobian integrand</p> <p>\\(j = (d\\epsilon/du')^T \\times d\\sigma/d\\epsilon \\times d\\epsilon/du'\\)</p> <p>Where:</p> <ul> <li>\\(d\\epsilon/du'\\) is the sensitivity of the strain to the state gradient</li> <li>\\(d\\sigma/d\\epsilon\\) the sensitivity of the stress to the strain gradient</li> </ul> <p>This function computes <code>de/du'^T * sigma * scale</code> at each point</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeWeakResidualJacobian--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dictionary of len(numpoints) array     design variable values at each point</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeWeakResidualJacobian--returns","title":"Returns","text":"<p>Jacobians : numPoints x numDim x numStates x numStates x numDim array     The sensibility of the weak residual integrand components to the state gradients at each point</p> Source code in <code>FEMpy/Constitutive/ConstitutiveModel.py</code> <pre><code>def computeWeakResidualJacobian(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n    weak residual jacobian integrand\n\n    $j = (d\\epsilon/du')^T \\\\times d\\sigma/d\\epsilon \\\\times d\\epsilon/du'$\n\n    Where:\n\n    - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient\n    - $d\\sigma/d\\epsilon$ the sensitivity of the stress to the strain gradient\n\n    This function computes `de/du'^T * sigma * scale` at each point\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dictionary of len(numpoints) array\n        design variable values at each point\n\n    Returns\n    -------\n    Jacobians : numPoints x numDim x numStates x numStates x numDim array\n        The sensibility of the weak residual integrand components to the state gradients at each point\n    \"\"\"\n    strainSens = self.computeStrainStateGradSens(states, stateGradients, coords, dvs)\n    strain = self.computeStrains(states, stateGradients, coords, dvs)\n    stressSens = self.computeStressStrainSens(strain, dvs)\n    scale = self.computeVolumeScaling(coords, dvs)\n    numPoints = states.shape[0]\n    # strainSens = strainSens.reshape(numPoints, self.numStrains, self.numStates * self.numDim)\n    # Jacobian = _computeWeakJacobianProduct(strainSens, stressSens, scale)\n    # points = p\n    # strains = e\n    # stress = o\n    # states = s\n    # dim = d\n    # Jacobians = np.einsum(\n    #     \"posd,poe,peSD,p-&gt;pdsSD\",\n    #     strainSens,\n    #     stressSens,\n    #     strainSens,\n    #     scale,\n    #     optimize=[\"einsum_path\", (1, 3), (0, 2), (0, 1)],\n    # )\n    Jacobians = np.zeros((numPoints, self.numDim, self.numStates, self.numStates, self.numDim))\n    _computeWeakJacobianProduct(strainSens, stressSens, scale, Jacobians)\n\n    return Jacobians\n</code></pre>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeWeakResiduals","title":"<code>computeWeakResiduals(states, stateGradients, coords, dvs)</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual integrand</p> <p>For a solid mechanics problem, the weak residual, derived from the virtual work principle is:</p> <p>\\(R = \\int r dV = \\int (du'/dq)^T  (d\\epsilon/du')^T  \\sigma  \\theta d\\Omega\\)</p> <p>Where:</p> <ul> <li>\\(du'/dq\\) is the sensitivity of the state gradient to the nodal state values, this is handled by the element</li> <li>\\(d\\epsilon/du'\\) is the sensitivity of the strain to the state gradient</li> <li>\\(\\sigma\\) are the stresses</li> <li>\\(\\theta\\) is the volume scaling parameter</li> <li>\\(\\Omega\\) is the element</li> </ul> <p>This function computes \\((de/du')^T * \\sigma * \\theta\\) at each point</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeWeakResiduals--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dictionary of len(numpoints) array     design variable values at each point</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeWeakResiduals--returns","title":"Returns","text":"<p>residuals : numPoints x self.numDim x self.numStates array     Weak residual integrand at each point</p> Source code in <code>FEMpy/Constitutive/ConstitutiveModel.py</code> <pre><code>def computeWeakResiduals(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual integrand\n\n    For a solid mechanics problem, the weak residual, derived from the virtual work principle is:\n\n    $R = \\int r dV = \\int (du'/dq)^T  (d\\epsilon/du')^T  \\sigma  \\\\theta d\\Omega$\n\n    Where:\n\n    - $du'/dq$ is the sensitivity of the state gradient to the nodal state values, this is handled by the element\n    - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient\n    - $\\sigma$ are the stresses\n    - $\\\\theta$ is the volume scaling parameter\n    - $\\Omega$ is the element\n\n    This function computes $(de/du')^T * \\sigma * \\\\theta$ at each point\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dictionary of len(numpoints) array\n        design variable values at each point\n\n    Returns\n    -------\n    residuals : numPoints x self.numDim x self.numStates array\n        Weak residual integrand at each point\n    \"\"\"\n    numPoints = coords.shape[0]\n    strain = self.computeStrains(states, stateGradients, coords, dvs)\n    stress = self.computeStresses(strain, dvs)\n    scale = self.computeVolumeScaling(coords, dvs)\n\n    strainSens = self.computeStrainStateGradSens(states, stateGradients, coords, dvs)\n\n    residuals = np.zeros((numPoints, self.numDim, self.numStates))\n    _computeWeakResidualProduct(strainSens, stress, scale, residuals)\n    return residuals\n</code></pre>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.getFunction","title":"<code>getFunction(name)</code>  <code>abstractmethod</code>","text":"<p>Return a function that can be computed for this constitutive model</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.getFunction--parameters","title":"Parameters","text":"<p>name : str     Name of the function to compute</p>"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.getFunction--returns","title":"Returns","text":"<p>callable     A function that can be called to compute the desired function at a bunch of points with the signature,     <code>f(states, stateGradients, coords, dvs)</code>, where:</p> <pre><code>- states is a numPoints x numStates array\n- stateGradients is a numPoints x numStates x numDim array\n- coords is a numPoints x numDim array\n- dvs is a dictionary of numPoints length arrays\n</code></pre> Source code in <code>FEMpy/Constitutive/ConstitutiveModel.py</code> <pre><code>@abc.abstractmethod\ndef getFunction(self, name):\n    \"\"\"Return a function that can be computed for this constitutive model\n\n    Parameters\n    ----------\n    name : str\n        Name of the function to compute\n\n    Returns\n    -------\n    callable\n        A function that can be called to compute the desired function at a bunch of points with the signature,\n        `f(states, stateGradients, coords, dvs)`, where:\n\n        - states is a numPoints x numStates array\n        - stateGradients is a numPoints x numStates x numDim array\n        - coords is a numPoints x numDim array\n        - dvs is a dictionary of numPoints length arrays\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"ConstitutiveModels/Iso1D/","title":"Isotropic 1 Dimensional Elasticity","text":"<p>               Bases: <code>ConstitutiveModel</code></p> <p>Constitutive model for an axial bar</p> <p>extended_summary</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D--inherits","title":"Inherits","text":"<p>ConstitutiveModel : FEMpy.Constitutive.ConstitutiveModel     The base class for FEMpy constitutive models</p> Source code in <code>FEMpy/Constitutive/Iso1D.py</code> <pre><code>class Iso1D(ConstitutiveModel):\n    \"\"\"Constitutive model for an axial bar\n\n    _extended_summary_\n\n    Inherits\n    ----------\n    ConstitutiveModel : FEMpy.Constitutive.ConstitutiveModel\n        The base class for FEMpy constitutive models\n    \"\"\"\n\n    def __init__(self, E, rho, A, linear=True):\n        \"\"\"Create an axial bar constitutive model\n\n        Parameters\n        ----------\n        E : float\n            Elastic Modulus\n        rho : float\n            Density\n        A : float\n            Cross-sectional area\n        linear : bool, optional\n            Whether to use the linear kinematic equations for strains, by default True\n        \"\"\"\n        # --- Design variables ---\n        designVars = {}\n        designVars[\"Area\"] = {\"defaultValue\": A}\n\n        # --- States ---\n        stateNames = [\"X-Displacement\"]\n\n        # --- Strains ---\n        strainNames = [\"e_xx\"]\n\n        # --- Stresses ---\n        stressNames = [\"sigma_xx\"]\n\n        # --- Functions ---\n        functionNames = [\"Mass\", \"Stress\", \"Strain\"]\n\n        # --- Material properties ---\n        self.E = E\n        self.rho = rho\n\n        numDim = 1\n\n        super().__init__(numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear)\n\n    def computeStrains(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one\n\n\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStrains array\n            Strain components at each point\n        \"\"\"\n        return strain1D(UPrime=stateGradients, nonlinear=not self.isLinear)\n\n    def computeStrainStateGradSens(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n        sensitivity of the strains to the state gradient at each one\n\n\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStrains x numStates x numDim array\n            Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n        \"\"\"\n        return strain1DSens(UPrime=stateGradients, nonlinear=not self.isLinear)\n\n    def computeStresses(self, strains, dvs):\n        \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one\n\n\n\n        Parameters\n        ----------\n        strains : numPoints x numStrains array\n            Strain components at each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStresses array\n            Stress components at each point\n        \"\"\"\n        return iso1DStress(strains, E=self.E)\n\n    def computeStressStrainSens(self, strains, dvs):\n        \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one\n\n        Parameters\n        ----------\n        strains : numPoints x numStrains array\n            Strain components at each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        sens : numPoints x numStrains x numStates x numDim array\n            Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n        \"\"\"\n        return iso1DStressStrainSens(strains, E=self.E)\n\n    def computeVolumeScaling(self, coords, dvs):\n        \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one\n\n        For this 2D model, the volume scaling is just the thickness\n\n        Parameters\n        ----------\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints length array\n            Volume scaling parameter at each point\n        \"\"\"\n        return dvs[\"Area\"]\n\n    def getFunction(self, name):\n        \"\"\"Return a function that can be computed for this constitutive model\n\n        Parameters\n        ----------\n        name : str\n            Name of the function to compute\n\n        Returns\n        -------\n        callable\n            A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)\n            where:\n            states is a numPoints x numStates array\n            stateGradients is a numPoints x numStates x numDim array\n            coords is a numPoints x numDim array\n            dvs is a dictionary of numPoints length arrays\n        \"\"\"\n\n        if name.lower() not in self.lowerCaseFuncNames:\n            raise ValueError(\n                f\"{name} is not a valid function name for this constitutive model, valid choices are {self.functionNames}\"\n            )\n\n        if name.lower() == \"mass\":\n\n            def massFunc(states, stateGradients, coords, dvs):\n                return np.ones(states.shape[0]) * self.rho\n\n            func = massFunc\n\n        if name.lower() == \"strain\":\n\n            def strainFunc(states, stateGradients, coords, dvs):\n                return self.computeStrains(states, stateGradients, coords, dvs).flatten()\n\n            func = strainFunc\n\n        if name.lower() == \"stress\":\n\n            def stressFunc(states, stateGradients, coords, dvs):\n                strains = self.computeStrains(states, stateGradients, coords, dvs)\n                return iso1DStress(strains, E=self.E).flatten()\n\n            func = stressFunc\n\n        return func\n</code></pre>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.__init__","title":"<code>__init__(E, rho, A, linear=True)</code>","text":"<p>Create an axial bar constitutive model</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.__init__--parameters","title":"Parameters","text":"<p>E : float     Elastic Modulus rho : float     Density A : float     Cross-sectional area linear : bool, optional     Whether to use the linear kinematic equations for strains, by default True</p> Source code in <code>FEMpy/Constitutive/Iso1D.py</code> <pre><code>def __init__(self, E, rho, A, linear=True):\n    \"\"\"Create an axial bar constitutive model\n\n    Parameters\n    ----------\n    E : float\n        Elastic Modulus\n    rho : float\n        Density\n    A : float\n        Cross-sectional area\n    linear : bool, optional\n        Whether to use the linear kinematic equations for strains, by default True\n    \"\"\"\n    # --- Design variables ---\n    designVars = {}\n    designVars[\"Area\"] = {\"defaultValue\": A}\n\n    # --- States ---\n    stateNames = [\"X-Displacement\"]\n\n    # --- Strains ---\n    strainNames = [\"e_xx\"]\n\n    # --- Stresses ---\n    stressNames = [\"sigma_xx\"]\n\n    # --- Functions ---\n    functionNames = [\"Mass\", \"Stress\", \"Strain\"]\n\n    # --- Material properties ---\n    self.E = E\n    self.rho = rho\n\n    numDim = 1\n\n    super().__init__(numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear)\n</code></pre>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStrainStateGradSens","title":"<code>computeStrainStateGradSens(states, stateGradients, coords, dvs)</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStrainStateGradSens--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStrainStateGradSens--returns","title":"Returns","text":"<p>numPoints x numStrains x numStates x numDim array     Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l</p> Source code in <code>FEMpy/Constitutive/Iso1D.py</code> <pre><code>def computeStrainStateGradSens(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n    sensitivity of the strains to the state gradient at each one\n\n\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStrains x numStates x numDim array\n        Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n    \"\"\"\n    return strain1DSens(UPrime=stateGradients, nonlinear=not self.isLinear)\n</code></pre>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStrains","title":"<code>computeStrains(states, stateGradients, coords, dvs)</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStrains--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStrains--returns","title":"Returns","text":"<p>numPoints x numStrains array     Strain components at each point</p> Source code in <code>FEMpy/Constitutive/Iso1D.py</code> <pre><code>def computeStrains(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one\n\n\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStrains array\n        Strain components at each point\n    \"\"\"\n    return strain1D(UPrime=stateGradients, nonlinear=not self.isLinear)\n</code></pre>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStressStrainSens","title":"<code>computeStressStrainSens(strains, dvs)</code>","text":"<p>Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStressStrainSens--parameters","title":"Parameters","text":"<p>strains : numPoints x numStrains array     Strain components at each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStressStrainSens--returns","title":"Returns","text":"<p>sens : numPoints x numStrains x numStates x numDim array     Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l</p> Source code in <code>FEMpy/Constitutive/Iso1D.py</code> <pre><code>def computeStressStrainSens(self, strains, dvs):\n    \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one\n\n    Parameters\n    ----------\n    strains : numPoints x numStrains array\n        Strain components at each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    sens : numPoints x numStrains x numStates x numDim array\n        Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n    \"\"\"\n    return iso1DStressStrainSens(strains, E=self.E)\n</code></pre>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStresses","title":"<code>computeStresses(strains, dvs)</code>","text":"<p>Given the strains and design variables at a bunch of points, compute the stresses at each one</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStresses--parameters","title":"Parameters","text":"<p>strains : numPoints x numStrains array     Strain components at each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeStresses--returns","title":"Returns","text":"<p>numPoints x numStresses array     Stress components at each point</p> Source code in <code>FEMpy/Constitutive/Iso1D.py</code> <pre><code>def computeStresses(self, strains, dvs):\n    \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one\n\n\n\n    Parameters\n    ----------\n    strains : numPoints x numStrains array\n        Strain components at each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStresses array\n        Stress components at each point\n    \"\"\"\n    return iso1DStress(strains, E=self.E)\n</code></pre>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeVolumeScaling","title":"<code>computeVolumeScaling(coords, dvs)</code>","text":"<p>Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one</p> <p>For this 2D model, the volume scaling is just the thickness</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeVolumeScaling--parameters","title":"Parameters","text":"<p>coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.computeVolumeScaling--returns","title":"Returns","text":"<p>numPoints length array     Volume scaling parameter at each point</p> Source code in <code>FEMpy/Constitutive/Iso1D.py</code> <pre><code>def computeVolumeScaling(self, coords, dvs):\n    \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one\n\n    For this 2D model, the volume scaling is just the thickness\n\n    Parameters\n    ----------\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints length array\n        Volume scaling parameter at each point\n    \"\"\"\n    return dvs[\"Area\"]\n</code></pre>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.getFunction","title":"<code>getFunction(name)</code>","text":"<p>Return a function that can be computed for this constitutive model</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.getFunction--parameters","title":"Parameters","text":"<p>name : str     Name of the function to compute</p>"},{"location":"ConstitutiveModels/Iso1D/#FEMpy.Constitutive.Iso1D.Iso1D.getFunction--returns","title":"Returns","text":"<p>callable     A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)     where:     states is a numPoints x numStates array     stateGradients is a numPoints x numStates x numDim array     coords is a numPoints x numDim array     dvs is a dictionary of numPoints length arrays</p> Source code in <code>FEMpy/Constitutive/Iso1D.py</code> <pre><code>def getFunction(self, name):\n    \"\"\"Return a function that can be computed for this constitutive model\n\n    Parameters\n    ----------\n    name : str\n        Name of the function to compute\n\n    Returns\n    -------\n    callable\n        A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)\n        where:\n        states is a numPoints x numStates array\n        stateGradients is a numPoints x numStates x numDim array\n        coords is a numPoints x numDim array\n        dvs is a dictionary of numPoints length arrays\n    \"\"\"\n\n    if name.lower() not in self.lowerCaseFuncNames:\n        raise ValueError(\n            f\"{name} is not a valid function name for this constitutive model, valid choices are {self.functionNames}\"\n        )\n\n    if name.lower() == \"mass\":\n\n        def massFunc(states, stateGradients, coords, dvs):\n            return np.ones(states.shape[0]) * self.rho\n\n        func = massFunc\n\n    if name.lower() == \"strain\":\n\n        def strainFunc(states, stateGradients, coords, dvs):\n            return self.computeStrains(states, stateGradients, coords, dvs).flatten()\n\n        func = strainFunc\n\n    if name.lower() == \"stress\":\n\n        def stressFunc(states, stateGradients, coords, dvs):\n            strains = self.computeStrains(states, stateGradients, coords, dvs)\n            return iso1DStress(strains, E=self.E).flatten()\n\n        func = stressFunc\n\n    return func\n</code></pre>"},{"location":"ConstitutiveModels/Iso3D/","title":"Isotropic 3 Dimensional Elasticity","text":"<p>               Bases: <code>ConstitutiveModel</code></p> <p>A constitutive model for a 3D isotropic material</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D--inherits","title":"Inherits","text":"<p>ConstitutiveModel : FEMpy.Constitutive.ConstitutiveModel     The base class for FEMpy constitutive models</p> Source code in <code>FEMpy/Constitutive/Iso3D.py</code> <pre><code>class Iso3D(ConstitutiveModel):\n    \"\"\"A constitutive model for a 3D isotropic material\n\n    Inherits\n    ----------\n    ConstitutiveModel : FEMpy.Constitutive.ConstitutiveModel\n        The base class for FEMpy constitutive models\n    \"\"\"\n\n    def __init__(self, E, nu, rho, linear=True):\n        \"\"\"Create an isotropic plane stress constitutive model\n\n        Parameters\n        ----------\n        E : float\n            Elastic Modulus\n        nu : float\n            Poisson's ratio\n        rho : float\n            Density\n        linear : bool, optional\n            Whether to use the linear kinematic equations for strains, by default True\n        \"\"\"\n        # --- Design variables ---\n        # This model has no design variables\n        designVars = {}\n\n        # --- States ---\n        stateNames = [\"X-Displacement\", \"Y-Displacement\", \"Z-Displacement\"]\n\n        # --- Strains ---\n        strainNames = [\"e_xx\", \"e_yy\", \"e_zz\", \"gamma_xy\", \"gamma_xz\", \"gamma_yz\"]\n\n        # --- Stresses ---\n        stressNames = [\"sigma_xx\", \"sigma_yy\", \"sigma_zz\", \"tau_xy\", \"tau_xz\", \"tau_yz\"]\n\n        # --- Functions ---\n        functionNames = [\"Mass\", \"Von-Mises-Stress\"]\n\n        # --- Material properties ---\n        self.E = E\n        self.nu = nu\n        self.rho = rho\n\n        numDim = 3\n\n        super().__init__(numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear)\n\n    def computeStrains(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStrains array\n            Strain components at each point\n        \"\"\"\n        return strain3D(UPrime=stateGradients, nonlinear=not self.isLinear)\n\n    def computeStrainStateGradSens(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n        sensitivity of the strains to the state gradient at each one\n\n\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStrains x numStates x numDim array\n            Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n        \"\"\"\n        return strain3DSens(UPrime=stateGradients, nonlinear=not self.isLinear)\n\n    def computeStresses(self, strains, dvs):\n        \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one\n\n\n\n        Parameters\n        ----------\n        strains : numPoints x numStrains array\n            Strain components at each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStresses array\n            Stress components at each point\n        \"\"\"\n        return iso3DStress(strains, E=self.E, nu=self.nu)\n\n    def computeStressStrainSens(self, strains, dvs):\n        \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one\n\n\n\n        Parameters\n        ----------\n        strains : numPoints x numStrains array\n            Strain components at each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        sens : numPoints x numStrains x numStates x numDim array\n            Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n        \"\"\"\n        return iso3DStressStrainSens(strains, E=self.E, nu=self.nu)\n\n    def computeVolumeScaling(self, coords, dvs):\n        \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one\n\n        For this 2D model, the volume scaling is just the thickness\n\n        Parameters\n        ----------\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints length array\n            Volume scaling parameter at each point\n        \"\"\"\n        return np.ones(coords.shape[0])\n\n    def getFunction(self, name):\n        \"\"\"Return a function that can be computed for this constitutive model\n\n        Parameters\n        ----------\n        name : str\n            Name of the function to compute\n\n        Returns\n        -------\n        callable\n            A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)\n            where:\n            states is a numPoints x numStates array\n            stateGradients is a numPoints x numStates x numDim array\n            coords is a numPoints x numDim array\n            dvs is a dictionary of numPoints length arrays\n        \"\"\"\n        if name.lower() not in self.lowerCaseFuncNames:\n            raise ValueError(\n                f\"{name} is not a valid function name for this constitutive model, valid choices are {self.functionNames}\"\n            )\n\n        if name.lower() == \"mass\":\n\n            def massFunc(states, stateGradients, coords, dvs):\n                return np.ones(states.shape[0]) * self.rho\n\n            func = massFunc\n\n        if name.lower() == \"von-mises-stress\":\n\n            def vmStressFunc(states, stateGradients, coords, dvs):\n                strains = self.computeStrains(states, stateGradients, coords, dvs)\n                stresses = self.computeStresses(strains, dvs)\n                return vonMises3D(stresses)\n\n            func = vmStressFunc\n\n        return func\n</code></pre>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.__init__","title":"<code>__init__(E, nu, rho, linear=True)</code>","text":"<p>Create an isotropic plane stress constitutive model</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.__init__--parameters","title":"Parameters","text":"<p>E : float     Elastic Modulus nu : float     Poisson's ratio rho : float     Density linear : bool, optional     Whether to use the linear kinematic equations for strains, by default True</p> Source code in <code>FEMpy/Constitutive/Iso3D.py</code> <pre><code>def __init__(self, E, nu, rho, linear=True):\n    \"\"\"Create an isotropic plane stress constitutive model\n\n    Parameters\n    ----------\n    E : float\n        Elastic Modulus\n    nu : float\n        Poisson's ratio\n    rho : float\n        Density\n    linear : bool, optional\n        Whether to use the linear kinematic equations for strains, by default True\n    \"\"\"\n    # --- Design variables ---\n    # This model has no design variables\n    designVars = {}\n\n    # --- States ---\n    stateNames = [\"X-Displacement\", \"Y-Displacement\", \"Z-Displacement\"]\n\n    # --- Strains ---\n    strainNames = [\"e_xx\", \"e_yy\", \"e_zz\", \"gamma_xy\", \"gamma_xz\", \"gamma_yz\"]\n\n    # --- Stresses ---\n    stressNames = [\"sigma_xx\", \"sigma_yy\", \"sigma_zz\", \"tau_xy\", \"tau_xz\", \"tau_yz\"]\n\n    # --- Functions ---\n    functionNames = [\"Mass\", \"Von-Mises-Stress\"]\n\n    # --- Material properties ---\n    self.E = E\n    self.nu = nu\n    self.rho = rho\n\n    numDim = 3\n\n    super().__init__(numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear)\n</code></pre>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStrainStateGradSens","title":"<code>computeStrainStateGradSens(states, stateGradients, coords, dvs)</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStrainStateGradSens--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStrainStateGradSens--returns","title":"Returns","text":"<p>numPoints x numStrains x numStates x numDim array     Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l</p> Source code in <code>FEMpy/Constitutive/Iso3D.py</code> <pre><code>def computeStrainStateGradSens(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n    sensitivity of the strains to the state gradient at each one\n\n\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStrains x numStates x numDim array\n        Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n    \"\"\"\n    return strain3DSens(UPrime=stateGradients, nonlinear=not self.isLinear)\n</code></pre>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStrains","title":"<code>computeStrains(states, stateGradients, coords, dvs)</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStrains--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStrains--returns","title":"Returns","text":"<p>numPoints x numStrains array     Strain components at each point</p> Source code in <code>FEMpy/Constitutive/Iso3D.py</code> <pre><code>def computeStrains(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStrains array\n        Strain components at each point\n    \"\"\"\n    return strain3D(UPrime=stateGradients, nonlinear=not self.isLinear)\n</code></pre>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStressStrainSens","title":"<code>computeStressStrainSens(strains, dvs)</code>","text":"<p>Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStressStrainSens--parameters","title":"Parameters","text":"<p>strains : numPoints x numStrains array     Strain components at each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStressStrainSens--returns","title":"Returns","text":"<p>sens : numPoints x numStrains x numStates x numDim array     Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l</p> Source code in <code>FEMpy/Constitutive/Iso3D.py</code> <pre><code>def computeStressStrainSens(self, strains, dvs):\n    \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one\n\n\n\n    Parameters\n    ----------\n    strains : numPoints x numStrains array\n        Strain components at each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    sens : numPoints x numStrains x numStates x numDim array\n        Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n    \"\"\"\n    return iso3DStressStrainSens(strains, E=self.E, nu=self.nu)\n</code></pre>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStresses","title":"<code>computeStresses(strains, dvs)</code>","text":"<p>Given the strains and design variables at a bunch of points, compute the stresses at each one</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStresses--parameters","title":"Parameters","text":"<p>strains : numPoints x numStrains array     Strain components at each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeStresses--returns","title":"Returns","text":"<p>numPoints x numStresses array     Stress components at each point</p> Source code in <code>FEMpy/Constitutive/Iso3D.py</code> <pre><code>def computeStresses(self, strains, dvs):\n    \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one\n\n\n\n    Parameters\n    ----------\n    strains : numPoints x numStrains array\n        Strain components at each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStresses array\n        Stress components at each point\n    \"\"\"\n    return iso3DStress(strains, E=self.E, nu=self.nu)\n</code></pre>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeVolumeScaling","title":"<code>computeVolumeScaling(coords, dvs)</code>","text":"<p>Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one</p> <p>For this 2D model, the volume scaling is just the thickness</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeVolumeScaling--parameters","title":"Parameters","text":"<p>coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.computeVolumeScaling--returns","title":"Returns","text":"<p>numPoints length array     Volume scaling parameter at each point</p> Source code in <code>FEMpy/Constitutive/Iso3D.py</code> <pre><code>def computeVolumeScaling(self, coords, dvs):\n    \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one\n\n    For this 2D model, the volume scaling is just the thickness\n\n    Parameters\n    ----------\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints length array\n        Volume scaling parameter at each point\n    \"\"\"\n    return np.ones(coords.shape[0])\n</code></pre>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.getFunction","title":"<code>getFunction(name)</code>","text":"<p>Return a function that can be computed for this constitutive model</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.getFunction--parameters","title":"Parameters","text":"<p>name : str     Name of the function to compute</p>"},{"location":"ConstitutiveModels/Iso3D/#FEMpy.Constitutive.Iso3D.Iso3D.getFunction--returns","title":"Returns","text":"<p>callable     A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)     where:     states is a numPoints x numStates array     stateGradients is a numPoints x numStates x numDim array     coords is a numPoints x numDim array     dvs is a dictionary of numPoints length arrays</p> Source code in <code>FEMpy/Constitutive/Iso3D.py</code> <pre><code>def getFunction(self, name):\n    \"\"\"Return a function that can be computed for this constitutive model\n\n    Parameters\n    ----------\n    name : str\n        Name of the function to compute\n\n    Returns\n    -------\n    callable\n        A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)\n        where:\n        states is a numPoints x numStates array\n        stateGradients is a numPoints x numStates x numDim array\n        coords is a numPoints x numDim array\n        dvs is a dictionary of numPoints length arrays\n    \"\"\"\n    if name.lower() not in self.lowerCaseFuncNames:\n        raise ValueError(\n            f\"{name} is not a valid function name for this constitutive model, valid choices are {self.functionNames}\"\n        )\n\n    if name.lower() == \"mass\":\n\n        def massFunc(states, stateGradients, coords, dvs):\n            return np.ones(states.shape[0]) * self.rho\n\n        func = massFunc\n\n    if name.lower() == \"von-mises-stress\":\n\n        def vmStressFunc(states, stateGradients, coords, dvs):\n            strains = self.computeStrains(states, stateGradients, coords, dvs)\n            stresses = self.computeStresses(strains, dvs)\n            return vonMises3D(stresses)\n\n        func = vmStressFunc\n\n    return func\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStrain/","title":"Isotropic Plane Strain","text":"<p>               Bases: <code>ConstitutiveModel</code></p> <p>A constitutive model for the 2D isotropic plane strain equations</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain--inherits","title":"Inherits","text":"<p>ConstitutiveModel : type     The base class for FEMpy constitutive models</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStrain.py</code> <pre><code>class IsoPlaneStrain(ConstitutiveModel):\n    \"\"\"A constitutive model for the 2D isotropic plane strain equations\n\n\n\n    Inherits\n    ----------\n    ConstitutiveModel : _type_\n        The base class for FEMpy constitutive models\n    \"\"\"\n\n    def __init__(self, E, nu, rho, t, linear=True):\n        \"\"\"Create an isotropic plane stress constitutive model\n\n\n\n        Parameters\n        ----------\n        E : float\n            Elastic Modulus\n        nu : float\n            Poisson's ratio\n        rho : float\n            Density\n        t : float\n            Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model\n        linear : bool, optional\n            Whether to use the linear kinematic equations for strains, by default True\n        \"\"\"\n        # --- Design variables ---\n        # This model has only one design variable, the thickness of the material\n        designVars = {}\n        designVars[\"Thickness\"] = {\"defaultValue\": t}\n\n        # --- States ---\n        stateNames = [\"X-Displacement\", \"Y-Displacement\"]\n\n        # --- Strains ---\n        strainNames = [\"e_xx\", \"e_yy\", \"gamma_xy\"]\n\n        # --- Stresses ---\n        stressNames = [\"sigma_xx\", \"sigma_yy\", \"tau_xy\"]\n\n        # --- Functions ---\n        functionNames = [\"Mass\", \"Von-Mises-Stress\"]\n\n        # --- Material properties ---\n        self.E = E\n        self.nu = nu\n        self.rho = rho\n\n        numDim = 2\n\n        super().__init__(numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear)\n\n    def computeStrains(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one\n\n\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStrains array\n            Strain components at each point\n        \"\"\"\n        return strain2D(UPrime=stateGradients, nonlinear=not self.isLinear)\n\n    def computeStrainStateGradSens(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n        sensitivity of the strains to the state gradient at each one\n\n\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStrains x numStates x numDim array\n            Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n        \"\"\"\n        return strain2DSens(UPrime=stateGradients, nonlinear=not self.isLinear)\n\n    def computeStresses(self, strains, dvs):\n        \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one\n\n\n\n        Parameters\n        ----------\n        strains : numPoints x numStrains array\n            Strain components at each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStresses array\n            Stress components at each point\n        \"\"\"\n        return isoPlaneStrainStress(strains, E=self.E, nu=self.nu)\n\n    def computeStressStrainSens(self, strains, dvs):\n        \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one\n\n\n\n        Parameters\n        ----------\n        strains : numPoints x numStrains array\n            Strain components at each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        sens : numPoints x numStrains x numStates x numDim array\n            Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n        \"\"\"\n        return isoPlaneStrainStressStrainSens(strains, E=self.E, nu=self.nu)\n\n    def computeVolumeScaling(self, coords, dvs):\n        \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one\n\n        For this 2D model, the volume scaling is just the thickness\n\n        Parameters\n        ----------\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints length array\n            Volume scaling parameter at each point\n        \"\"\"\n        return dvs[\"Thickness\"]\n\n    def getFunction(self, name):\n        \"\"\"Return a function that can be computed for this constitutive model\n\n        Parameters\n        ----------\n        name : str\n            Name of the function to compute\n\n        Returns\n        -------\n        callable\n            A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)\n            where:\n            states is a numPoints x numStates array\n            stateGradients is a numPoints x numStates x numDim array\n            coords is a numPoints x numDim array\n            dvs is a dictionary of numPoints length arrays\n        \"\"\"\n        if name.lower() not in self.lowerCaseFuncNames:\n            raise ValueError(\n                f\"{name} is not a valid function name for this constitutive model, valid choices are {self.functionNames}\"\n            )\n\n        if name.lower() == \"mass\":\n\n            def massFunc(states, stateGradients, coords, dvs):\n                return np.ones(states.shape[0]) * self.rho\n\n            func = massFunc\n\n        if name.lower() == \"von-mises-stress\":\n\n            def vmStressFunc(states, stateGradients, coords, dvs):\n                strains = self.computeStrains(states, stateGradients, coords, dvs)\n                stresses = self.computeStresses(strains, dvs)\n                return vonMises2DPlaneStrain(stresses, self.nu)\n\n            func = vmStressFunc\n\n        return func\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.__init__","title":"<code>__init__(E, nu, rho, t, linear=True)</code>","text":"<p>Create an isotropic plane stress constitutive model</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.__init__--parameters","title":"Parameters","text":"<p>E : float     Elastic Modulus nu : float     Poisson's ratio rho : float     Density t : float     Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model linear : bool, optional     Whether to use the linear kinematic equations for strains, by default True</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStrain.py</code> <pre><code>def __init__(self, E, nu, rho, t, linear=True):\n    \"\"\"Create an isotropic plane stress constitutive model\n\n\n\n    Parameters\n    ----------\n    E : float\n        Elastic Modulus\n    nu : float\n        Poisson's ratio\n    rho : float\n        Density\n    t : float\n        Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model\n    linear : bool, optional\n        Whether to use the linear kinematic equations for strains, by default True\n    \"\"\"\n    # --- Design variables ---\n    # This model has only one design variable, the thickness of the material\n    designVars = {}\n    designVars[\"Thickness\"] = {\"defaultValue\": t}\n\n    # --- States ---\n    stateNames = [\"X-Displacement\", \"Y-Displacement\"]\n\n    # --- Strains ---\n    strainNames = [\"e_xx\", \"e_yy\", \"gamma_xy\"]\n\n    # --- Stresses ---\n    stressNames = [\"sigma_xx\", \"sigma_yy\", \"tau_xy\"]\n\n    # --- Functions ---\n    functionNames = [\"Mass\", \"Von-Mises-Stress\"]\n\n    # --- Material properties ---\n    self.E = E\n    self.nu = nu\n    self.rho = rho\n\n    numDim = 2\n\n    super().__init__(numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear)\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStrainStateGradSens","title":"<code>computeStrainStateGradSens(states, stateGradients, coords, dvs)</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStrainStateGradSens--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStrainStateGradSens--returns","title":"Returns","text":"<p>numPoints x numStrains x numStates x numDim array     Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStrain.py</code> <pre><code>def computeStrainStateGradSens(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n    sensitivity of the strains to the state gradient at each one\n\n\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStrains x numStates x numDim array\n        Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n    \"\"\"\n    return strain2DSens(UPrime=stateGradients, nonlinear=not self.isLinear)\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStrains","title":"<code>computeStrains(states, stateGradients, coords, dvs)</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStrains--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStrains--returns","title":"Returns","text":"<p>numPoints x numStrains array     Strain components at each point</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStrain.py</code> <pre><code>def computeStrains(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one\n\n\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStrains array\n        Strain components at each point\n    \"\"\"\n    return strain2D(UPrime=stateGradients, nonlinear=not self.isLinear)\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStressStrainSens","title":"<code>computeStressStrainSens(strains, dvs)</code>","text":"<p>Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStressStrainSens--parameters","title":"Parameters","text":"<p>strains : numPoints x numStrains array     Strain components at each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStressStrainSens--returns","title":"Returns","text":"<p>sens : numPoints x numStrains x numStates x numDim array     Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStrain.py</code> <pre><code>def computeStressStrainSens(self, strains, dvs):\n    \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one\n\n\n\n    Parameters\n    ----------\n    strains : numPoints x numStrains array\n        Strain components at each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    sens : numPoints x numStrains x numStates x numDim array\n        Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n    \"\"\"\n    return isoPlaneStrainStressStrainSens(strains, E=self.E, nu=self.nu)\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStresses","title":"<code>computeStresses(strains, dvs)</code>","text":"<p>Given the strains and design variables at a bunch of points, compute the stresses at each one</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStresses--parameters","title":"Parameters","text":"<p>strains : numPoints x numStrains array     Strain components at each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStresses--returns","title":"Returns","text":"<p>numPoints x numStresses array     Stress components at each point</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStrain.py</code> <pre><code>def computeStresses(self, strains, dvs):\n    \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one\n\n\n\n    Parameters\n    ----------\n    strains : numPoints x numStrains array\n        Strain components at each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStresses array\n        Stress components at each point\n    \"\"\"\n    return isoPlaneStrainStress(strains, E=self.E, nu=self.nu)\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeVolumeScaling","title":"<code>computeVolumeScaling(coords, dvs)</code>","text":"<p>Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one</p> <p>For this 2D model, the volume scaling is just the thickness</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeVolumeScaling--parameters","title":"Parameters","text":"<p>coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeVolumeScaling--returns","title":"Returns","text":"<p>numPoints length array     Volume scaling parameter at each point</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStrain.py</code> <pre><code>def computeVolumeScaling(self, coords, dvs):\n    \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one\n\n    For this 2D model, the volume scaling is just the thickness\n\n    Parameters\n    ----------\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints length array\n        Volume scaling parameter at each point\n    \"\"\"\n    return dvs[\"Thickness\"]\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.getFunction","title":"<code>getFunction(name)</code>","text":"<p>Return a function that can be computed for this constitutive model</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.getFunction--parameters","title":"Parameters","text":"<p>name : str     Name of the function to compute</p>"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.getFunction--returns","title":"Returns","text":"<p>callable     A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)     where:     states is a numPoints x numStates array     stateGradients is a numPoints x numStates x numDim array     coords is a numPoints x numDim array     dvs is a dictionary of numPoints length arrays</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStrain.py</code> <pre><code>def getFunction(self, name):\n    \"\"\"Return a function that can be computed for this constitutive model\n\n    Parameters\n    ----------\n    name : str\n        Name of the function to compute\n\n    Returns\n    -------\n    callable\n        A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)\n        where:\n        states is a numPoints x numStates array\n        stateGradients is a numPoints x numStates x numDim array\n        coords is a numPoints x numDim array\n        dvs is a dictionary of numPoints length arrays\n    \"\"\"\n    if name.lower() not in self.lowerCaseFuncNames:\n        raise ValueError(\n            f\"{name} is not a valid function name for this constitutive model, valid choices are {self.functionNames}\"\n        )\n\n    if name.lower() == \"mass\":\n\n        def massFunc(states, stateGradients, coords, dvs):\n            return np.ones(states.shape[0]) * self.rho\n\n        func = massFunc\n\n    if name.lower() == \"von-mises-stress\":\n\n        def vmStressFunc(states, stateGradients, coords, dvs):\n            strains = self.computeStrains(states, stateGradients, coords, dvs)\n            stresses = self.computeStresses(strains, dvs)\n            return vonMises2DPlaneStrain(stresses, self.nu)\n\n        func = vmStressFunc\n\n    return func\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStress/","title":"Isotropic Plane Stress","text":"<p>               Bases: <code>ConstitutiveModel</code></p> <p>A constitutive model for the 2D isotropic plane stress equations</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress--inherits","title":"Inherits","text":"<p>ConstitutiveModel :     The base class for FEMpy constitutive models</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStress.py</code> <pre><code>class IsoPlaneStress(ConstitutiveModel):\n    \"\"\"A constitutive model for the 2D isotropic plane stress equations\n\n\n\n    Inherits\n    ----------\n    ConstitutiveModel :\n        The base class for FEMpy constitutive models\n    \"\"\"\n\n    def __init__(self, E, nu, rho, t, linear=True):\n        \"\"\"Create an isotropic plane stress constitutive model\n\n\n\n        Parameters\n        ----------\n        E : float\n            Elastic Modulus\n        nu : float\n            Poisson's ratio\n        rho : float\n            Density\n        t : float\n            Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model\n        linear : bool, optional\n            Whether to use the linear kinematic equations for strains, by default True\n        \"\"\"\n        # --- Design variables ---\n        # This model has only one design variable, the thickness of the material\n        designVars = {}\n        designVars[\"Thickness\"] = {\"defaultValue\": t}\n\n        # --- States ---\n        stateNames = [\"X-Displacement\", \"Y-Displacement\"]\n\n        # --- Strains ---\n        strainNames = [\"e_xx\", \"e_yy\", \"gamma_xy\"]\n\n        # --- Stresses ---\n        stressNames = [\"sigma_xx\", \"sigma_yy\", \"tau_xy\"]\n\n        # --- Functions ---\n        functionNames = [\"Mass\", \"Von-Mises-Stress\"]\n\n        # --- Material properties ---\n        self.E = E\n        self.nu = nu\n        self.rho = rho\n\n        numDim = 2\n\n        super().__init__(numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear)\n\n    def computeStrains(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one\n\n\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStrains array\n            Strain components at each point\n        \"\"\"\n        return strain2D(UPrime=stateGradients, nonlinear=not self.isLinear)\n\n    def computeStrainStateGradSens(self, states, stateGradients, coords, dvs):\n        \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n        sensitivity of the strains to the state gradient at each one\n\n\n\n        Parameters\n        ----------\n        states : numPoints x numStates array\n            State values at each point\n        stateGradients : numPoints x numStates x numDim array\n            State gradients at each point\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStrains x numStates x numDim array\n            Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n        \"\"\"\n        return strain2DSens(UPrime=stateGradients, nonlinear=not self.isLinear)\n\n    def computeStresses(self, strains, dvs):\n        \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one\n\n\n\n        Parameters\n        ----------\n        strains : numPoints x numStrains array\n            Strain components at each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints x numStresses array\n            Stress components at each point\n        \"\"\"\n        return isoPlaneStressStress(strains, E=self.E, nu=self.nu)\n\n    def computeStressStrainSens(self, strains, dvs):\n        \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one\n\n\n\n        Parameters\n        ----------\n        strains : numPoints x numStrains array\n            Strain components at each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        sens : numPoints x numStrains x numStates x numDim array\n            Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n        \"\"\"\n        return isoPlaneStressStressStrainSens(strains, E=self.E, nu=self.nu)\n\n    def computeVolumeScaling(self, coords, dvs):\n        \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one\n\n        For this 2D model, the volume scaling is just the thickness\n\n        Parameters\n        ----------\n        coords : numPoints x numDim array\n            Coordinates of each point\n        dvs : dict of arrays of length numPoints\n            Design variable values at each point\n\n        Returns\n        -------\n        numPoints length array\n            Volume scaling parameter at each point\n        \"\"\"\n        return dvs[\"Thickness\"]\n\n    def getFunction(self, name):\n        \"\"\"Return a function that can be computed for this constitutive model\n\n        Parameters\n        ----------\n        name : str\n            Name of the function to compute\n\n        Returns\n        -------\n        callable\n            A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)\n            where:\n            states is a numPoints x numStates array\n            stateGradients is a numPoints x numStates x numDim array\n            coords is a numPoints x numDim array\n            dvs is a dictionary of numPoints length arrays\n        \"\"\"\n\n        if name.lower() not in self.lowerCaseFuncNames:\n            raise ValueError(\n                f\"{name} is not a valid function name for this constitutive model, valid choices are {self.functionNames}\"\n            )\n\n        if name.lower() == \"mass\":\n\n            def massFunc(states, stateGradients, coords, dvs):\n                return np.ones(states.shape[0]) * self.rho\n\n            func = massFunc\n\n        if name.lower() == \"von-mises-stress\":\n\n            def vmStressFunc(states, stateGradients, coords, dvs):\n                strains = self.computeStrains(states, stateGradients, coords, dvs)\n                stresses = self.computeStresses(strains, dvs)\n                return vonMises2DPlaneStress(stresses)\n\n            func = vmStressFunc\n\n        return func\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.__init__","title":"<code>__init__(E, nu, rho, t, linear=True)</code>","text":"<p>Create an isotropic plane stress constitutive model</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.__init__--parameters","title":"Parameters","text":"<p>E : float     Elastic Modulus nu : float     Poisson's ratio rho : float     Density t : float     Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model linear : bool, optional     Whether to use the linear kinematic equations for strains, by default True</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStress.py</code> <pre><code>def __init__(self, E, nu, rho, t, linear=True):\n    \"\"\"Create an isotropic plane stress constitutive model\n\n\n\n    Parameters\n    ----------\n    E : float\n        Elastic Modulus\n    nu : float\n        Poisson's ratio\n    rho : float\n        Density\n    t : float\n        Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model\n    linear : bool, optional\n        Whether to use the linear kinematic equations for strains, by default True\n    \"\"\"\n    # --- Design variables ---\n    # This model has only one design variable, the thickness of the material\n    designVars = {}\n    designVars[\"Thickness\"] = {\"defaultValue\": t}\n\n    # --- States ---\n    stateNames = [\"X-Displacement\", \"Y-Displacement\"]\n\n    # --- Strains ---\n    strainNames = [\"e_xx\", \"e_yy\", \"gamma_xy\"]\n\n    # --- Stresses ---\n    stressNames = [\"sigma_xx\", \"sigma_yy\", \"tau_xy\"]\n\n    # --- Functions ---\n    functionNames = [\"Mass\", \"Von-Mises-Stress\"]\n\n    # --- Material properties ---\n    self.E = E\n    self.nu = nu\n    self.rho = rho\n\n    numDim = 2\n\n    super().__init__(numDim, stateNames, strainNames, stressNames, designVars, functionNames, linear)\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStrainStateGradSens","title":"<code>computeStrainStateGradSens(states, stateGradients, coords, dvs)</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStrainStateGradSens--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStrainStateGradSens--returns","title":"Returns","text":"<p>numPoints x numStrains x numStates x numDim array     Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStress.py</code> <pre><code>def computeStrainStateGradSens(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the\n    sensitivity of the strains to the state gradient at each one\n\n\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStrains x numStates x numDim array\n        Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n    \"\"\"\n    return strain2DSens(UPrime=stateGradients, nonlinear=not self.isLinear)\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStrains","title":"<code>computeStrains(states, stateGradients, coords, dvs)</code>","text":"<p>Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStrains--parameters","title":"Parameters","text":"<p>states : numPoints x numStates array     State values at each point stateGradients : numPoints x numStates x numDim array     State gradients at each point coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStrains--returns","title":"Returns","text":"<p>numPoints x numStrains array     Strain components at each point</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStress.py</code> <pre><code>def computeStrains(self, states, stateGradients, coords, dvs):\n    \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one\n\n\n\n    Parameters\n    ----------\n    states : numPoints x numStates array\n        State values at each point\n    stateGradients : numPoints x numStates x numDim array\n        State gradients at each point\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStrains array\n        Strain components at each point\n    \"\"\"\n    return strain2D(UPrime=stateGradients, nonlinear=not self.isLinear)\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStressStrainSens","title":"<code>computeStressStrainSens(strains, dvs)</code>","text":"<p>Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStressStrainSens--parameters","title":"Parameters","text":"<p>strains : numPoints x numStrains array     Strain components at each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStressStrainSens--returns","title":"Returns","text":"<p>sens : numPoints x numStrains x numStates x numDim array     Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStress.py</code> <pre><code>def computeStressStrainSens(self, strains, dvs):\n    \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one\n\n\n\n    Parameters\n    ----------\n    strains : numPoints x numStrains array\n        Strain components at each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    sens : numPoints x numStrains x numStates x numDim array\n        Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l\n    \"\"\"\n    return isoPlaneStressStressStrainSens(strains, E=self.E, nu=self.nu)\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStresses","title":"<code>computeStresses(strains, dvs)</code>","text":"<p>Given the strains and design variables at a bunch of points, compute the stresses at each one</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStresses--parameters","title":"Parameters","text":"<p>strains : numPoints x numStrains array     Strain components at each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStresses--returns","title":"Returns","text":"<p>numPoints x numStresses array     Stress components at each point</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStress.py</code> <pre><code>def computeStresses(self, strains, dvs):\n    \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one\n\n\n\n    Parameters\n    ----------\n    strains : numPoints x numStrains array\n        Strain components at each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints x numStresses array\n        Stress components at each point\n    \"\"\"\n    return isoPlaneStressStress(strains, E=self.E, nu=self.nu)\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeVolumeScaling","title":"<code>computeVolumeScaling(coords, dvs)</code>","text":"<p>Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one</p> <p>For this 2D model, the volume scaling is just the thickness</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeVolumeScaling--parameters","title":"Parameters","text":"<p>coords : numPoints x numDim array     Coordinates of each point dvs : dict of arrays of length numPoints     Design variable values at each point</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeVolumeScaling--returns","title":"Returns","text":"<p>numPoints length array     Volume scaling parameter at each point</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStress.py</code> <pre><code>def computeVolumeScaling(self, coords, dvs):\n    \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one\n\n    For this 2D model, the volume scaling is just the thickness\n\n    Parameters\n    ----------\n    coords : numPoints x numDim array\n        Coordinates of each point\n    dvs : dict of arrays of length numPoints\n        Design variable values at each point\n\n    Returns\n    -------\n    numPoints length array\n        Volume scaling parameter at each point\n    \"\"\"\n    return dvs[\"Thickness\"]\n</code></pre>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.getFunction","title":"<code>getFunction(name)</code>","text":"<p>Return a function that can be computed for this constitutive model</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.getFunction--parameters","title":"Parameters","text":"<p>name : str     Name of the function to compute</p>"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.getFunction--returns","title":"Returns","text":"<p>callable     A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)     where:     states is a numPoints x numStates array     stateGradients is a numPoints x numStates x numDim array     coords is a numPoints x numDim array     dvs is a dictionary of numPoints length arrays</p> Source code in <code>FEMpy/Constitutive/IsoPlaneStress.py</code> <pre><code>def getFunction(self, name):\n    \"\"\"Return a function that can be computed for this constitutive model\n\n    Parameters\n    ----------\n    name : str\n        Name of the function to compute\n\n    Returns\n    -------\n    callable\n        A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs)\n        where:\n        states is a numPoints x numStates array\n        stateGradients is a numPoints x numStates x numDim array\n        coords is a numPoints x numDim array\n        dvs is a dictionary of numPoints length arrays\n    \"\"\"\n\n    if name.lower() not in self.lowerCaseFuncNames:\n        raise ValueError(\n            f\"{name} is not a valid function name for this constitutive model, valid choices are {self.functionNames}\"\n        )\n\n    if name.lower() == \"mass\":\n\n        def massFunc(states, stateGradients, coords, dvs):\n            return np.ones(states.shape[0]) * self.rho\n\n        func = massFunc\n\n    if name.lower() == \"von-mises-stress\":\n\n        def vmStressFunc(states, stateGradients, coords, dvs):\n            strains = self.computeStrains(states, stateGradients, coords, dvs)\n            stresses = self.computeStresses(strains, dvs)\n            return vonMises2DPlaneStress(stresses)\n\n        func = vmStressFunc\n\n    return func\n</code></pre>"},{"location":"DevelopmentGuide/DevelopmentGuide/","title":"Contributors Guide","text":""},{"location":"DevelopmentGuide/DevelopmentGuide/#code-formatting-and-linting","title":"Code formatting and Linting","text":"<p>The following checks will be run on any PR using pre-commit before it can be merged into the main branch:</p> <ul> <li>Black code formatter, with 120 column line width and target python versions 3.8-3.10</li> <li>Flake8 linter, using the MDO Lab's configuration file</li> <li>Interrogate docstring check</li> <li><code>check-yaml</code> - checks yaml files for parseable syntax.</li> <li><code>check-json</code> - checks json files for parseable syntax.</li> <li><code>check-added-large-files</code> - prevents giant files from being committed.</li> <li><code>mixed-line-ending</code> - replaces or checks mixed line ending.</li> <li><code>check-merge-conflict</code> - checks for files that contain merge conflict strings.</li> <li><code>debug-statements</code> - checks for debugger imports and py37+ <code>breakpoint()</code> calls in python source.</li> </ul> <p>If you want to contribute to FEMpy please install FEMpy in editable mode and setup the pre-commit hooks to ensure consistent code formatting. The full installation process is then:</p> <pre><code># Install FEMpy in editable mode\npip install -e .[dev]\n\n# Download the MDO Lab's flake8 configuration\nwget https://raw.githubusercontent.com/mdolab/.github/master/.flake8\n\n# Install the pre-commit hooks\npre-commit install\n</code></pre> <p>If the <code>wget</code> command doesn't work on your OS, simply download the file here and place it in the root directory of your FEMpy repository.</p>"},{"location":"Elements/Element/","title":"Element Base Class","text":"<p>The base class from which all other elements are derived.</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>class Element:\n    \"\"\"The base class from which all other elements are derived.\"\"\"\n\n    def __init__(self, numNodes, numDim, quadratureOrder, numStates=None):\n        \"\"\"Instantiate an element object\n\n        Parameters\n        ----------\n        numNodes : int\n            Number of nodes in the element\n        numDim : int\n            Number of spatial dimensions the element lives in\n        quadratureOrder : int\n            Integration quadrature order\n        numStates : int, optional\n            Number of states in the underlying PDE, a.k.a the number of DOF per node, by default uses numDim\n        \"\"\"\n        self.numNodes = numNodes\n        self.numDim = numDim\n        self.numStates = numStates if numStates is not None else numDim\n        self.numDOF = self.numNodes * self.numStates\n        self.quadratureOrder = quadratureOrder\n        self.name = f\"{self.numNodes}Node-{self.numStates}Disp-{self.numDim}D-Element\"\n\n        # --- Parametric coordinate bounds ---\n        # By default it is assumed that the parametric coordinates are in the range [-1, 1] in each dimension, for\n        # elements where this is not true (e.g a 2d triangular element), these attributes should be overwritten\n        self.paramCoordLowerBounds = -np.ones(self.numDim)\n        self.paramCoordUpperBounds = np.ones(self.numDim)\n        self.paramCoordLinearConstaintMat = None\n        self.paramCoordLinearConstaintUpperBounds = None\n        self.paramCoordLinearConstaintLowerBounds = None\n\n        # --- Define fast jacobian determinant function based on number of dimensions ---\n        if self.numDim == 1:\n            self.jacDet = det1\n            self.jacInv = inv1\n        elif self.numDim == 2:\n            self.jacDet = det2\n            self.jacInv = inv2\n        elif self.numDim == 3:\n            self.jacDet = det3\n            self.jacInv = inv3\n\n        if self.numDim not in [1, 2, 3]:\n            raise ValueError(f\"Sorry, FEMpy doesn't support {self.numDim}-dimensional problems\")\n\n    # ==============================================================================\n    # Abstract methods: Must be implemented by derived classes\n    # ==============================================================================\n\n    @abc.abstractmethod\n    def computeShapeFunctions(self, paramCoords):\n        \"\"\"Compute the shape function values at a given set of parametric coordinates\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate shape functions at\n\n        Returns\n        -------\n        N: numPoint x numNodes array\n            Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def computeShapeFunctionGradients(self, paramCoords):\n        \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates\n\n\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate shape function gradients at\n\n        Returns\n        -------\n        NPrimeParam: numPoint x numDim x numNodes array\n            Shape function gradient values, NPrimeParam[i][j][k] is the derivative of the kth shape function at the ith point w.r.t the jth parametric coordinate\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def getIntegrationPointWeights(self, order=None):\n        \"\"\"Compute the integration point weights for a given quadrature order on this element\n\n        Parameters\n        ----------\n        order : int, optional\n            Integration order\n\n        Returns\n        -------\n        array of length numIntpoint\n            Integration point weights\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def getIntegrationPointCoords(self, order=None):\n        \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element\n\n        Parameters\n        ----------\n        order : int, optional\n            Integration order\n\n        Returns\n        -------\n        numIntpoint x numDim array\n            Integration point coordinates\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def getReferenceElementCoordinates(self):\n        \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined\n\n        Returns\n        -------\n        numNodes x numDim array\n            Element node coordinates\n        \"\"\"\n        raise NotImplementedError\n\n    # ==============================================================================\n    # Implemented methods\n    # ==============================================================================\n    def computeFunction(self, nodeCoords, nodeStates, elementDVs, function, elementReductionType, intOrder=None):\n        \"\"\"Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element\n\n\n\n        Parameters\n        ----------\n        nodeCoords : numElements x numNodes x numDim array\n            Node coordinates for each element\n        nodeStates : numElements x numNodes x numStates array\n            State values at the nodes of each element\n        elementDVs : dict of numElement length arrays\n            Design variable values for each element\n        function : callable\n            Function to evaluate at each point within each element, must have signature f(x, u, u', dvs), where:\n                x is an n x numDim array of coordinates\n                u is an n x numStates array of state values\n                u' is an n x (numStates*numDim) array of state gradients\n                dvs is an n x numDVs array of design variable values\n        elementReductionType : _type_\n            Type of reduction to do to get a single value for each element, can be:\n                - 'sum' : sum all values\n                - 'mean' : average all values\n                - `integrate` : integrate the function over the element\n                - 'max' : take the maximum value\n                - 'min' : take the minimum value\n                - 'ksmax' : Compute a smooth approximation of the maximum value using KS aggregation\n                - 'ksmin' : Compute a smooth approximation of the minimum value using KS aggregation\n\n        Returns\n        -------\n        values : numElements array\n            Value of the function for each element\n        \"\"\"\n\n        numElements = nodeCoords.shape[0]\n        nodeCoords = np.ascontiguousarray(nodeCoords)\n        nodeStates = np.ascontiguousarray(nodeStates)\n\n        # - Get integration point parametric coordinates and weights (same for all elements of same type)\n        intOrder = self.quadratureOrder if intOrder is None else intOrder\n        intPointWeights = self.getIntegrationPointWeights(intOrder)  # numIntPoints\n        intPointParamCoords = self.getIntegrationPointCoords(intOrder)  # numIntPoints x numDim\n        numIntPoints = len(intPointWeights)\n\n        # Get the quantities we need for the weak residual evaluation at the integration points for each element\n        pointQuantities = self._computeFunctionEvaluationQuantities(\n            intPointParamCoords,\n            nodeStates,\n            nodeCoords,\n            elementDVs,\n            quantities=[\"Coord\", \"State\", \"StateGrad\", \"DVs\", \"JacDet\"],\n        )\n        values = function(\n            pointQuantities[\"State\"], pointQuantities[\"StateGrad\"], pointQuantities[\"Coord\"], pointQuantities[\"DVs\"]\n        )\n        values = values.reshape((numElements, numIntPoints))\n\n        # perform element reduction if specified\n        if elementReductionType is not None:\n            assert elementReductionType.lower() in [\n                \"sum\",\n                \"mean\",\n                \"integrate\",\n                \"min\",\n                \"max\",\n                \"ksmax\",\n                \"ksmin\",\n            ], \"elementReductionType not valid\"\n\n            # Simple numpy reductions\n            if elementReductionType.lower() in [\"sum\", \"mean\", \"min\", \"max\"]:\n                if elementReductionType.lower() == \"sum\":\n                    reductFunc = np.sum\n\n                if elementReductionType.lower() == \"mean\":\n                    reductFunc = np.average\n\n                if elementReductionType.lower() == \"min\":\n                    reductFunc = np.min\n\n                if elementReductionType.lower() == \"max\":\n                    reductFunc = np.max\n\n                return reductFunc(values, axis=1)\n\n            if elementReductionType.lower() == \"integrate\":\n                # compute integration using weighted sum of w*values*detJ over each set of element points\n                pointQuantities[\"JacDet\"] = pointQuantities[\"JacDet\"].reshape((numElements, numIntPoints))\n\n                return np.einsum(\n                    \"ep,ep,p-&gt;e\",\n                    values,\n                    pointQuantities[\"JacDet\"],\n                    intPointWeights,\n                    optimize=[\"einsum_path\", (0, 1), (0, 1)],\n                )\n\n            if elementReductionType.lower() in [\"ksmax\", \"ksmin\"]:\n                reducedValues = np.zeros(numElements)\n                for i in range(numElements):\n                    reducedValues[i] = ksAgg(values[i, :], \"max\")\n                return reducedValues\n\n            if elementReductionType.lower() == \"ksmin\":\n                reducedValues = np.zeros(numElements)\n                for i in range(numElements):\n                    reducedValues[i] = ksAgg(values[i, :], \"min\")\n                return reducedValues\n\n        return values\n\n    def _computeFunctionEvaluationQuantities(self, paramCoords, nodeStates, nodeCoords, designVars, quantities):\n        \"\"\"Compute a series of values that are used for evaluating functions at multiple points over multiple elements\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate quantities at\n        nodeCoords : numElements x numNodes x numDim array\n            Node coordinates for each element\n        nodeStates : numElements x numNodes x numStates array\n            State values at the nodes of each element\n        designVars : dict of numElements arrays\n            Design variable values for each element\n        quantities : list of strings, optional\n            List of quantities to compute, by default None are computed, valid quatities are:\n            - \"N\" : Shape function values\n            - \"NPrimeParam\" : Shape function gradients\n            - \"Coord\" : True coordinates\n            - \"State\" : State values\n            - \"StateGrad\" : State gradients\n            - \"DVs\" : Design variable values\n            - \"Jac\" : Jacobian of the transformation from parametric to true coordinates\n            - \"JacInv\" : Inverse of the Jacobian of the transformation from parametric to true coordinates\n            - \"JacDet\" : Determinant of the Jacobian of the transformation from parametric to true coordinates\n            - \"StateGradSens\" : Sensitivity of the state gradients to the nodal states\n        \"\"\"\n        lowerCaseQuantities = [q.lower() for q in quantities]\n        outputs = {}\n        numElements = nodeCoords.shape[0]\n        numPoints = paramCoords.shape[0]\n        numPointsTotal = numElements * numPoints\n        # - Get shape functions N (du/dq) and their gradients in parametric coordinates at points\n        # (same for all elements of same type)\n        if any([q in lowerCaseQuantities for q in [\"n\", \"coords\", \"state\"]]):\n            N = self.computeShapeFunctions(paramCoords)  # numPoints x numNodes\n            if \"n\" in lowerCaseQuantities:\n                outputs[\"N\"] = N\n\n        if any(\n            [q in lowerCaseQuantities for q in [\"nprimeparam\", \"stategrad\", \"jac\", \"jacinv\", \"jacdet\", \"stategradsens\"]]\n        ):\n            NPrimeParam = self.computeShapeFunctionGradients(paramCoords)  # numPoints x numDim x numNodes\n            if \"nprimeparam\" in lowerCaseQuantities:\n                outputs[\"NPrimeParam\"] = NPrimeParam\n\n        # - Compute real coordinates at points (different for each element)\n        if \"coord\" in lowerCaseQuantities:\n            pointCoords = _interpolationProduct(N[:, : self.numNodes], nodeCoords)  # numElements x numPoints x numDim\n            outputs[\"Coord\"] = pointCoords\n\n        # - Compute states at points (different for each element)\n        if \"state\" in lowerCaseQuantities:\n            pointStates = _interpolationProduct(N, nodeStates)  # numElements x numPoints x numStates\n            outputs[\"State\"] = pointStates\n\n        # - Compute Jacobians, their inverses, and their determinants at points (different for each element)\n        if any([q in lowerCaseQuantities for q in [\"jac\", \"jacinv\", \"jacdet\", \"stategrad\", \"stategradsens\"]]):\n            pointJacs = np.zeros((numElements, numPoints, self.numDim, self.numDim))\n            _computeNPrimeCoordProduct(NPrimeParam, nodeCoords, pointJacs)\n            if \"jac\" in lowerCaseQuantities:\n                outputs[\"Jac\"] = pointJacs\n            if any([q in lowerCaseQuantities for q in [\"jacinv\", \"stategrad\", \"stategradsens\"]]):\n                pointJacInvs = self.jacInv(pointJacs)\n                if \"jacInv\" in lowerCaseQuantities:\n                    outputs[\"JacInv\"] = pointJacInvs\n            if \"jacdet\" in lowerCaseQuantities:\n                outputs[\"JacDet\"] = self.jacDet(pointJacs)  # numElements x numPoints\n\n        # - Compute du'/dq at points (different for each element)\n        if \"stategradsens\" in lowerCaseQuantities:\n            pointDUPrimedq = np.zeros((numElements, numPoints, self.numDim, self.numNodes))\n            _computeDUPrimeDqProduct(pointJacInvs, NPrimeParam, pointDUPrimedq)\n            outputs[\"StateGradSens\"] = pointDUPrimedq\n\n        # - Compute u' at points (different for each element)\n        if \"stategrad\" in lowerCaseQuantities:\n            pointStateGradients = np.zeros((numElements, numPoints, self.numStates, self.numDim))\n            _computeUPrimeProduct(pointJacInvs, NPrimeParam, nodeStates, pointStateGradients)\n            outputs[\"StateGrad\"] = pointStateGradients\n\n        # Currently everything is in numElements x numPoints x ... arrays, but the constitutive model doesn't care about\n        # the distinction between different elements, so we need to flatten the first two dimensions of each array, so\n        # they're all (numElements x numPoints) x ...\n        for key in outputs:\n            outputs[key] = np.ascontiguousarray(outputs[key].reshape(numPointsTotal, *outputs[key].shape[2:]))\n\n        # For the DVs it's a bit different, we have one DV value per element, so we actually need to expand them so that\n        # we have one value per point\n        if \"dvs\" in lowerCaseQuantities:\n            outputs[\"DVs\"] = {}\n            for dvName, dvValues in designVars.items():\n                outputs[\"DVs\"][dvName] = np.ascontiguousarray(np.repeat(dvValues, numPoints))\n\n        return outputs\n\n    def computeResiduals(self, nodeStates, nodeCoords, designVars, constitutiveModel, intOrder=None):\n        \"\"\"Compute the local residual for a series of elements\n\n        Parameters\n        ----------\n        nodeCoords : numElements x numNodes x numDim array\n            Node coordinates for each element\n        nodeStates : numElements x numNodes x numStates array\n            State values at the nodes of each element\n        designVars : dict of numElements arrays\n            Design variable values for each element\n        constitutiveModel : FEMpy constitutive model object\n            The constitutive model of the element\n\n        Returns\n        -------\n        numElement x numNodes x numStates array\n            The local residuals for each element\n        \"\"\"\n        numElements = nodeCoords.shape[0]\n        nodeCoords = np.ascontiguousarray(nodeCoords)\n        nodeStates = np.ascontiguousarray(nodeStates)\n\n        # - Get integration point parametric coordinates and weights (same for all elements of same type)\n        intOrder = self.quadratureOrder if intOrder is None else intOrder\n        intPointWeights = self.getIntegrationPointWeights(intOrder)  # numIntPoints\n        intPointParamCoords = self.getIntegrationPointCoords(intOrder)  # numIntPoints x numDim\n        numIntPoints = len(intPointWeights)\n\n        # Get the quantities we need for the weak residual evaluation at the integration points for each element\n        pointQuantities = self._computeFunctionEvaluationQuantities(\n            intPointParamCoords,\n            nodeStates,\n            nodeCoords,\n            designVars,\n            quantities=[\"Coord\", \"State\", \"StateGrad\", \"JacDet\", \"StateGradSens\", \"DVs\"],\n        )\n\n        weakRes = constitutiveModel.computeWeakResiduals(\n            pointQuantities[\"State\"], pointQuantities[\"StateGrad\"], pointQuantities[\"Coord\"], pointQuantities[\"DVs\"]\n        )\n\n        # - Compute r = du'/dq^T * f\n        r = np.zeros((numElements * numIntPoints, self.numNodes, self.numStates))\n        _transformResidual(pointQuantities[\"StateGradSens\"], weakRes, r)\n        r = r.reshape((numElements, numIntPoints, self.numNodes, self.numStates))\n        pointQuantities[\"JacDet\"] = pointQuantities[\"JacDet\"].reshape((numElements, numIntPoints))\n\n        # - Compute R, weighted sum of w * r * detJ over each set of integration points\n        # R = np.einsum(\n        #     \"epns,ep,p-&gt;ens\", r, pointQuantities[\"JacDet\"], intPointWeights, optimize=[\"einsum_path\", (1, 2), (0, 1)]\n        # )\n        R = np.zeros((numElements, self.numNodes, self.numStates))\n        _integrate(r, pointQuantities[\"JacDet\"], intPointWeights, R)\n        return R\n\n    def computeResidualJacobians(self, nodeStates, nodeCoords, designVars, constitutiveModel, intOrder=None):\n        \"\"\"Given node coordinates and states, design variable values, and a constitutive model, compute the residual Jacobian for a bunch of elements\n\n        Parameters\n        ----------\n        nodeCoords : numElements x numNodes x numDim array\n            Node coordinates for each element\n        nodeStates : numElements x numNodes x numStates array\n            State values at the nodes of each element\n        designVars : dict of numElements arrays\n            Design variable values for each element\n        constitutiveModel : FEMpy constitutive model object\n            The constitutive model of the element\n\n        Returns\n        -------\n        numElement x (numNodes * numStates) x (numNodes * numStates) array\n            The local residual Jacobian matrix for each element\n        \"\"\"\n        numElements = nodeCoords.shape[0]\n        nodeCoords = np.ascontiguousarray(nodeCoords)\n        nodeStates = np.ascontiguousarray(nodeStates)\n\n        # - Get integration point parametric coordinates and weights (same for all elements of same type)\n        intOrder = self.quadratureOrder if intOrder is None else intOrder\n        intPointWeights = self.getIntegrationPointWeights(intOrder)  # numIntPoints\n        intPointParamCoords = self.getIntegrationPointCoords(intOrder)  # numIntPoints x numDim\n        numIntPoints = len(intPointWeights)\n\n        # Get the quantities we need for the weak residual evaluation at the integration points for each element\n        pointQuantities = self._computeFunctionEvaluationQuantities(\n            intPointParamCoords,\n            nodeStates,\n            nodeCoords,\n            designVars,\n            quantities=[\"Coord\", \"State\", \"StateGrad\", \"JacDet\", \"StateGradSens\", \"DVs\"],\n        )\n\n        # Compute the weak residual Jacobians, dr/du'\n        weakJacs = constitutiveModel.computeWeakResidualJacobian(\n            pointQuantities[\"State\"], pointQuantities[\"StateGrad\"], pointQuantities[\"Coord\"], pointQuantities[\"DVs\"]\n        )\n\n        # Compute dr/dq = du'/dq^T * dr/du' * du'/dq\n        # Jacs = np.einsum(\n        #     \"pdn,pdsSD,pDN-&gt;pnsNS\",\n        #     pointQuantities[\"StateGradSens\"],\n        #     weakJacs,\n        #     pointQuantities[\"StateGradSens\"],\n        #     optimize=[\"einsum_path\", (0, 2), (0, 1)],\n        # )\n        Jacs = np.zeros((numElements * numIntPoints, self.numNodes, self.numStates, self.numNodes, self.numStates))\n        _transformResidualJacobians(pointQuantities[\"StateGradSens\"], weakJacs, Jacs)\n        Jacs = Jacs.reshape((numElements, numIntPoints, self.numNodes, self.numStates, self.numNodes, self.numStates))\n        pointQuantities[\"JacDet\"] = pointQuantities[\"JacDet\"].reshape((numElements, numIntPoints))\n\n        # - Compute R, weighted sum of w * r * detJ over each set of integration points\n        dRdq = np.zeros((numElements, self.numNodes, self.numStates, self.numNodes, self.numStates))\n        _integrate(Jacs, pointQuantities[\"JacDet\"], intPointWeights, dRdq)\n\n        return dRdq.reshape((numElements, self.numDOF, self.numDOF))\n\n    def computeStates(self, paramCoords, nodeStates):\n        \"\"\"Given nodal DOF, compute the state at given parametric coordinates within the element\n\n        This function is vectorised both across multiple elements, and multiple points within each element,\n        but the parametric coordinates are assumed to be the same across all elements\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to compute state at\n        nodeStates : numElements x numNodes x numStates array\n            State values at the nodes of each element\n\n        Returns\n        -------\n        states : numElements x numPoint x numStates array\n            State values at the given parametric coordinates for each element\n        \"\"\"\n\n        # Compute shape functions at the given parametric coordinates\n        N = self.computeShapeFunctions(paramCoords)\n\n        # Then for each element, compute the states at the points, the einsum below is equivalent to:\n        # product = np.zeros((numElements, numPoints, numStates))\n        # for ii in range(numElements):\n        #     product[ii] = N @ nodeStates[ii]\n        return _interpolationProduct(N, nodeStates)\n\n    def computeCoordinates(self, paramCoords, nodeCoords):\n        \"\"\"Given nodal coordinates, compute the real coordinates at given parametric coordinates within the element\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to compute real coordinates of\n        nodeCoords : numElements x numNodes x numDim array\n            Node coordinates for each element\n        \"\"\"\n        # Compute shape functions at the given parametric coordinates\n        N = self.computeShapeFunctions(paramCoords)\n\n        # Then for each element, compute the states at the points, the einsum below is equivalent to:\n        # product = np.zeros((numElements, numPoints, numStates))\n        # for ii in range(numElements):\n        #     product[ii] = N[:, : self.numNodes] @ nodeStates[ii]\n        return _interpolationProduct(N[:, : self.numNodes], nodeCoords)\n\n    def computeJacobians(self, paramCoords, nodeCoords):\n        \"\"\"Compute the Jacobian at a set of parametric coordinates within a set of elements\n\n        This function is vectorised both across multiple elements, and multiple points within each element,\n        but the parametric coordinates are assumed to be the same across all elements\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to compute Jacobians at\n        nodeCoords : numElements x numNodes x numDim array\n            Node coordinates for each element\n\n        Returns\n        -------\n        Jac : numElements x numPoints x numDim x numDim array\n            The Jacobians at each point in each element\n        \"\"\"\n        NPrimeParam = self.computeShapeFunctionGradients(paramCoords)  # numPoints x numDim x numNodes\n        numElements = nodeCoords.shape[0]\n        numPoints = paramCoords.shape[0]\n        Jac = np.zeros((numElements, numPoints, self.numDim, self.numDim))\n        nodeCoords = np.ascontiguousarray(nodeCoords)\n\n        # The function call below does the following:\n        # for ii in range(numElements):\n        #   for jj in range(numPoints):\n        #     Jac[ii, jj] = NPrimeParam[jj] @ nodeCoords[ii]\n        _computeNPrimeCoordProduct(NPrimeParam, nodeCoords, Jac)\n        return Jac\n\n    def computeStateGradients(self, paramCoords, nodeStates, nodeCoords):\n        \"\"\"Given nodal DOF, compute the gradient of the state at given parametric coordinates within the element\n\n        The gradient of the state at each point in each element is a numStates x numDim array.\n\n        This function is vectorised both across multiple elements, and multiple points within each element,\n        but the parametric coordinates are assumed to be the same across all elements\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to compute state at\n        nodeStates : numElements x numNodes x numStates array\n            State values at the nodes of each element\n        nodeCoords : numElements x numNodes x numDim array\n            Node coordinates for each element\n\n        Returns\n        -------\n        stateGradients : numElements x numPoint x numStates x numDim array\n            The gradient of the states at each point in each element, stateGradient[i, j, k, l] is the value of\n            $du_k/dx_l$ at the $j^{th}$ point in the $i^{th}$ element\n        \"\"\"\n\n        numElements = nodeCoords.shape[0]\n        numPoints = paramCoords.shape[0]\n        NPrimeParam = self.computeShapeFunctionGradients(paramCoords)\n        Jac = np.zeros((numElements, numPoints, self.numDim, self.numDim))\n        _computeNPrimeCoordProduct(NPrimeParam, nodeCoords, Jac)\n        JacInv = self.jacInv(np.reshape(Jac, (numElements * numPoints, self.numDim, self.numDim)))\n        JacInv = np.reshape(JacInv, (numElements, numPoints, self.numDim, self.numDim))\n        UPrime = np.zeros((numElements, numPoints, self.numStates, self.numDim))\n        # The function call below is equivalent to the following\n        # for ii in range(numElements):\n        #     for jj in range(numPoints):\n        #         result[ii, jj] = (JacInv[ii, jj] @ NPrimeParam[jj] @ nodeStates[ii]).T\n        _computeUPrimeProduct(JacInv, NPrimeParam, np.ascontiguousarray(nodeStates), UPrime)\n        return UPrime\n\n    # Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element\n\n    def getClosestPoints(self, nodeCoords, point, **kwargs):\n        \"\"\"Given real coordinates of a point, find the parametric coordinates of the closest point on a series of\n        elements to that point\n\n        Computing the closest point is an optimization problem of the form:\n\n        min ||X(x) - P||^2\n\n        s.t Ax &lt;= b\n            lb &lt;= x &lt;= ub\n\n        Where X are the real coordinates of a point in the element, x the parametric coordinates of that point, and P is\n        the target point. lb &lt;= x &lt;= ub and Ax &lt;= b are a set of bounds and linear constraints on the parametric\n        coordinates that encode the bounds of the element.\n\n        Parameters\n        ----------\n        nodeCoords : numElements x numNodes x numDim array\n            The coordinates of the elements\n        point : array of length numDim\n            Target point coordinates\n\n        Returns\n        -------\n        closestParamCoords : numElements x numDim array\n            The parametric coordinates of the closest point in each element\n        closestDistances : numElements array\n            The distances from the closest point in each element to the target point\n        \"\"\"\n        numElements = nodeCoords.shape[0]\n        closestDistances = np.zeros(numElements)\n        closestParamCoords = np.zeros((numElements, self.numDim))\n\n        paramCoordBounds = Bounds(lb=self.paramCoordLowerBounds, ub=self.paramCoordUpperBounds)\n        if self.paramCoordLinearConstaintMat is not None:\n            paramCoordLinearConstraints = LinearConstraint(\n                self.paramCoordLinearConstaintMat,\n                self.paramCoordLinearConstaintLowerBounds,\n                self.paramCoordLinearConstaintUpperBounds,\n                keep_feasible=True,\n            )\n        else:\n            paramCoordLinearConstraints = None\n\n        for ii in range(numElements):\n            closestParamCoords[ii], closestDistances[ii] = self._getClosestPoint(\n                nodeCoords[ii], point, paramCoordBounds, paramCoordLinearConstraints, **kwargs\n            )\n\n        return closestParamCoords, closestDistances\n\n    def _getClosestPoint(self, nodeCoords, point, paramCoordBounds, paramCoordLinearConstraints, **kwargs):\n        \"\"\"Find the closest point on a single element to a given point\n\n        Parameters\n        ----------\n        nodeCoords : numNodes x numDim array\n            The coordinates of the element nodes\n        point : array of length numDim\n            Target point coordinates\n        paramCoordBounds : scipy.optimize.Bounds object\n            Parametric coordinate bounds\n        paramCoordLinearConstraints : scipy.optimize.LinearConstraint object\n            Any linear constraints required to enforce the parametric coordinate bounds\n\n        Returns\n        -------\n        array of length numDim\n            The parametric coordinates of the closest point in the element\n        float\n            The distance from the closest point in the element to the target point\n        \"\"\"\n        nodeCoordCopy = np.zeros((1, self.numNodes, self.numDim))\n        nodeCoordCopy[0] = nodeCoords\n\n        def r(xParam):\n            xTrue = self.computeCoordinates(np.atleast_2d(xParam), nodeCoordCopy).flatten()\n            error = np.linalg.norm(xTrue - point)\n            print(f\"{xParam=}, {xTrue=}, {point=}, {error=}\")\n            return error\n\n        def drdxParam(xParam):\n            xTrue = self.computeCoordinates(np.atleast_2d(xParam), nodeCoordCopy).flatten()\n            Jac = self.computeJacobians(np.atleast_2d(xParam), nodeCoordCopy)\n            return 2 * (xTrue - point) @ Jac[0, 0].T\n\n        if \"tol\" not in kwargs:\n            kwargs[\"tol\"] = 1e-10\n\n        maxAttempts = 10\n        closestPointFound = False\n        for _ in range(maxAttempts):\n            x0 = self.getRandParamCoord(1)[0]\n            sol = minimize(\n                r,\n                x0,\n                jac=drdxParam,\n                bounds=paramCoordBounds,\n                constraints=paramCoordLinearConstraints,\n                method=\"trust-constr\",\n                **kwargs,\n            )\n            closestPointFound = sol.fun &lt; 1e-4\n            if closestPointFound:\n                break\n\n        return sol.x, sol.fun\n\n    def getRandomElementCoordinates(self, rng=None):\n        \"\"\"Compute random node coordinates for an element\n\n        The random node coordinates are computed by taking the reference element coordinates and then applying:\n        - Random perturbations to each node\n        - Random translation in each dimension\n        - Random scalings in each dimension\n        - Random rotations around each available axis\n\n        Parameters\n        ----------\n        rng : numpy random Generator, optional\n            Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n            case a new one is created for this call\n        \"\"\"\n        if rng is None:\n            rng = np.random.default_rng()\n        coords = self.getReferenceElementCoordinates()  # numNodes x numDim array\n\n        # Perturb coordinates by up to 40% of the minimum distance between any two nodes\n        _, minDistance = _computeMaxMinDistance(coords)\n        coords += rng.random(coords.shape) * 0.4 * minDistance\n\n        # Apply random translation\n        for ii in range(self.numDim):\n            translation = rng.random() * 2 * minDistance - minDistance\n            coords[:, ii] += translation\n\n        # Scale each dimension by a random factor between 0.1 and 10\n        for dim in range(self.numDim):\n            scalingPower = rng.random() * 2 - 1\n            coords[:, dim] *= 10**scalingPower\n\n        # Rotate the element around each axis by a random angle\n        if self.numDim == 2:\n            angle = rng.random() * 4 * np.pi - 2 * np.pi\n            c, s = np.cos(angle), np.sin(angle)\n            R = np.array(((c, s), (-s, c)))\n            coords = coords @ R.T\n        elif self.numDim == 3:\n            R = Rotation.random(random_state=rng)\n            coords = coords @ R.as_matrix().T\n\n        return coords\n\n    # ==============================================================================\n    # Testing methods\n    # ==============================================================================\n\n    def getRandParamCoord(self, n, rng=None):\n        \"\"\"Get a random set of parametric coordinates within the element\n\n        By default this method assumes the the valid parametric coordinates are between -1 and 1 in each direction. If this is not the case for a particular element then that element should reimplemnt this method.\n\n        Parameters\n        ----------\n        n : int\n            Number of points to generate\n        rng : numpy random Generator, optional\n            Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n            case a new one is created for this call\n        \"\"\"\n        if rng is None:\n            rng = np.random.default_rng()\n        return rng.random((n, self.numDim)) * 2 - 1\n\n    def testShapeFunctionDerivatives(self, n=10, rng=None):\n        \"\"\"Test the implementation of the shape function derivatives using the complex-step method\n\n        Parameters\n        ----------\n        n : int, optional\n            Number of random coordinates to generate, by default 10\n        rng : numpy random Generator, optional\n            Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n            case a new one is created for this call\n        \"\"\"\n        paramCoords = self.getRandParamCoord(n, rng=rng)\n        coordPert = np.zeros_like(paramCoords, dtype=\"complex128\")\n        dN = self.computeShapeFunctionGradients(paramCoords)\n        dNApprox = np.zeros_like(dN)\n        for i in range(self.numDim):\n            np.copyto(coordPert, paramCoords)\n            coordPert[:, i] += 1e-200 * 1j\n            dNApprox[:, i, :] = 1e200 * np.imag(self.computeShapeFunctions(coordPert))\n        return dN - dNApprox\n\n    def testShapeFunctionSum(self, n=10, rng=None):\n        \"\"\"Test the basic property that shape function values should sum to 1 everywhere within an element\n\n        Parameters\n        ----------\n        n : int, optional\n            Number of points to test at, by default 10\n        rng : numpy random Generator, optional\n            Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n            case a new one is created for this call\n        \"\"\"\n        paramCoords = self.getRandParamCoord(n, rng=rng)\n        N = self.computeShapeFunctions(paramCoords)\n        return np.sum(N, axis=1)\n\n    def testInterpolation(self, n=10, rng=None):\n        \"\"\"Validate that, when the element geometry matches the reference element exactly, the parametric and real coordinates are the same\n\n        Parameters\n        ----------\n        n : int, optional\n            Number of points to test at, by default 10\n        rng : numpy random Generator, optional\n            Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n            case a new one is created for this call\n        \"\"\"\n        nodeCoords = np.zeros((1, self.numNodes, self.numDim))\n        nodeCoords[0] = self.getReferenceElementCoordinates()\n        paramCoords = self.getRandParamCoord(n, rng=rng)\n        error = np.zeros((n, self.numDim))\n        x = self.computeCoordinates(paramCoords, nodeCoords)\n        error = x - paramCoords\n        return error\n\n    def testIdentityJacobian(self, n=10, rng=None):\n        \"\"\"Validate that, when the element geometry matches the reference element exactly, the mapping Jacobian is the identity matrix everywhere.\n\n        Parameters\n        ----------\n        n : int, optional\n            Number of points to test at, by default 10\n        rng : numpy random Generator, optional\n            Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n            case a new one is created for this call\n        \"\"\"\n        nodeCoords = np.zeros((1, self.numNodes, self.numDim))\n        nodeCoords[0] = self.getReferenceElementCoordinates()\n        paramCoords = self.getRandParamCoord(n, rng=rng)\n\n        # The expected Jacobians are a stack of n identity matrices\n        expectedJacs = np.tile(np.eye(self.numDim), (1, n, 1, 1))\n        Jacs = self.computeJacobians(paramCoords, nodeCoords)\n        return Jacs - expectedJacs\n\n    def testStateGradient(self, n=10, rng=None):\n        \"\"\"Test that the state gradient is correctly reconstructed within the element\n\n        This test works by generating random node coordinates, then computing the states at each node using the\n        following equation:\n\n        u_i = a_i * x + b_i * y + c_i * z + d_i\n\n        This field has a gradient, du/dx, of [a_i, b_i, c_i] everywhere in the element, which should be exactly\n        reproduced by the state gradient computed by the element.\n\n        Parameters\n        ----------\n        n : int, optional\n            _description_, by default 10\n        rng : numpy random Generator, optional\n            Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n            case a new one is created for this call\n        \"\"\"\n        if rng is None:\n            rng = np.random.default_rng()\n        nodeCoords = np.zeros((1, self.numNodes, self.numDim))\n        nodeCoords[0] = self.getRandomElementCoordinates(rng=rng)\n        paramCoords = self.getRandParamCoord(n, rng=rng)\n\n        randStateGradient = rng.random((self.numStates, self.numDim))\n        ExpectedStateGradients = np.tile(randStateGradient, (1, n, 1, 1))\n\n        nodeStates = np.zeros((1, self.numNodes, self.numStates))\n        for ii in range(self.numNodes):\n            for jj in range(self.numStates):\n                nodeStates[:, ii, jj] = np.dot(nodeCoords[0, ii], randStateGradient[jj])\n\n        stateGradient = self.computeStateGradients(paramCoords, nodeStates, nodeCoords)\n\n        return stateGradient - ExpectedStateGradients\n\n    def testGetClosestPoints(self, n=10, tol=1e-10, rng=None):\n        \"\"\"Test the getClosestPoints method\n\n        This test works by generating a set of random parametric coordinates, converting them to real coordinates, and\n        then checking that the parametric coordinates returned by getClosestPoints match the original random values.\n\n        Parameters\n        ----------\n        n : int, optional\n            Number of random coordinates to generate, by default 10\n        rng : numpy random Generator, optional\n            Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n            case a new one is created for this call\n        \"\"\"\n        nodeCoords = np.zeros((1, self.numNodes, self.numDim))\n        nodeCoords[0] = self.getRandomElementCoordinates(rng=rng)\n        paramCoords = self.getRandParamCoord(n, rng=rng)\n        realCoords = self.computeCoordinates(paramCoords, nodeCoords)\n        error = np.zeros_like(realCoords)\n        for i in range(n):\n            coords, _ = self.getClosestPoints(nodeCoords, realCoords[0, i], tol=tol)\n            error[0, i] = coords - paramCoords[i]\n        return error\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.__init__","title":"<code>__init__(numNodes, numDim, quadratureOrder, numStates=None)</code>","text":"<p>Instantiate an element object</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.__init__--parameters","title":"Parameters","text":"<p>numNodes : int     Number of nodes in the element numDim : int     Number of spatial dimensions the element lives in quadratureOrder : int     Integration quadrature order numStates : int, optional     Number of states in the underlying PDE, a.k.a the number of DOF per node, by default uses numDim</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def __init__(self, numNodes, numDim, quadratureOrder, numStates=None):\n    \"\"\"Instantiate an element object\n\n    Parameters\n    ----------\n    numNodes : int\n        Number of nodes in the element\n    numDim : int\n        Number of spatial dimensions the element lives in\n    quadratureOrder : int\n        Integration quadrature order\n    numStates : int, optional\n        Number of states in the underlying PDE, a.k.a the number of DOF per node, by default uses numDim\n    \"\"\"\n    self.numNodes = numNodes\n    self.numDim = numDim\n    self.numStates = numStates if numStates is not None else numDim\n    self.numDOF = self.numNodes * self.numStates\n    self.quadratureOrder = quadratureOrder\n    self.name = f\"{self.numNodes}Node-{self.numStates}Disp-{self.numDim}D-Element\"\n\n    # --- Parametric coordinate bounds ---\n    # By default it is assumed that the parametric coordinates are in the range [-1, 1] in each dimension, for\n    # elements where this is not true (e.g a 2d triangular element), these attributes should be overwritten\n    self.paramCoordLowerBounds = -np.ones(self.numDim)\n    self.paramCoordUpperBounds = np.ones(self.numDim)\n    self.paramCoordLinearConstaintMat = None\n    self.paramCoordLinearConstaintUpperBounds = None\n    self.paramCoordLinearConstaintLowerBounds = None\n\n    # --- Define fast jacobian determinant function based on number of dimensions ---\n    if self.numDim == 1:\n        self.jacDet = det1\n        self.jacInv = inv1\n    elif self.numDim == 2:\n        self.jacDet = det2\n        self.jacInv = inv2\n    elif self.numDim == 3:\n        self.jacDet = det3\n        self.jacInv = inv3\n\n    if self.numDim not in [1, 2, 3]:\n        raise ValueError(f\"Sorry, FEMpy doesn't support {self.numDim}-dimensional problems\")\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeCoordinates","title":"<code>computeCoordinates(paramCoords, nodeCoords)</code>","text":"<p>Given nodal coordinates, compute the real coordinates at given parametric coordinates within the element</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeCoordinates--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to compute real coordinates of nodeCoords : numElements x numNodes x numDim array     Node coordinates for each element</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def computeCoordinates(self, paramCoords, nodeCoords):\n    \"\"\"Given nodal coordinates, compute the real coordinates at given parametric coordinates within the element\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to compute real coordinates of\n    nodeCoords : numElements x numNodes x numDim array\n        Node coordinates for each element\n    \"\"\"\n    # Compute shape functions at the given parametric coordinates\n    N = self.computeShapeFunctions(paramCoords)\n\n    # Then for each element, compute the states at the points, the einsum below is equivalent to:\n    # product = np.zeros((numElements, numPoints, numStates))\n    # for ii in range(numElements):\n    #     product[ii] = N[:, : self.numNodes] @ nodeStates[ii]\n    return _interpolationProduct(N[:, : self.numNodes], nodeCoords)\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeFunction","title":"<code>computeFunction(nodeCoords, nodeStates, elementDVs, function, elementReductionType, intOrder=None)</code>","text":"<p>Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeFunction--parameters","title":"Parameters","text":"<p>nodeCoords : numElements x numNodes x numDim array     Node coordinates for each element nodeStates : numElements x numNodes x numStates array     State values at the nodes of each element elementDVs : dict of numElement length arrays     Design variable values for each element function : callable     Function to evaluate at each point within each element, must have signature f(x, u, u', dvs), where:         x is an n x numDim array of coordinates         u is an n x numStates array of state values         u' is an n x (numStates*numDim) array of state gradients         dvs is an n x numDVs array of design variable values elementReductionType : type     Type of reduction to do to get a single value for each element, can be:         - 'sum' : sum all values         - 'mean' : average all values         - <code>integrate</code> : integrate the function over the element         - 'max' : take the maximum value         - 'min' : take the minimum value         - 'ksmax' : Compute a smooth approximation of the maximum value using KS aggregation         - 'ksmin' : Compute a smooth approximation of the minimum value using KS aggregation</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeFunction--returns","title":"Returns","text":"<p>values : numElements array     Value of the function for each element</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def computeFunction(self, nodeCoords, nodeStates, elementDVs, function, elementReductionType, intOrder=None):\n    \"\"\"Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element\n\n\n\n    Parameters\n    ----------\n    nodeCoords : numElements x numNodes x numDim array\n        Node coordinates for each element\n    nodeStates : numElements x numNodes x numStates array\n        State values at the nodes of each element\n    elementDVs : dict of numElement length arrays\n        Design variable values for each element\n    function : callable\n        Function to evaluate at each point within each element, must have signature f(x, u, u', dvs), where:\n            x is an n x numDim array of coordinates\n            u is an n x numStates array of state values\n            u' is an n x (numStates*numDim) array of state gradients\n            dvs is an n x numDVs array of design variable values\n    elementReductionType : _type_\n        Type of reduction to do to get a single value for each element, can be:\n            - 'sum' : sum all values\n            - 'mean' : average all values\n            - `integrate` : integrate the function over the element\n            - 'max' : take the maximum value\n            - 'min' : take the minimum value\n            - 'ksmax' : Compute a smooth approximation of the maximum value using KS aggregation\n            - 'ksmin' : Compute a smooth approximation of the minimum value using KS aggregation\n\n    Returns\n    -------\n    values : numElements array\n        Value of the function for each element\n    \"\"\"\n\n    numElements = nodeCoords.shape[0]\n    nodeCoords = np.ascontiguousarray(nodeCoords)\n    nodeStates = np.ascontiguousarray(nodeStates)\n\n    # - Get integration point parametric coordinates and weights (same for all elements of same type)\n    intOrder = self.quadratureOrder if intOrder is None else intOrder\n    intPointWeights = self.getIntegrationPointWeights(intOrder)  # numIntPoints\n    intPointParamCoords = self.getIntegrationPointCoords(intOrder)  # numIntPoints x numDim\n    numIntPoints = len(intPointWeights)\n\n    # Get the quantities we need for the weak residual evaluation at the integration points for each element\n    pointQuantities = self._computeFunctionEvaluationQuantities(\n        intPointParamCoords,\n        nodeStates,\n        nodeCoords,\n        elementDVs,\n        quantities=[\"Coord\", \"State\", \"StateGrad\", \"DVs\", \"JacDet\"],\n    )\n    values = function(\n        pointQuantities[\"State\"], pointQuantities[\"StateGrad\"], pointQuantities[\"Coord\"], pointQuantities[\"DVs\"]\n    )\n    values = values.reshape((numElements, numIntPoints))\n\n    # perform element reduction if specified\n    if elementReductionType is not None:\n        assert elementReductionType.lower() in [\n            \"sum\",\n            \"mean\",\n            \"integrate\",\n            \"min\",\n            \"max\",\n            \"ksmax\",\n            \"ksmin\",\n        ], \"elementReductionType not valid\"\n\n        # Simple numpy reductions\n        if elementReductionType.lower() in [\"sum\", \"mean\", \"min\", \"max\"]:\n            if elementReductionType.lower() == \"sum\":\n                reductFunc = np.sum\n\n            if elementReductionType.lower() == \"mean\":\n                reductFunc = np.average\n\n            if elementReductionType.lower() == \"min\":\n                reductFunc = np.min\n\n            if elementReductionType.lower() == \"max\":\n                reductFunc = np.max\n\n            return reductFunc(values, axis=1)\n\n        if elementReductionType.lower() == \"integrate\":\n            # compute integration using weighted sum of w*values*detJ over each set of element points\n            pointQuantities[\"JacDet\"] = pointQuantities[\"JacDet\"].reshape((numElements, numIntPoints))\n\n            return np.einsum(\n                \"ep,ep,p-&gt;e\",\n                values,\n                pointQuantities[\"JacDet\"],\n                intPointWeights,\n                optimize=[\"einsum_path\", (0, 1), (0, 1)],\n            )\n\n        if elementReductionType.lower() in [\"ksmax\", \"ksmin\"]:\n            reducedValues = np.zeros(numElements)\n            for i in range(numElements):\n                reducedValues[i] = ksAgg(values[i, :], \"max\")\n            return reducedValues\n\n        if elementReductionType.lower() == \"ksmin\":\n            reducedValues = np.zeros(numElements)\n            for i in range(numElements):\n                reducedValues[i] = ksAgg(values[i, :], \"min\")\n            return reducedValues\n\n    return values\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeJacobians","title":"<code>computeJacobians(paramCoords, nodeCoords)</code>","text":"<p>Compute the Jacobian at a set of parametric coordinates within a set of elements</p> <p>This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeJacobians--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to compute Jacobians at nodeCoords : numElements x numNodes x numDim array     Node coordinates for each element</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeJacobians--returns","title":"Returns","text":"<p>Jac : numElements x numPoints x numDim x numDim array     The Jacobians at each point in each element</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def computeJacobians(self, paramCoords, nodeCoords):\n    \"\"\"Compute the Jacobian at a set of parametric coordinates within a set of elements\n\n    This function is vectorised both across multiple elements, and multiple points within each element,\n    but the parametric coordinates are assumed to be the same across all elements\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to compute Jacobians at\n    nodeCoords : numElements x numNodes x numDim array\n        Node coordinates for each element\n\n    Returns\n    -------\n    Jac : numElements x numPoints x numDim x numDim array\n        The Jacobians at each point in each element\n    \"\"\"\n    NPrimeParam = self.computeShapeFunctionGradients(paramCoords)  # numPoints x numDim x numNodes\n    numElements = nodeCoords.shape[0]\n    numPoints = paramCoords.shape[0]\n    Jac = np.zeros((numElements, numPoints, self.numDim, self.numDim))\n    nodeCoords = np.ascontiguousarray(nodeCoords)\n\n    # The function call below does the following:\n    # for ii in range(numElements):\n    #   for jj in range(numPoints):\n    #     Jac[ii, jj] = NPrimeParam[jj] @ nodeCoords[ii]\n    _computeNPrimeCoordProduct(NPrimeParam, nodeCoords, Jac)\n    return Jac\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeResidualJacobians","title":"<code>computeResidualJacobians(nodeStates, nodeCoords, designVars, constitutiveModel, intOrder=None)</code>","text":"<p>Given node coordinates and states, design variable values, and a constitutive model, compute the residual Jacobian for a bunch of elements</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeResidualJacobians--parameters","title":"Parameters","text":"<p>nodeCoords : numElements x numNodes x numDim array     Node coordinates for each element nodeStates : numElements x numNodes x numStates array     State values at the nodes of each element designVars : dict of numElements arrays     Design variable values for each element constitutiveModel : FEMpy constitutive model object     The constitutive model of the element</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeResidualJacobians--returns","title":"Returns","text":"<p>numElement x (numNodes * numStates) x (numNodes * numStates) array     The local residual Jacobian matrix for each element</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def computeResidualJacobians(self, nodeStates, nodeCoords, designVars, constitutiveModel, intOrder=None):\n    \"\"\"Given node coordinates and states, design variable values, and a constitutive model, compute the residual Jacobian for a bunch of elements\n\n    Parameters\n    ----------\n    nodeCoords : numElements x numNodes x numDim array\n        Node coordinates for each element\n    nodeStates : numElements x numNodes x numStates array\n        State values at the nodes of each element\n    designVars : dict of numElements arrays\n        Design variable values for each element\n    constitutiveModel : FEMpy constitutive model object\n        The constitutive model of the element\n\n    Returns\n    -------\n    numElement x (numNodes * numStates) x (numNodes * numStates) array\n        The local residual Jacobian matrix for each element\n    \"\"\"\n    numElements = nodeCoords.shape[0]\n    nodeCoords = np.ascontiguousarray(nodeCoords)\n    nodeStates = np.ascontiguousarray(nodeStates)\n\n    # - Get integration point parametric coordinates and weights (same for all elements of same type)\n    intOrder = self.quadratureOrder if intOrder is None else intOrder\n    intPointWeights = self.getIntegrationPointWeights(intOrder)  # numIntPoints\n    intPointParamCoords = self.getIntegrationPointCoords(intOrder)  # numIntPoints x numDim\n    numIntPoints = len(intPointWeights)\n\n    # Get the quantities we need for the weak residual evaluation at the integration points for each element\n    pointQuantities = self._computeFunctionEvaluationQuantities(\n        intPointParamCoords,\n        nodeStates,\n        nodeCoords,\n        designVars,\n        quantities=[\"Coord\", \"State\", \"StateGrad\", \"JacDet\", \"StateGradSens\", \"DVs\"],\n    )\n\n    # Compute the weak residual Jacobians, dr/du'\n    weakJacs = constitutiveModel.computeWeakResidualJacobian(\n        pointQuantities[\"State\"], pointQuantities[\"StateGrad\"], pointQuantities[\"Coord\"], pointQuantities[\"DVs\"]\n    )\n\n    # Compute dr/dq = du'/dq^T * dr/du' * du'/dq\n    # Jacs = np.einsum(\n    #     \"pdn,pdsSD,pDN-&gt;pnsNS\",\n    #     pointQuantities[\"StateGradSens\"],\n    #     weakJacs,\n    #     pointQuantities[\"StateGradSens\"],\n    #     optimize=[\"einsum_path\", (0, 2), (0, 1)],\n    # )\n    Jacs = np.zeros((numElements * numIntPoints, self.numNodes, self.numStates, self.numNodes, self.numStates))\n    _transformResidualJacobians(pointQuantities[\"StateGradSens\"], weakJacs, Jacs)\n    Jacs = Jacs.reshape((numElements, numIntPoints, self.numNodes, self.numStates, self.numNodes, self.numStates))\n    pointQuantities[\"JacDet\"] = pointQuantities[\"JacDet\"].reshape((numElements, numIntPoints))\n\n    # - Compute R, weighted sum of w * r * detJ over each set of integration points\n    dRdq = np.zeros((numElements, self.numNodes, self.numStates, self.numNodes, self.numStates))\n    _integrate(Jacs, pointQuantities[\"JacDet\"], intPointWeights, dRdq)\n\n    return dRdq.reshape((numElements, self.numDOF, self.numDOF))\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeResiduals","title":"<code>computeResiduals(nodeStates, nodeCoords, designVars, constitutiveModel, intOrder=None)</code>","text":"<p>Compute the local residual for a series of elements</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeResiduals--parameters","title":"Parameters","text":"<p>nodeCoords : numElements x numNodes x numDim array     Node coordinates for each element nodeStates : numElements x numNodes x numStates array     State values at the nodes of each element designVars : dict of numElements arrays     Design variable values for each element constitutiveModel : FEMpy constitutive model object     The constitutive model of the element</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeResiduals--returns","title":"Returns","text":"<p>numElement x numNodes x numStates array     The local residuals for each element</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def computeResiduals(self, nodeStates, nodeCoords, designVars, constitutiveModel, intOrder=None):\n    \"\"\"Compute the local residual for a series of elements\n\n    Parameters\n    ----------\n    nodeCoords : numElements x numNodes x numDim array\n        Node coordinates for each element\n    nodeStates : numElements x numNodes x numStates array\n        State values at the nodes of each element\n    designVars : dict of numElements arrays\n        Design variable values for each element\n    constitutiveModel : FEMpy constitutive model object\n        The constitutive model of the element\n\n    Returns\n    -------\n    numElement x numNodes x numStates array\n        The local residuals for each element\n    \"\"\"\n    numElements = nodeCoords.shape[0]\n    nodeCoords = np.ascontiguousarray(nodeCoords)\n    nodeStates = np.ascontiguousarray(nodeStates)\n\n    # - Get integration point parametric coordinates and weights (same for all elements of same type)\n    intOrder = self.quadratureOrder if intOrder is None else intOrder\n    intPointWeights = self.getIntegrationPointWeights(intOrder)  # numIntPoints\n    intPointParamCoords = self.getIntegrationPointCoords(intOrder)  # numIntPoints x numDim\n    numIntPoints = len(intPointWeights)\n\n    # Get the quantities we need for the weak residual evaluation at the integration points for each element\n    pointQuantities = self._computeFunctionEvaluationQuantities(\n        intPointParamCoords,\n        nodeStates,\n        nodeCoords,\n        designVars,\n        quantities=[\"Coord\", \"State\", \"StateGrad\", \"JacDet\", \"StateGradSens\", \"DVs\"],\n    )\n\n    weakRes = constitutiveModel.computeWeakResiduals(\n        pointQuantities[\"State\"], pointQuantities[\"StateGrad\"], pointQuantities[\"Coord\"], pointQuantities[\"DVs\"]\n    )\n\n    # - Compute r = du'/dq^T * f\n    r = np.zeros((numElements * numIntPoints, self.numNodes, self.numStates))\n    _transformResidual(pointQuantities[\"StateGradSens\"], weakRes, r)\n    r = r.reshape((numElements, numIntPoints, self.numNodes, self.numStates))\n    pointQuantities[\"JacDet\"] = pointQuantities[\"JacDet\"].reshape((numElements, numIntPoints))\n\n    # - Compute R, weighted sum of w * r * detJ over each set of integration points\n    # R = np.einsum(\n    #     \"epns,ep,p-&gt;ens\", r, pointQuantities[\"JacDet\"], intPointWeights, optimize=[\"einsum_path\", (1, 2), (0, 1)]\n    # )\n    R = np.zeros((numElements, self.numNodes, self.numStates))\n    _integrate(r, pointQuantities[\"JacDet\"], intPointWeights, R)\n    return R\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeShapeFunctionGradients","title":"<code>computeShapeFunctionGradients(paramCoords)</code>  <code>abstractmethod</code>","text":"<p>Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeShapeFunctionGradients--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to evaluate shape function gradients at</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeShapeFunctionGradients--returns","title":"Returns","text":"<p>NPrimeParam: numPoint x numDim x numNodes array     Shape function gradient values, NPrimeParami[k] is the derivative of the kth shape function at the ith point w.r.t the jth parametric coordinate</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>@abc.abstractmethod\ndef computeShapeFunctionGradients(self, paramCoords):\n    \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates\n\n\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to evaluate shape function gradients at\n\n    Returns\n    -------\n    NPrimeParam: numPoint x numDim x numNodes array\n        Shape function gradient values, NPrimeParam[i][j][k] is the derivative of the kth shape function at the ith point w.r.t the jth parametric coordinate\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeShapeFunctions","title":"<code>computeShapeFunctions(paramCoords)</code>  <code>abstractmethod</code>","text":"<p>Compute the shape function values at a given set of parametric coordinates</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeShapeFunctions--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to evaluate shape functions at</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeShapeFunctions--returns","title":"Returns","text":"<p>N: numPoint x numNodes array     Array of shape function values at the given parametric coordinates, Ni is the value of the jth shape function at the ith parametric point</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>@abc.abstractmethod\ndef computeShapeFunctions(self, paramCoords):\n    \"\"\"Compute the shape function values at a given set of parametric coordinates\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to evaluate shape functions at\n\n    Returns\n    -------\n    N: numPoint x numNodes array\n        Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeStateGradients","title":"<code>computeStateGradients(paramCoords, nodeStates, nodeCoords)</code>","text":"<p>Given nodal DOF, compute the gradient of the state at given parametric coordinates within the element</p> <p>The gradient of the state at each point in each element is a numStates x numDim array.</p> <p>This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeStateGradients--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to compute state at nodeStates : numElements x numNodes x numStates array     State values at the nodes of each element nodeCoords : numElements x numNodes x numDim array     Node coordinates for each element</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeStateGradients--returns","title":"Returns","text":"<p>stateGradients : numElements x numPoint x numStates x numDim array     The gradient of the states at each point in each element, stateGradient[i, j, k, l] is the value of     \\(du_k/dx_l\\) at the \\(j^{th}\\) point in the \\(i^{th}\\) element</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def computeStateGradients(self, paramCoords, nodeStates, nodeCoords):\n    \"\"\"Given nodal DOF, compute the gradient of the state at given parametric coordinates within the element\n\n    The gradient of the state at each point in each element is a numStates x numDim array.\n\n    This function is vectorised both across multiple elements, and multiple points within each element,\n    but the parametric coordinates are assumed to be the same across all elements\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to compute state at\n    nodeStates : numElements x numNodes x numStates array\n        State values at the nodes of each element\n    nodeCoords : numElements x numNodes x numDim array\n        Node coordinates for each element\n\n    Returns\n    -------\n    stateGradients : numElements x numPoint x numStates x numDim array\n        The gradient of the states at each point in each element, stateGradient[i, j, k, l] is the value of\n        $du_k/dx_l$ at the $j^{th}$ point in the $i^{th}$ element\n    \"\"\"\n\n    numElements = nodeCoords.shape[0]\n    numPoints = paramCoords.shape[0]\n    NPrimeParam = self.computeShapeFunctionGradients(paramCoords)\n    Jac = np.zeros((numElements, numPoints, self.numDim, self.numDim))\n    _computeNPrimeCoordProduct(NPrimeParam, nodeCoords, Jac)\n    JacInv = self.jacInv(np.reshape(Jac, (numElements * numPoints, self.numDim, self.numDim)))\n    JacInv = np.reshape(JacInv, (numElements, numPoints, self.numDim, self.numDim))\n    UPrime = np.zeros((numElements, numPoints, self.numStates, self.numDim))\n    # The function call below is equivalent to the following\n    # for ii in range(numElements):\n    #     for jj in range(numPoints):\n    #         result[ii, jj] = (JacInv[ii, jj] @ NPrimeParam[jj] @ nodeStates[ii]).T\n    _computeUPrimeProduct(JacInv, NPrimeParam, np.ascontiguousarray(nodeStates), UPrime)\n    return UPrime\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeStates","title":"<code>computeStates(paramCoords, nodeStates)</code>","text":"<p>Given nodal DOF, compute the state at given parametric coordinates within the element</p> <p>This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeStates--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to compute state at nodeStates : numElements x numNodes x numStates array     State values at the nodes of each element</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeStates--returns","title":"Returns","text":"<p>states : numElements x numPoint x numStates array     State values at the given parametric coordinates for each element</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def computeStates(self, paramCoords, nodeStates):\n    \"\"\"Given nodal DOF, compute the state at given parametric coordinates within the element\n\n    This function is vectorised both across multiple elements, and multiple points within each element,\n    but the parametric coordinates are assumed to be the same across all elements\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to compute state at\n    nodeStates : numElements x numNodes x numStates array\n        State values at the nodes of each element\n\n    Returns\n    -------\n    states : numElements x numPoint x numStates array\n        State values at the given parametric coordinates for each element\n    \"\"\"\n\n    # Compute shape functions at the given parametric coordinates\n    N = self.computeShapeFunctions(paramCoords)\n\n    # Then for each element, compute the states at the points, the einsum below is equivalent to:\n    # product = np.zeros((numElements, numPoints, numStates))\n    # for ii in range(numElements):\n    #     product[ii] = N @ nodeStates[ii]\n    return _interpolationProduct(N, nodeStates)\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getClosestPoints","title":"<code>getClosestPoints(nodeCoords, point, **kwargs)</code>","text":"<p>Given real coordinates of a point, find the parametric coordinates of the closest point on a series of elements to that point</p> <p>Computing the closest point is an optimization problem of the form:</p> <p>min ||X(x) - P||^2</p> <p>s.t Ax &lt;= b     lb &lt;= x &lt;= ub</p> <p>Where X are the real coordinates of a point in the element, x the parametric coordinates of that point, and P is the target point. lb &lt;= x &lt;= ub and Ax &lt;= b are a set of bounds and linear constraints on the parametric coordinates that encode the bounds of the element.</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getClosestPoints--parameters","title":"Parameters","text":"<p>nodeCoords : numElements x numNodes x numDim array     The coordinates of the elements point : array of length numDim     Target point coordinates</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getClosestPoints--returns","title":"Returns","text":"<p>closestParamCoords : numElements x numDim array     The parametric coordinates of the closest point in each element closestDistances : numElements array     The distances from the closest point in each element to the target point</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def getClosestPoints(self, nodeCoords, point, **kwargs):\n    \"\"\"Given real coordinates of a point, find the parametric coordinates of the closest point on a series of\n    elements to that point\n\n    Computing the closest point is an optimization problem of the form:\n\n    min ||X(x) - P||^2\n\n    s.t Ax &lt;= b\n        lb &lt;= x &lt;= ub\n\n    Where X are the real coordinates of a point in the element, x the parametric coordinates of that point, and P is\n    the target point. lb &lt;= x &lt;= ub and Ax &lt;= b are a set of bounds and linear constraints on the parametric\n    coordinates that encode the bounds of the element.\n\n    Parameters\n    ----------\n    nodeCoords : numElements x numNodes x numDim array\n        The coordinates of the elements\n    point : array of length numDim\n        Target point coordinates\n\n    Returns\n    -------\n    closestParamCoords : numElements x numDim array\n        The parametric coordinates of the closest point in each element\n    closestDistances : numElements array\n        The distances from the closest point in each element to the target point\n    \"\"\"\n    numElements = nodeCoords.shape[0]\n    closestDistances = np.zeros(numElements)\n    closestParamCoords = np.zeros((numElements, self.numDim))\n\n    paramCoordBounds = Bounds(lb=self.paramCoordLowerBounds, ub=self.paramCoordUpperBounds)\n    if self.paramCoordLinearConstaintMat is not None:\n        paramCoordLinearConstraints = LinearConstraint(\n            self.paramCoordLinearConstaintMat,\n            self.paramCoordLinearConstaintLowerBounds,\n            self.paramCoordLinearConstaintUpperBounds,\n            keep_feasible=True,\n        )\n    else:\n        paramCoordLinearConstraints = None\n\n    for ii in range(numElements):\n        closestParamCoords[ii], closestDistances[ii] = self._getClosestPoint(\n            nodeCoords[ii], point, paramCoordBounds, paramCoordLinearConstraints, **kwargs\n        )\n\n    return closestParamCoords, closestDistances\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getIntegrationPointCoords","title":"<code>getIntegrationPointCoords(order=None)</code>  <code>abstractmethod</code>","text":"<p>Compute the integration point parameteric coordinates for a given quadrature order on this element</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getIntegrationPointCoords--parameters","title":"Parameters","text":"<p>order : int, optional     Integration order</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getIntegrationPointCoords--returns","title":"Returns","text":"<p>numIntpoint x numDim array     Integration point coordinates</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>@abc.abstractmethod\ndef getIntegrationPointCoords(self, order=None):\n    \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element\n\n    Parameters\n    ----------\n    order : int, optional\n        Integration order\n\n    Returns\n    -------\n    numIntpoint x numDim array\n        Integration point coordinates\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getIntegrationPointWeights","title":"<code>getIntegrationPointWeights(order=None)</code>  <code>abstractmethod</code>","text":"<p>Compute the integration point weights for a given quadrature order on this element</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getIntegrationPointWeights--parameters","title":"Parameters","text":"<p>order : int, optional     Integration order</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getIntegrationPointWeights--returns","title":"Returns","text":"<p>array of length numIntpoint     Integration point weights</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>@abc.abstractmethod\ndef getIntegrationPointWeights(self, order=None):\n    \"\"\"Compute the integration point weights for a given quadrature order on this element\n\n    Parameters\n    ----------\n    order : int, optional\n        Integration order\n\n    Returns\n    -------\n    array of length numIntpoint\n        Integration point weights\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getRandParamCoord","title":"<code>getRandParamCoord(n, rng=None)</code>","text":"<p>Get a random set of parametric coordinates within the element</p> <p>By default this method assumes the the valid parametric coordinates are between -1 and 1 in each direction. If this is not the case for a particular element then that element should reimplemnt this method.</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getRandParamCoord--parameters","title":"Parameters","text":"<p>n : int     Number of points to generate rng : numpy random Generator, optional     Random number generator to use, useful for creating consistent test behaviour, by default None, in which     case a new one is created for this call</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def getRandParamCoord(self, n, rng=None):\n    \"\"\"Get a random set of parametric coordinates within the element\n\n    By default this method assumes the the valid parametric coordinates are between -1 and 1 in each direction. If this is not the case for a particular element then that element should reimplemnt this method.\n\n    Parameters\n    ----------\n    n : int\n        Number of points to generate\n    rng : numpy random Generator, optional\n        Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n        case a new one is created for this call\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    return rng.random((n, self.numDim)) * 2 - 1\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getRandomElementCoordinates","title":"<code>getRandomElementCoordinates(rng=None)</code>","text":"<p>Compute random node coordinates for an element</p> <p>The random node coordinates are computed by taking the reference element coordinates and then applying: - Random perturbations to each node - Random translation in each dimension - Random scalings in each dimension - Random rotations around each available axis</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getRandomElementCoordinates--parameters","title":"Parameters","text":"<p>rng : numpy random Generator, optional     Random number generator to use, useful for creating consistent test behaviour, by default None, in which     case a new one is created for this call</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def getRandomElementCoordinates(self, rng=None):\n    \"\"\"Compute random node coordinates for an element\n\n    The random node coordinates are computed by taking the reference element coordinates and then applying:\n    - Random perturbations to each node\n    - Random translation in each dimension\n    - Random scalings in each dimension\n    - Random rotations around each available axis\n\n    Parameters\n    ----------\n    rng : numpy random Generator, optional\n        Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n        case a new one is created for this call\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    coords = self.getReferenceElementCoordinates()  # numNodes x numDim array\n\n    # Perturb coordinates by up to 40% of the minimum distance between any two nodes\n    _, minDistance = _computeMaxMinDistance(coords)\n    coords += rng.random(coords.shape) * 0.4 * minDistance\n\n    # Apply random translation\n    for ii in range(self.numDim):\n        translation = rng.random() * 2 * minDistance - minDistance\n        coords[:, ii] += translation\n\n    # Scale each dimension by a random factor between 0.1 and 10\n    for dim in range(self.numDim):\n        scalingPower = rng.random() * 2 - 1\n        coords[:, dim] *= 10**scalingPower\n\n    # Rotate the element around each axis by a random angle\n    if self.numDim == 2:\n        angle = rng.random() * 4 * np.pi - 2 * np.pi\n        c, s = np.cos(angle), np.sin(angle)\n        R = np.array(((c, s), (-s, c)))\n        coords = coords @ R.T\n    elif self.numDim == 3:\n        R = Rotation.random(random_state=rng)\n        coords = coords @ R.as_matrix().T\n\n    return coords\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getReferenceElementCoordinates","title":"<code>getReferenceElementCoordinates()</code>  <code>abstractmethod</code>","text":"<p>Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getReferenceElementCoordinates--returns","title":"Returns","text":"<p>numNodes x numDim array     Element node coordinates</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>@abc.abstractmethod\ndef getReferenceElementCoordinates(self):\n    \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined\n\n    Returns\n    -------\n    numNodes x numDim array\n        Element node coordinates\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testGetClosestPoints","title":"<code>testGetClosestPoints(n=10, tol=1e-10, rng=None)</code>","text":"<p>Test the getClosestPoints method</p> <p>This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getClosestPoints match the original random values.</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testGetClosestPoints--parameters","title":"Parameters","text":"<p>n : int, optional     Number of random coordinates to generate, by default 10 rng : numpy random Generator, optional     Random number generator to use, useful for creating consistent test behaviour, by default None, in which     case a new one is created for this call</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def testGetClosestPoints(self, n=10, tol=1e-10, rng=None):\n    \"\"\"Test the getClosestPoints method\n\n    This test works by generating a set of random parametric coordinates, converting them to real coordinates, and\n    then checking that the parametric coordinates returned by getClosestPoints match the original random values.\n\n    Parameters\n    ----------\n    n : int, optional\n        Number of random coordinates to generate, by default 10\n    rng : numpy random Generator, optional\n        Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n        case a new one is created for this call\n    \"\"\"\n    nodeCoords = np.zeros((1, self.numNodes, self.numDim))\n    nodeCoords[0] = self.getRandomElementCoordinates(rng=rng)\n    paramCoords = self.getRandParamCoord(n, rng=rng)\n    realCoords = self.computeCoordinates(paramCoords, nodeCoords)\n    error = np.zeros_like(realCoords)\n    for i in range(n):\n        coords, _ = self.getClosestPoints(nodeCoords, realCoords[0, i], tol=tol)\n        error[0, i] = coords - paramCoords[i]\n    return error\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testIdentityJacobian","title":"<code>testIdentityJacobian(n=10, rng=None)</code>","text":"<p>Validate that, when the element geometry matches the reference element exactly, the mapping Jacobian is the identity matrix everywhere.</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testIdentityJacobian--parameters","title":"Parameters","text":"<p>n : int, optional     Number of points to test at, by default 10 rng : numpy random Generator, optional     Random number generator to use, useful for creating consistent test behaviour, by default None, in which     case a new one is created for this call</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def testIdentityJacobian(self, n=10, rng=None):\n    \"\"\"Validate that, when the element geometry matches the reference element exactly, the mapping Jacobian is the identity matrix everywhere.\n\n    Parameters\n    ----------\n    n : int, optional\n        Number of points to test at, by default 10\n    rng : numpy random Generator, optional\n        Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n        case a new one is created for this call\n    \"\"\"\n    nodeCoords = np.zeros((1, self.numNodes, self.numDim))\n    nodeCoords[0] = self.getReferenceElementCoordinates()\n    paramCoords = self.getRandParamCoord(n, rng=rng)\n\n    # The expected Jacobians are a stack of n identity matrices\n    expectedJacs = np.tile(np.eye(self.numDim), (1, n, 1, 1))\n    Jacs = self.computeJacobians(paramCoords, nodeCoords)\n    return Jacs - expectedJacs\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testInterpolation","title":"<code>testInterpolation(n=10, rng=None)</code>","text":"<p>Validate that, when the element geometry matches the reference element exactly, the parametric and real coordinates are the same</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testInterpolation--parameters","title":"Parameters","text":"<p>n : int, optional     Number of points to test at, by default 10 rng : numpy random Generator, optional     Random number generator to use, useful for creating consistent test behaviour, by default None, in which     case a new one is created for this call</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def testInterpolation(self, n=10, rng=None):\n    \"\"\"Validate that, when the element geometry matches the reference element exactly, the parametric and real coordinates are the same\n\n    Parameters\n    ----------\n    n : int, optional\n        Number of points to test at, by default 10\n    rng : numpy random Generator, optional\n        Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n        case a new one is created for this call\n    \"\"\"\n    nodeCoords = np.zeros((1, self.numNodes, self.numDim))\n    nodeCoords[0] = self.getReferenceElementCoordinates()\n    paramCoords = self.getRandParamCoord(n, rng=rng)\n    error = np.zeros((n, self.numDim))\n    x = self.computeCoordinates(paramCoords, nodeCoords)\n    error = x - paramCoords\n    return error\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testShapeFunctionDerivatives","title":"<code>testShapeFunctionDerivatives(n=10, rng=None)</code>","text":"<p>Test the implementation of the shape function derivatives using the complex-step method</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testShapeFunctionDerivatives--parameters","title":"Parameters","text":"<p>n : int, optional     Number of random coordinates to generate, by default 10 rng : numpy random Generator, optional     Random number generator to use, useful for creating consistent test behaviour, by default None, in which     case a new one is created for this call</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def testShapeFunctionDerivatives(self, n=10, rng=None):\n    \"\"\"Test the implementation of the shape function derivatives using the complex-step method\n\n    Parameters\n    ----------\n    n : int, optional\n        Number of random coordinates to generate, by default 10\n    rng : numpy random Generator, optional\n        Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n        case a new one is created for this call\n    \"\"\"\n    paramCoords = self.getRandParamCoord(n, rng=rng)\n    coordPert = np.zeros_like(paramCoords, dtype=\"complex128\")\n    dN = self.computeShapeFunctionGradients(paramCoords)\n    dNApprox = np.zeros_like(dN)\n    for i in range(self.numDim):\n        np.copyto(coordPert, paramCoords)\n        coordPert[:, i] += 1e-200 * 1j\n        dNApprox[:, i, :] = 1e200 * np.imag(self.computeShapeFunctions(coordPert))\n    return dN - dNApprox\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testShapeFunctionSum","title":"<code>testShapeFunctionSum(n=10, rng=None)</code>","text":"<p>Test the basic property that shape function values should sum to 1 everywhere within an element</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testShapeFunctionSum--parameters","title":"Parameters","text":"<p>n : int, optional     Number of points to test at, by default 10 rng : numpy random Generator, optional     Random number generator to use, useful for creating consistent test behaviour, by default None, in which     case a new one is created for this call</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def testShapeFunctionSum(self, n=10, rng=None):\n    \"\"\"Test the basic property that shape function values should sum to 1 everywhere within an element\n\n    Parameters\n    ----------\n    n : int, optional\n        Number of points to test at, by default 10\n    rng : numpy random Generator, optional\n        Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n        case a new one is created for this call\n    \"\"\"\n    paramCoords = self.getRandParamCoord(n, rng=rng)\n    N = self.computeShapeFunctions(paramCoords)\n    return np.sum(N, axis=1)\n</code></pre>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testStateGradient","title":"<code>testStateGradient(n=10, rng=None)</code>","text":"<p>Test that the state gradient is correctly reconstructed within the element</p> <p>This test works by generating random node coordinates, then computing the states at each node using the following equation:</p> <p>u_i = a_i * x + b_i * y + c_i * z + d_i</p> <p>This field has a gradient, du/dx, of [a_i, b_i, c_i] everywhere in the element, which should be exactly reproduced by the state gradient computed by the element.</p>"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testStateGradient--parameters","title":"Parameters","text":"<p>n : int, optional     description, by default 10 rng : numpy random Generator, optional     Random number generator to use, useful for creating consistent test behaviour, by default None, in which     case a new one is created for this call</p> Source code in <code>FEMpy/Elements/Element.py</code> <pre><code>def testStateGradient(self, n=10, rng=None):\n    \"\"\"Test that the state gradient is correctly reconstructed within the element\n\n    This test works by generating random node coordinates, then computing the states at each node using the\n    following equation:\n\n    u_i = a_i * x + b_i * y + c_i * z + d_i\n\n    This field has a gradient, du/dx, of [a_i, b_i, c_i] everywhere in the element, which should be exactly\n    reproduced by the state gradient computed by the element.\n\n    Parameters\n    ----------\n    n : int, optional\n        _description_, by default 10\n    rng : numpy random Generator, optional\n        Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n        case a new one is created for this call\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    nodeCoords = np.zeros((1, self.numNodes, self.numDim))\n    nodeCoords[0] = self.getRandomElementCoordinates(rng=rng)\n    paramCoords = self.getRandParamCoord(n, rng=rng)\n\n    randStateGradient = rng.random((self.numStates, self.numDim))\n    ExpectedStateGradients = np.tile(randStateGradient, (1, n, 1, 1))\n\n    nodeStates = np.zeros((1, self.numNodes, self.numStates))\n    for ii in range(self.numNodes):\n        for jj in range(self.numStates):\n            nodeStates[:, ii, jj] = np.dot(nodeCoords[0, ii], randStateGradient[jj])\n\n    stateGradient = self.computeStateGradients(paramCoords, nodeStates, nodeCoords)\n\n    return stateGradient - ExpectedStateGradients\n</code></pre>"},{"location":"Elements/Hex3D/","title":"3D Hex Element","text":"<p>               Bases: <code>Element</code></p> <p>An \"arbitrary order\" 3d hexahedral finite element</p> <p>Like the QuadElement2D, the arbitrary order bit is in quotes because I have not figured out how to do the node reordering from the shape function ordering to the node ordering used by MeshIO for anything more than 2<sup>nd</sup> order hex elements yet</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D--inherits-from","title":"Inherits from","text":"<p>Element : FEMpy Element class     The base FEMpy element class</p> Source code in <code>FEMpy/Elements/HexElement3D.py</code> <pre><code>class HexElement3D(Element):\n    \"\"\"An \"arbitrary order\" 3d hexahedral finite element\n\n    Like the QuadElement2D, the arbitrary order bit is in quotes because I have not figured out how to do the node\n    reordering from the shape function ordering to the node ordering used by MeshIO for anything more than 2nd order\n    hex elements yet\n\n    Inherits from\n    -------------\n    Element : FEMpy Element class\n        The base FEMpy element class\n    \"\"\"\n\n    def __init__(self, order=1, numStates=None, quadratureOrder=None):\n        \"\"\"Create a new 3d hexahedral finite element object\n\n        Parameters\n        ----------\n        order : int, optional\n            Element order, a first order hex has 6 nodes, 2nd order 27 etc, currently only orders 1-3 are\n            supported, by default 1\n        numStates : int, optional\n            Number of states in the underlying PDE, by default 3\n        quadratureOrder : int, optional\n            Quadrature order to use for numerical integration, by default None, in which case a valid order for the\n            chosen element order is used\n\n        Raises\n        ------\n        ValueError\n            Raises error if order is not 1, 2 or 3\n        \"\"\"\n        if order not in [1, 2]:\n            raise ValueError(\"Hex elements only support orders 1 and 2\")\n        self.order = order\n        numNodes = (order + 1) ** 3\n        if quadratureOrder is None:\n            shapeFuncOrder = 2 * order\n            quadratureOrder = int(np.ceil((shapeFuncOrder + 1) / 2))\n        super().__init__(numNodes, numDim=3, quadratureOrder=quadratureOrder, numStates=numStates)\n\n        self.name = f\"Order{self.order}-LagrangeHex\"\n\n        self.shapeFuncToNodeOrder = self._getNodeReordering(self.order)\n\n    # ==============================================================================\n    # Public methods\n    # ==============================================================================\n\n    def computeShapeFunctions(self, paramCoords):\n        \"\"\"Compute the shape function values at a given set of parametric coordinates\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate shape functions at\n\n        Returns\n        -------\n        N: numPoint x numNodes array\n            Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point\n        \"\"\"\n        N = LP.LagrangePoly3d(paramCoords[:, 0], paramCoords[:, 1], paramCoords[:, 2], self.order + 1)\n        return np.ascontiguousarray(N[:, self.shapeFuncToNodeOrder])\n\n    def computeShapeFunctionGradients(self, paramCoords):\n        \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates\n\n\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate shape function gradients at\n\n        Returns\n        -------\n        NGrad: numPoint x numDim x numNodes array\n            Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth\n            parametric coordinate\n        \"\"\"\n        NPrimeParam = LP.LagrangePoly3dDeriv(paramCoords[:, 0], paramCoords[:, 1], paramCoords[:, 2], self.order + 1)\n        return np.ascontiguousarray(NPrimeParam[:, :, self.shapeFuncToNodeOrder])\n\n    def getIntegrationPointWeights(self, order=None):\n        \"\"\"Compute the integration point weights for a given quadrature order on this element\n\n        Parameters\n        ----------\n        order : int\n            Integration order\n\n        Returns\n        -------\n        array of length numIntpoint\n            Integration point weights\n        \"\"\"\n        if order is None:\n            order = self.quadratureOrder\n        return getGaussQuadWeights(self.numDim, order)\n\n    def getIntegrationPointCoords(self, order=None):\n        \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element\n\n        Parameters\n        ----------\n        order : int\n            Integration order\n\n        Returns\n        -------\n        numIntpoint x numDim array\n            Integration point coordinates\n        \"\"\"\n        if order is None:\n            order = self.quadratureOrder\n        return getGaussQuadPoints(self.numDim, order)\n\n    def getReferenceElementCoordinates(self):\n        \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined\n\n        For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering\n\n        Returns\n        -------\n        numNodes x numDim array\n            Element node coordinates\n        \"\"\"\n        numPoints = self.order + 1\n        p = np.linspace(-1, 1, numPoints)\n        x = np.tile(p, numPoints**2)\n        y = np.tile(np.repeat(p, numPoints), numPoints)\n        z = np.repeat(p, numPoints**2)\n        return np.vstack((x[self.shapeFuncToNodeOrder], y[self.shapeFuncToNodeOrder], z[self.shapeFuncToNodeOrder])).T\n\n    # ==============================================================================\n    # Private methods\n    # ==============================================================================\n\n    @staticmethod\n    def _getNodeReordering(order):\n        \"\"\"Compute the reordering required between shape functions and nodes\n\n        The 23d lagrange polynomial shape functions are ordered left to right, front to back and then bottom to top, but the node ordering is defined differently in finite element meshes. This method computes the reordering required to map the shape functions to the correct node ordering. As of now I have simply manually implemented this for the first few orders, but it should be possible to compute this for any order with some sort of recursion.\n\n        Parameters\n        ----------\n        order : int\n            Quad element order\n\n        Returns\n        -------\n        np.array\n            Reordering array, array[i] = j indicates that the ith shape function should be reordered to the jth node\n        \"\"\"\n        if order == 1:\n            return np.array([0, 1, 3, 2, 4, 5, 7, 6])\n        if order == 2:\n            return np.array(\n                [0, 2, 8, 6, 18, 20, 26, 24, 1, 5, 7, 3, 19, 23, 25, 21, 9, 11, 17, 15, 12, 14, 10, 16, 4, 22, 13]\n            )\n</code></pre>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.__init__","title":"<code>__init__(order=1, numStates=None, quadratureOrder=None)</code>","text":"<p>Create a new 3d hexahedral finite element object</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.__init__--parameters","title":"Parameters","text":"<p>order : int, optional     Element order, a first order hex has 6 nodes, 2<sup>nd</sup> order 27 etc, currently only orders 1-3 are     supported, by default 1 numStates : int, optional     Number of states in the underlying PDE, by default 3 quadratureOrder : int, optional     Quadrature order to use for numerical integration, by default None, in which case a valid order for the     chosen element order is used</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.__init__--raises","title":"Raises","text":"<p>ValueError     Raises error if order is not 1, 2 or 3</p> Source code in <code>FEMpy/Elements/HexElement3D.py</code> <pre><code>def __init__(self, order=1, numStates=None, quadratureOrder=None):\n    \"\"\"Create a new 3d hexahedral finite element object\n\n    Parameters\n    ----------\n    order : int, optional\n        Element order, a first order hex has 6 nodes, 2nd order 27 etc, currently only orders 1-3 are\n        supported, by default 1\n    numStates : int, optional\n        Number of states in the underlying PDE, by default 3\n    quadratureOrder : int, optional\n        Quadrature order to use for numerical integration, by default None, in which case a valid order for the\n        chosen element order is used\n\n    Raises\n    ------\n    ValueError\n        Raises error if order is not 1, 2 or 3\n    \"\"\"\n    if order not in [1, 2]:\n        raise ValueError(\"Hex elements only support orders 1 and 2\")\n    self.order = order\n    numNodes = (order + 1) ** 3\n    if quadratureOrder is None:\n        shapeFuncOrder = 2 * order\n        quadratureOrder = int(np.ceil((shapeFuncOrder + 1) / 2))\n    super().__init__(numNodes, numDim=3, quadratureOrder=quadratureOrder, numStates=numStates)\n\n    self.name = f\"Order{self.order}-LagrangeHex\"\n\n    self.shapeFuncToNodeOrder = self._getNodeReordering(self.order)\n</code></pre>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.computeShapeFunctionGradients","title":"<code>computeShapeFunctionGradients(paramCoords)</code>","text":"<p>Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.computeShapeFunctionGradients--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to evaluate shape function gradients at</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.computeShapeFunctionGradients--returns","title":"Returns","text":"<p>NGrad: numPoint x numDim x numNodes array     Shape function gradient values, NGradi[k] is the value of the kth shape function at the ith point w.r.t the kth     parametric coordinate</p> Source code in <code>FEMpy/Elements/HexElement3D.py</code> <pre><code>def computeShapeFunctionGradients(self, paramCoords):\n    \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates\n\n\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to evaluate shape function gradients at\n\n    Returns\n    -------\n    NGrad: numPoint x numDim x numNodes array\n        Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth\n        parametric coordinate\n    \"\"\"\n    NPrimeParam = LP.LagrangePoly3dDeriv(paramCoords[:, 0], paramCoords[:, 1], paramCoords[:, 2], self.order + 1)\n    return np.ascontiguousarray(NPrimeParam[:, :, self.shapeFuncToNodeOrder])\n</code></pre>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.computeShapeFunctions","title":"<code>computeShapeFunctions(paramCoords)</code>","text":"<p>Compute the shape function values at a given set of parametric coordinates</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.computeShapeFunctions--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to evaluate shape functions at</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.computeShapeFunctions--returns","title":"Returns","text":"<p>N: numPoint x numNodes array     Array of shape function values at the given parametric coordinates, Ni is the value of the jth shape function at the ith parametric point</p> Source code in <code>FEMpy/Elements/HexElement3D.py</code> <pre><code>def computeShapeFunctions(self, paramCoords):\n    \"\"\"Compute the shape function values at a given set of parametric coordinates\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to evaluate shape functions at\n\n    Returns\n    -------\n    N: numPoint x numNodes array\n        Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point\n    \"\"\"\n    N = LP.LagrangePoly3d(paramCoords[:, 0], paramCoords[:, 1], paramCoords[:, 2], self.order + 1)\n    return np.ascontiguousarray(N[:, self.shapeFuncToNodeOrder])\n</code></pre>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getIntegrationPointCoords","title":"<code>getIntegrationPointCoords(order=None)</code>","text":"<p>Compute the integration point parameteric coordinates for a given quadrature order on this element</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getIntegrationPointCoords--parameters","title":"Parameters","text":"<p>order : int     Integration order</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getIntegrationPointCoords--returns","title":"Returns","text":"<p>numIntpoint x numDim array     Integration point coordinates</p> Source code in <code>FEMpy/Elements/HexElement3D.py</code> <pre><code>def getIntegrationPointCoords(self, order=None):\n    \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element\n\n    Parameters\n    ----------\n    order : int\n        Integration order\n\n    Returns\n    -------\n    numIntpoint x numDim array\n        Integration point coordinates\n    \"\"\"\n    if order is None:\n        order = self.quadratureOrder\n    return getGaussQuadPoints(self.numDim, order)\n</code></pre>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getIntegrationPointWeights","title":"<code>getIntegrationPointWeights(order=None)</code>","text":"<p>Compute the integration point weights for a given quadrature order on this element</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getIntegrationPointWeights--parameters","title":"Parameters","text":"<p>order : int     Integration order</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getIntegrationPointWeights--returns","title":"Returns","text":"<p>array of length numIntpoint     Integration point weights</p> Source code in <code>FEMpy/Elements/HexElement3D.py</code> <pre><code>def getIntegrationPointWeights(self, order=None):\n    \"\"\"Compute the integration point weights for a given quadrature order on this element\n\n    Parameters\n    ----------\n    order : int\n        Integration order\n\n    Returns\n    -------\n    array of length numIntpoint\n        Integration point weights\n    \"\"\"\n    if order is None:\n        order = self.quadratureOrder\n    return getGaussQuadWeights(self.numDim, order)\n</code></pre>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getReferenceElementCoordinates","title":"<code>getReferenceElementCoordinates()</code>","text":"<p>Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined</p> <p>For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering</p>"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getReferenceElementCoordinates--returns","title":"Returns","text":"<p>numNodes x numDim array     Element node coordinates</p> Source code in <code>FEMpy/Elements/HexElement3D.py</code> <pre><code>def getReferenceElementCoordinates(self):\n    \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined\n\n    For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering\n\n    Returns\n    -------\n    numNodes x numDim array\n        Element node coordinates\n    \"\"\"\n    numPoints = self.order + 1\n    p = np.linspace(-1, 1, numPoints)\n    x = np.tile(p, numPoints**2)\n    y = np.tile(np.repeat(p, numPoints), numPoints)\n    z = np.repeat(p, numPoints**2)\n    return np.vstack((x[self.shapeFuncToNodeOrder], y[self.shapeFuncToNodeOrder], z[self.shapeFuncToNodeOrder])).T\n</code></pre>"},{"location":"Elements/Line1D/","title":"1D Line Element","text":"<p>               Bases: <code>Element</code></p> <p>An abitrary order 1d line finite element</p> <p>The node ordering for the nth order line element looks like: ::</p> <pre><code>0 --- 2 --- 3 ... n-1 --- n --- 1\n</code></pre>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D--inherits-from","title":"Inherits from","text":"<p>Element : FEMpy.Elements.Element     The FEMpy element base class</p> Source code in <code>FEMpy/Elements/LineElement1D.py</code> <pre><code>class LineElement1D(Element):\n    \"\"\"An abitrary order 1d line finite element\n\n    The node ordering for the nth order line element looks like: ::\n\n        0 --- 2 --- 3 ... n-1 --- n --- 1\n\n    Inherits from\n    -------------\n    Element : FEMpy.Elements.Element\n        The FEMpy element base class\n    \"\"\"\n\n    def __init__(self, order=1, numStates=None, quadratureOrder=None):\n        \"\"\"Create a new 1d line element object\n\n        Parameters\n        ----------\n        order : int, optional\n            _description_, by default 1\n        numStates : _type_, optional\n            _description_, by default None\n        quadratureOrder : _type_, optional\n            _description_, by default None\n        \"\"\"\n        if order &lt; 1:\n            raise ValueError(\"Order must be greater than 0\")\n        self.order = order\n        numNodes = order + 1\n        if quadratureOrder is None:\n            # Compute quadrature order necessary to exactly intergrate polynomials of the same order as this element's\n            # shape functions\n            quadratureOrder = int(np.ceil((order + 1) / 2))\n\n        super().__init__(numNodes, numDim=1, quadratureOrder=quadratureOrder, numStates=numStates)\n\n        self.name = f\"Order{self.order}-LagrangeLine\"\n\n        self.shapeFuncToNodeOrder = self._getNodeReordering(self.order)\n\n    # ==============================================================================\n    # Public methods\n    # ==============================================================================\n    def computeShapeFunctions(self, paramCoords):\n        \"\"\"Compute the shape function values at a given set of parametric coordinates\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate shape functions at\n\n        Returns\n        -------\n        N: numPoint x numNodes array\n            Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape\n            function at the ith parametric point\n        \"\"\"\n        N = LP.LagrangePoly1d(paramCoords, self.order + 1)\n        return np.ascontiguousarray(N[:, self.shapeFuncToNodeOrder])\n\n    def computeShapeFunctionGradients(self, paramCoords):\n        \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates\n\n\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate shape function gradients at\n\n        Returns\n        -------\n        NGrad: numPoint x numDim x numNodes array\n            Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth\n            parametric coordinate\n        \"\"\"\n        NPrimeParam = np.zeros((paramCoords.shape[0], self.numDim, self.numNodes))\n        NPrimeParam[:, 0, :] = LP.LagrangePoly1dDeriv(paramCoords, self.order + 1)\n        return np.ascontiguousarray(NPrimeParam[:, :, self.shapeFuncToNodeOrder])\n\n    def getIntegrationPointWeights(self, order=None):\n        \"\"\"Compute the integration point weights for a given quadrature order on this element\n\n        Parameters\n        ----------\n        order : int\n            Integration order\n\n        Returns\n        -------\n        array of length numIntpoint\n            Integration point weights\n        \"\"\"\n        if order is None:\n            order = self.quadratureOrder\n        return getGaussQuadWeights(self.numDim, order)\n\n    def getIntegrationPointCoords(self, order=None):\n        \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element\n\n        Parameters\n        ----------\n        order : int\n            Integration order\n\n        Returns\n        -------\n        numIntpoint x numDim array\n            Integration point coordinates\n        \"\"\"\n        if order is None:\n            order = self.quadratureOrder\n        return getGaussQuadPoints(self.numDim, order)\n\n    def getReferenceElementCoordinates(self):\n        \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined\n\n        For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering\n\n        Returns\n        -------\n        numNodes x numDim array\n            Element node coordinates\n        \"\"\"\n        x = np.atleast_2d(np.linspace(-1, 1, self.numNodes)).T\n        return x[self.shapeFuncToNodeOrder]\n\n    # ==============================================================================\n    # Private methods\n    # ==============================================================================\n\n    @staticmethod\n    def _getNodeReordering(order):\n        \"\"\"Compute the reordering required between shape functions and nodes\n\n        The 1d lagrange polynomial shape functions are ordered left to right, but the node ordering is defined\n        differently, (e.g for a four node element it is 0-2-3-1). This method computes the reordering required to map\n        the shape functions to the correct node ordering.\n\n        Parameters\n        ----------\n        order : int\n            Line element order\n\n        Returns\n        -------\n        np.array\n            Reordering array, array[i] = j indicates that the ith shape function should be reordered to the jth node\n        \"\"\"\n        ordering = np.arange(order + 1)\n        ordering[-1] = 1\n        ordering[1:-1] += 1\n        return ordering\n</code></pre>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.__init__","title":"<code>__init__(order=1, numStates=None, quadratureOrder=None)</code>","text":"<p>Create a new 1d line element object</p>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.__init__--parameters","title":"Parameters","text":"<p>order : int, optional     description, by default 1 numStates : type, optional     description, by default None quadratureOrder : type, optional     description, by default None</p> Source code in <code>FEMpy/Elements/LineElement1D.py</code> <pre><code>def __init__(self, order=1, numStates=None, quadratureOrder=None):\n    \"\"\"Create a new 1d line element object\n\n    Parameters\n    ----------\n    order : int, optional\n        _description_, by default 1\n    numStates : _type_, optional\n        _description_, by default None\n    quadratureOrder : _type_, optional\n        _description_, by default None\n    \"\"\"\n    if order &lt; 1:\n        raise ValueError(\"Order must be greater than 0\")\n    self.order = order\n    numNodes = order + 1\n    if quadratureOrder is None:\n        # Compute quadrature order necessary to exactly intergrate polynomials of the same order as this element's\n        # shape functions\n        quadratureOrder = int(np.ceil((order + 1) / 2))\n\n    super().__init__(numNodes, numDim=1, quadratureOrder=quadratureOrder, numStates=numStates)\n\n    self.name = f\"Order{self.order}-LagrangeLine\"\n\n    self.shapeFuncToNodeOrder = self._getNodeReordering(self.order)\n</code></pre>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.computeShapeFunctionGradients","title":"<code>computeShapeFunctionGradients(paramCoords)</code>","text":"<p>Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates</p>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.computeShapeFunctionGradients--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to evaluate shape function gradients at</p>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.computeShapeFunctionGradients--returns","title":"Returns","text":"<p>NGrad: numPoint x numDim x numNodes array     Shape function gradient values, NGradi[k] is the value of the kth shape function at the ith point w.r.t the kth     parametric coordinate</p> Source code in <code>FEMpy/Elements/LineElement1D.py</code> <pre><code>def computeShapeFunctionGradients(self, paramCoords):\n    \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates\n\n\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to evaluate shape function gradients at\n\n    Returns\n    -------\n    NGrad: numPoint x numDim x numNodes array\n        Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth\n        parametric coordinate\n    \"\"\"\n    NPrimeParam = np.zeros((paramCoords.shape[0], self.numDim, self.numNodes))\n    NPrimeParam[:, 0, :] = LP.LagrangePoly1dDeriv(paramCoords, self.order + 1)\n    return np.ascontiguousarray(NPrimeParam[:, :, self.shapeFuncToNodeOrder])\n</code></pre>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.computeShapeFunctions","title":"<code>computeShapeFunctions(paramCoords)</code>","text":"<p>Compute the shape function values at a given set of parametric coordinates</p>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.computeShapeFunctions--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to evaluate shape functions at</p>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.computeShapeFunctions--returns","title":"Returns","text":"<p>N: numPoint x numNodes array     Array of shape function values at the given parametric coordinates, Ni is the value of the jth shape     function at the ith parametric point</p> Source code in <code>FEMpy/Elements/LineElement1D.py</code> <pre><code>def computeShapeFunctions(self, paramCoords):\n    \"\"\"Compute the shape function values at a given set of parametric coordinates\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to evaluate shape functions at\n\n    Returns\n    -------\n    N: numPoint x numNodes array\n        Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape\n        function at the ith parametric point\n    \"\"\"\n    N = LP.LagrangePoly1d(paramCoords, self.order + 1)\n    return np.ascontiguousarray(N[:, self.shapeFuncToNodeOrder])\n</code></pre>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.getIntegrationPointCoords","title":"<code>getIntegrationPointCoords(order=None)</code>","text":"<p>Compute the integration point parameteric coordinates for a given quadrature order on this element</p>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.getIntegrationPointCoords--parameters","title":"Parameters","text":"<p>order : int     Integration order</p>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.getIntegrationPointCoords--returns","title":"Returns","text":"<p>numIntpoint x numDim array     Integration point coordinates</p> Source code in <code>FEMpy/Elements/LineElement1D.py</code> <pre><code>def getIntegrationPointCoords(self, order=None):\n    \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element\n\n    Parameters\n    ----------\n    order : int\n        Integration order\n\n    Returns\n    -------\n    numIntpoint x numDim array\n        Integration point coordinates\n    \"\"\"\n    if order is None:\n        order = self.quadratureOrder\n    return getGaussQuadPoints(self.numDim, order)\n</code></pre>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.getIntegrationPointWeights","title":"<code>getIntegrationPointWeights(order=None)</code>","text":"<p>Compute the integration point weights for a given quadrature order on this element</p>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.getIntegrationPointWeights--parameters","title":"Parameters","text":"<p>order : int     Integration order</p>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.getIntegrationPointWeights--returns","title":"Returns","text":"<p>array of length numIntpoint     Integration point weights</p> Source code in <code>FEMpy/Elements/LineElement1D.py</code> <pre><code>def getIntegrationPointWeights(self, order=None):\n    \"\"\"Compute the integration point weights for a given quadrature order on this element\n\n    Parameters\n    ----------\n    order : int\n        Integration order\n\n    Returns\n    -------\n    array of length numIntpoint\n        Integration point weights\n    \"\"\"\n    if order is None:\n        order = self.quadratureOrder\n    return getGaussQuadWeights(self.numDim, order)\n</code></pre>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.getReferenceElementCoordinates","title":"<code>getReferenceElementCoordinates()</code>","text":"<p>Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined</p> <p>For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering</p>"},{"location":"Elements/Line1D/#FEMpy.Elements.LineElement1D.LineElement1D.getReferenceElementCoordinates--returns","title":"Returns","text":"<p>numNodes x numDim array     Element node coordinates</p> Source code in <code>FEMpy/Elements/LineElement1D.py</code> <pre><code>def getReferenceElementCoordinates(self):\n    \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined\n\n    For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering\n\n    Returns\n    -------\n    numNodes x numDim array\n        Element node coordinates\n    \"\"\"\n    x = np.atleast_2d(np.linspace(-1, 1, self.numNodes)).T\n    return x[self.shapeFuncToNodeOrder]\n</code></pre>"},{"location":"Elements/Quad2D/","title":"2D Quad Element","text":"<p>               Bases: <code>Element</code></p> <p>An \"arbitrary order\" 2d quadrilateral finite element</p> <p>Arbitrary order is in quotes at the moment because although the shape functions can in theory be computed for an arbitrary with the current LagrangePoly implementation, I have not figured out how to element the node reordering required to reorder the shape functions into the node ordering used by MeshIO yet for anything more than 3<sup>rd</sup> order elements.</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D--inherits-from","title":"Inherits from","text":"<p>Element : FEMpy.Elements.Element     The FEMpy element base class</p> Source code in <code>FEMpy/Elements/QuadElement2D.py</code> <pre><code>class QuadElement2D(Element):\n    \"\"\"An \"arbitrary order\" 2d quadrilateral finite element\n\n    Arbitrary order is in quotes at the moment because although the shape functions can in theory be computed for an\n    arbitrary with the current LagrangePoly implementation, I have not figured out how to element the node reordering\n    required to reorder the shape functions into the node ordering used by MeshIO yet for anything more than 3rd order\n    elements.\n\n    Inherits from\n    -------------\n    Element : FEMpy.Elements.Element\n        The FEMpy element base class\n    \"\"\"\n\n    def __init__(self, order=1, numStates=None, quadratureOrder=None):\n        \"\"\"Create a new 2d quadrilateral finite element object\n\n        Parameters\n        ----------\n        order : int, optional\n            Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are\n            supported, by default 1\n        numStates : int, optional\n            Number of states in the underlying PDE, by default 2\n        quadratureOrder : int, optional\n            Quadrature order to use for numerical integration, by default None, in which case a valid order for the\n            chosen element order is used\n\n        Raises\n        ------\n        ValueError\n            Raises error if order is not 1, 2 or 3\n        \"\"\"\n        if order not in [1, 2, 3]:\n            raise ValueError(\"Quad elements only support orders 1, 2 and 3\")\n        self.order = order\n        numNodes = (order + 1) ** 2\n        if quadratureOrder is None:\n            shapeFuncOrder = 2 * order\n            quadratureOrder = int(np.ceil((shapeFuncOrder + 1) / 2))\n        super().__init__(numNodes, numDim=2, quadratureOrder=quadratureOrder, numStates=numStates)\n\n        self.name = f\"Order{self.order}-LagrangeQuad\"\n\n        self.shapeFuncToNodeOrder = self._getNodeReordering(self.order)\n\n    # ==============================================================================\n    # Public methods\n    # ==============================================================================\n\n    def computeShapeFunctions(self, paramCoords):\n        \"\"\"Compute the shape function values at a given set of parametric coordinates\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate shape functions at\n\n        Returns\n        -------\n        N: numPoint x numNodes array\n            Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point\n        \"\"\"\n        N = LP.LagrangePoly2d(paramCoords[:, 0], paramCoords[:, 1], self.order + 1)\n        return np.ascontiguousarray(N[:, self.shapeFuncToNodeOrder])\n\n    def computeShapeFunctionGradients(self, paramCoords):\n        \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates\n\n\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate shape function gradients at\n\n        Returns\n        -------\n        NGrad: numPoint x numDim x numNodes array\n            Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth\n            parametric coordinate\n        \"\"\"\n        NPrimeParam = LP.LagrangePoly2dDeriv(paramCoords[:, 0], paramCoords[:, 1], self.order + 1)\n        return np.ascontiguousarray(NPrimeParam[:, :, self.shapeFuncToNodeOrder])\n\n    def getIntegrationPointWeights(self, order=None):\n        \"\"\"Compute the integration point weights for a given quadrature order on this element\n\n        Parameters\n        ----------\n        order : int\n            Integration order\n\n        Returns\n        -------\n        array of length numIntpoint\n            Integration point weights\n        \"\"\"\n        if order is None:\n            order = self.quadratureOrder\n        return getGaussQuadWeights(self.numDim, order)\n\n    def getIntegrationPointCoords(self, order=None):\n        \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element\n\n        Parameters\n        ----------\n        order : int\n            Integration order\n\n        Returns\n        -------\n        numIntpoint x numDim array\n            Integration point coordinates\n        \"\"\"\n        if order is None:\n            order = self.quadratureOrder\n        return getGaussQuadPoints(self.numDim, order)\n\n    def getReferenceElementCoordinates(self):\n        \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined\n\n        For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering\n\n        Returns\n        -------\n        numNodes x numDim array\n            Element node coordinates\n        \"\"\"\n        x = np.tile(np.linspace(-1, 1, self.order + 1), self.order + 1)\n        y = np.repeat(np.linspace(-1, 1, self.order + 1), self.order + 1)\n        return np.vstack((x[self.shapeFuncToNodeOrder], y[self.shapeFuncToNodeOrder])).T\n\n    # ==============================================================================\n    # Private methods\n    # ==============================================================================\n\n    @staticmethod\n    def _getNodeReordering(order):\n        \"\"\"Compute the reordering required between shape functions and nodes\n\n        The 2d lagrange polynomial shape functions are ordered left to right, bottom to top, but the node ordering is defined differently, (e.g for a four node element it is bottom left, bottom right, top left, top right). This method computes the reordering required to map the shape functions to the correct node ordering. As of now I have simply manually implemented this for the first few orders, but it should be possible to compute this for any order with some sort of recursion.\n\n        Parameters\n        ----------\n        order : int\n            Quad element order\n\n        Returns\n        -------\n        np.array\n            Reordering array, array[i] = j indicates that the ith shape function should be reordered to the jth node\n        \"\"\"\n        if order == 1:\n            return np.array([0, 1, 3, 2])\n        if order == 2:\n            return np.array([0, 2, 8, 6, 1, 5, 7, 3, 4])\n        if order == 3:\n            return np.array([0, 3, 15, 12, 1, 2, 7, 11, 14, 13, 8, 4, 5, 6, 10, 9])\n</code></pre>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.__init__","title":"<code>__init__(order=1, numStates=None, quadratureOrder=None)</code>","text":"<p>Create a new 2d quadrilateral finite element object</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.__init__--parameters","title":"Parameters","text":"<p>order : int, optional     Element order, a first order quad has 4 nodes, 2<sup>nd</sup> order 9, 3<sup>rd</sup> order 16 etc, currently only orders 1-3 are     supported, by default 1 numStates : int, optional     Number of states in the underlying PDE, by default 2 quadratureOrder : int, optional     Quadrature order to use for numerical integration, by default None, in which case a valid order for the     chosen element order is used</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.__init__--raises","title":"Raises","text":"<p>ValueError     Raises error if order is not 1, 2 or 3</p> Source code in <code>FEMpy/Elements/QuadElement2D.py</code> <pre><code>def __init__(self, order=1, numStates=None, quadratureOrder=None):\n    \"\"\"Create a new 2d quadrilateral finite element object\n\n    Parameters\n    ----------\n    order : int, optional\n        Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are\n        supported, by default 1\n    numStates : int, optional\n        Number of states in the underlying PDE, by default 2\n    quadratureOrder : int, optional\n        Quadrature order to use for numerical integration, by default None, in which case a valid order for the\n        chosen element order is used\n\n    Raises\n    ------\n    ValueError\n        Raises error if order is not 1, 2 or 3\n    \"\"\"\n    if order not in [1, 2, 3]:\n        raise ValueError(\"Quad elements only support orders 1, 2 and 3\")\n    self.order = order\n    numNodes = (order + 1) ** 2\n    if quadratureOrder is None:\n        shapeFuncOrder = 2 * order\n        quadratureOrder = int(np.ceil((shapeFuncOrder + 1) / 2))\n    super().__init__(numNodes, numDim=2, quadratureOrder=quadratureOrder, numStates=numStates)\n\n    self.name = f\"Order{self.order}-LagrangeQuad\"\n\n    self.shapeFuncToNodeOrder = self._getNodeReordering(self.order)\n</code></pre>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.computeShapeFunctionGradients","title":"<code>computeShapeFunctionGradients(paramCoords)</code>","text":"<p>Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.computeShapeFunctionGradients--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to evaluate shape function gradients at</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.computeShapeFunctionGradients--returns","title":"Returns","text":"<p>NGrad: numPoint x numDim x numNodes array     Shape function gradient values, NGradi[k] is the value of the kth shape function at the ith point w.r.t the kth     parametric coordinate</p> Source code in <code>FEMpy/Elements/QuadElement2D.py</code> <pre><code>def computeShapeFunctionGradients(self, paramCoords):\n    \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates\n\n\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to evaluate shape function gradients at\n\n    Returns\n    -------\n    NGrad: numPoint x numDim x numNodes array\n        Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth\n        parametric coordinate\n    \"\"\"\n    NPrimeParam = LP.LagrangePoly2dDeriv(paramCoords[:, 0], paramCoords[:, 1], self.order + 1)\n    return np.ascontiguousarray(NPrimeParam[:, :, self.shapeFuncToNodeOrder])\n</code></pre>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.computeShapeFunctions","title":"<code>computeShapeFunctions(paramCoords)</code>","text":"<p>Compute the shape function values at a given set of parametric coordinates</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.computeShapeFunctions--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to evaluate shape functions at</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.computeShapeFunctions--returns","title":"Returns","text":"<p>N: numPoint x numNodes array     Array of shape function values at the given parametric coordinates, Ni is the value of the jth shape function at the ith parametric point</p> Source code in <code>FEMpy/Elements/QuadElement2D.py</code> <pre><code>def computeShapeFunctions(self, paramCoords):\n    \"\"\"Compute the shape function values at a given set of parametric coordinates\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to evaluate shape functions at\n\n    Returns\n    -------\n    N: numPoint x numNodes array\n        Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point\n    \"\"\"\n    N = LP.LagrangePoly2d(paramCoords[:, 0], paramCoords[:, 1], self.order + 1)\n    return np.ascontiguousarray(N[:, self.shapeFuncToNodeOrder])\n</code></pre>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getIntegrationPointCoords","title":"<code>getIntegrationPointCoords(order=None)</code>","text":"<p>Compute the integration point parameteric coordinates for a given quadrature order on this element</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getIntegrationPointCoords--parameters","title":"Parameters","text":"<p>order : int     Integration order</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getIntegrationPointCoords--returns","title":"Returns","text":"<p>numIntpoint x numDim array     Integration point coordinates</p> Source code in <code>FEMpy/Elements/QuadElement2D.py</code> <pre><code>def getIntegrationPointCoords(self, order=None):\n    \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element\n\n    Parameters\n    ----------\n    order : int\n        Integration order\n\n    Returns\n    -------\n    numIntpoint x numDim array\n        Integration point coordinates\n    \"\"\"\n    if order is None:\n        order = self.quadratureOrder\n    return getGaussQuadPoints(self.numDim, order)\n</code></pre>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getIntegrationPointWeights","title":"<code>getIntegrationPointWeights(order=None)</code>","text":"<p>Compute the integration point weights for a given quadrature order on this element</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getIntegrationPointWeights--parameters","title":"Parameters","text":"<p>order : int     Integration order</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getIntegrationPointWeights--returns","title":"Returns","text":"<p>array of length numIntpoint     Integration point weights</p> Source code in <code>FEMpy/Elements/QuadElement2D.py</code> <pre><code>def getIntegrationPointWeights(self, order=None):\n    \"\"\"Compute the integration point weights for a given quadrature order on this element\n\n    Parameters\n    ----------\n    order : int\n        Integration order\n\n    Returns\n    -------\n    array of length numIntpoint\n        Integration point weights\n    \"\"\"\n    if order is None:\n        order = self.quadratureOrder\n    return getGaussQuadWeights(self.numDim, order)\n</code></pre>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getReferenceElementCoordinates","title":"<code>getReferenceElementCoordinates()</code>","text":"<p>Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined</p> <p>For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering</p>"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getReferenceElementCoordinates--returns","title":"Returns","text":"<p>numNodes x numDim array     Element node coordinates</p> Source code in <code>FEMpy/Elements/QuadElement2D.py</code> <pre><code>def getReferenceElementCoordinates(self):\n    \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined\n\n    For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering\n\n    Returns\n    -------\n    numNodes x numDim array\n        Element node coordinates\n    \"\"\"\n    x = np.tile(np.linspace(-1, 1, self.order + 1), self.order + 1)\n    y = np.repeat(np.linspace(-1, 1, self.order + 1), self.order + 1)\n    return np.vstack((x[self.shapeFuncToNodeOrder], y[self.shapeFuncToNodeOrder])).T\n</code></pre>"},{"location":"Elements/Tri2D/","title":"2D Triangle Element","text":"<p>               Bases: <code>Element</code></p> <p>An up-to-3<sup>rd</sup>-order 2d triangular element with 3, 6 or 10 nodes respectively.</p> <p>The node numbering follows the meshio conventions shown below:</p> <p>1<sup>st</sup> order element::</p> <pre><code>2\n|\\\n| \\\n|  \\\n|   \\\n|    \\\n0-----1\n</code></pre> <p>2<sup>nd</sup> order element::</p> <pre><code>2\n|\\\n| \\\n5  4\n|   \\\n|    \\\n0--3--1\n</code></pre> <p>3<sup>rd</sup> Order::</p> <pre><code>2\n|\\\n| \\\n7  6\n|   \\\n|    \\\n8  9  5\n|      \\\n|       \\\n0--3--4--1\n</code></pre> Source code in <code>FEMpy/Elements/TriElement2D.py</code> <pre><code>class TriElement2D(Element):\n    \"\"\"\n    An up-to-3rd-order 2d triangular element with 3, 6 or 10 nodes respectively.\n\n    The node numbering follows the meshio conventions shown below:\n\n    1st order element::\n\n        2\n        |\\\\\n        | \\\\\n        |  \\\\\n        |   \\\\\n        |    \\\\\n        0-----1\n\n    2nd order element::\n\n        2\n        |\\\\\n        | \\\\\n        5  4\n        |   \\\\\n        |    \\\\\n        0--3--1\n\n    3rd Order::\n\n        2\n        |\\\\\n        | \\\\\n        7  6\n        |   \\\\\n        |    \\\\\n        8  9  5\n        |      \\\\\n        |       \\\\\n        0--3--4--1\n\n    \"\"\"\n\n    def __init__(self, order=1, numStates=None, quadratureOrder=None):\n        \"\"\"Create a new 2d triangular finite element object\n\n        Parameters\n        ----------\n        order : int, optional\n            Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are\n            supported, by default 1\n        numStates : int, optional\n            Number of states in the underlying PDE, by default 2\n        quadratureOrder : int, optional\n            Quadrature order to use for numerical integration, by default None, in which case a valid order for the\n            chosen element order is used\n\n        Raises\n        ------\n        ValueError\n            Raises error if order is not 1, 2 or 3\n        \"\"\"\n        if order not in [1, 2, 3]:\n            raise ValueError(\"Triangular elements only support orders 1, 2 and 3\")\n        self.order = order\n        numNodes = (order + 1) * (order + 2) // 2\n        if quadratureOrder is None:\n            shapeFuncOrder = order\n            quadratureOrder = int(np.ceil((shapeFuncOrder + 1) / 2))\n\n        super().__init__(numNodes, numDim=2, quadratureOrder=quadratureOrder, numStates=numStates)\n\n        self.name = f\"Order{self.order}-LagrangeTri\"\n\n        # --- Define parametric coordinate bounds ---\n        self.paramCoordLowerBounds = -np.zeros(self.numDim)\n        self.paramCoordLinearConstaintMat = np.array([1.0, 1.0])\n        self.paramCoordLinearConstaintUpperBounds = 1.0\n        self.paramCoordLinearConstaintLowerBounds = -np.inf\n\n    def computeShapeFunctions(self, paramCoords):\n        \"\"\"Compute the shape function values at a given set of parametric coordinates\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate shape functions at\n\n        Returns\n        -------\n        N: numPoint x numNodes array\n            Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point\n        \"\"\"\n        return LP.LagrangePolyTri(paramCoords[:, 0], paramCoords[:, 1], self.order)\n\n    def computeShapeFunctionGradients(self, paramCoords):\n        \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates\n\n        Parameters\n        ----------\n        paramCoords : numPoint x numDim array\n            Array of parametric point coordinates to evaluate shape function gradients at\n\n        Returns\n        -------\n        NGrad: numPoint x numDim x numNodes array\n            Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth\n            parametric coordinate\n        \"\"\"\n        return LP.LagrangePolyTriDeriv(paramCoords[:, 0], paramCoords[:, 1], self.order)\n\n    def getIntegrationPointWeights(self, order=None):\n        \"\"\"Compute the integration point weights for a given quadrature order on this element\n\n        Parameters\n        ----------\n        order : int\n            Integration order\n\n        Returns\n        -------\n        array of length numIntpoint\n            Integration point weights\n        \"\"\"\n        if order is None:\n            order = self.quadratureOrder\n        return getTriQuadWeights(order)\n\n    def getIntegrationPointCoords(self, order=None):\n        \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element\n\n        Parameters\n        ----------\n        order : int\n            Integration order\n\n        Returns\n        -------\n        numIntpoint x numDim array\n            Integration point coordinates\n        \"\"\"\n        if order is None:\n            order = self.quadratureOrder\n        return getTriQuadPoints(order)\n\n    def getReferenceElementCoordinates(self):\n        \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined\n\n        Returns\n        -------\n        numNodes x numDim array\n            Element node coordinates\n        \"\"\"\n        if self.order == 1:\n            return np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]])\n        elif self.order == 2:\n            return np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [0.5, 0.0], [0.5, 0.5], [0.0, 0.5]])\n        elif self.order == 3:\n            return np.array(\n                [\n                    [0.0, 0.0],\n                    [1.0, 0.0],\n                    [0.0, 1.0],\n                    [1 / 3, 0.0],\n                    [2 / 3, 0.0],\n                    [2 / 3, 1 / 3],\n                    [1 / 3, 2 / 3],\n                    [0.0, 2 / 3],\n                    [0.0, 1 / 3],\n                    [1 / 3, 1 / 3],\n                ]\n            )\n\n    def getRandParamCoord(self, n, rng=None):\n        \"\"\"Generate a set of random parametric coordinates\n        For a tri element we need u and v in range [0,1] and u + v &lt;= 1, we can generate these points by generating\n        random points in a square on the domain [0,1] and then reflecting any points outside the triangle to the inside.\n        Parameters\n        ----------\n        n : int, optional\n            number of points to generate, by default 1\n        rng : numpy random Generator, optional\n            Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n            case a new one is created for this call\n\n        Returns\n        -------\n        paramCoords : n x numDim array\n            isoparametric coordinates, one row for each point\n        \"\"\"\n        if rng is None:\n            rng = np.random.default_rng()\n        coords = np.atleast_2d(rng.random((n, 2)))\n        for i in range(n):\n            coordSum = coords[i, 0] + coords[i, 1]\n            if coordSum &gt; 1:\n                coords[i] = 1 - coords[i]\n        return coords\n</code></pre>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.__init__","title":"<code>__init__(order=1, numStates=None, quadratureOrder=None)</code>","text":"<p>Create a new 2d triangular finite element object</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.__init__--parameters","title":"Parameters","text":"<p>order : int, optional     Element order, a first order quad has 4 nodes, 2<sup>nd</sup> order 9, 3<sup>rd</sup> order 16 etc, currently only orders 1-3 are     supported, by default 1 numStates : int, optional     Number of states in the underlying PDE, by default 2 quadratureOrder : int, optional     Quadrature order to use for numerical integration, by default None, in which case a valid order for the     chosen element order is used</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.__init__--raises","title":"Raises","text":"<p>ValueError     Raises error if order is not 1, 2 or 3</p> Source code in <code>FEMpy/Elements/TriElement2D.py</code> <pre><code>def __init__(self, order=1, numStates=None, quadratureOrder=None):\n    \"\"\"Create a new 2d triangular finite element object\n\n    Parameters\n    ----------\n    order : int, optional\n        Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are\n        supported, by default 1\n    numStates : int, optional\n        Number of states in the underlying PDE, by default 2\n    quadratureOrder : int, optional\n        Quadrature order to use for numerical integration, by default None, in which case a valid order for the\n        chosen element order is used\n\n    Raises\n    ------\n    ValueError\n        Raises error if order is not 1, 2 or 3\n    \"\"\"\n    if order not in [1, 2, 3]:\n        raise ValueError(\"Triangular elements only support orders 1, 2 and 3\")\n    self.order = order\n    numNodes = (order + 1) * (order + 2) // 2\n    if quadratureOrder is None:\n        shapeFuncOrder = order\n        quadratureOrder = int(np.ceil((shapeFuncOrder + 1) / 2))\n\n    super().__init__(numNodes, numDim=2, quadratureOrder=quadratureOrder, numStates=numStates)\n\n    self.name = f\"Order{self.order}-LagrangeTri\"\n\n    # --- Define parametric coordinate bounds ---\n    self.paramCoordLowerBounds = -np.zeros(self.numDim)\n    self.paramCoordLinearConstaintMat = np.array([1.0, 1.0])\n    self.paramCoordLinearConstaintUpperBounds = 1.0\n    self.paramCoordLinearConstaintLowerBounds = -np.inf\n</code></pre>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.computeShapeFunctionGradients","title":"<code>computeShapeFunctionGradients(paramCoords)</code>","text":"<p>Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.computeShapeFunctionGradients--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to evaluate shape function gradients at</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.computeShapeFunctionGradients--returns","title":"Returns","text":"<p>NGrad: numPoint x numDim x numNodes array     Shape function gradient values, NGradi[k] is the value of the kth shape function at the ith point w.r.t the kth     parametric coordinate</p> Source code in <code>FEMpy/Elements/TriElement2D.py</code> <pre><code>def computeShapeFunctionGradients(self, paramCoords):\n    \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to evaluate shape function gradients at\n\n    Returns\n    -------\n    NGrad: numPoint x numDim x numNodes array\n        Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth\n        parametric coordinate\n    \"\"\"\n    return LP.LagrangePolyTriDeriv(paramCoords[:, 0], paramCoords[:, 1], self.order)\n</code></pre>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.computeShapeFunctions","title":"<code>computeShapeFunctions(paramCoords)</code>","text":"<p>Compute the shape function values at a given set of parametric coordinates</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.computeShapeFunctions--parameters","title":"Parameters","text":"<p>paramCoords : numPoint x numDim array     Array of parametric point coordinates to evaluate shape functions at</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.computeShapeFunctions--returns","title":"Returns","text":"<p>N: numPoint x numNodes array     Array of shape function values at the given parametric coordinates, Ni is the value of the jth shape function at the ith parametric point</p> Source code in <code>FEMpy/Elements/TriElement2D.py</code> <pre><code>def computeShapeFunctions(self, paramCoords):\n    \"\"\"Compute the shape function values at a given set of parametric coordinates\n\n    Parameters\n    ----------\n    paramCoords : numPoint x numDim array\n        Array of parametric point coordinates to evaluate shape functions at\n\n    Returns\n    -------\n    N: numPoint x numNodes array\n        Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point\n    \"\"\"\n    return LP.LagrangePolyTri(paramCoords[:, 0], paramCoords[:, 1], self.order)\n</code></pre>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getIntegrationPointCoords","title":"<code>getIntegrationPointCoords(order=None)</code>","text":"<p>Compute the integration point parameteric coordinates for a given quadrature order on this element</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getIntegrationPointCoords--parameters","title":"Parameters","text":"<p>order : int     Integration order</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getIntegrationPointCoords--returns","title":"Returns","text":"<p>numIntpoint x numDim array     Integration point coordinates</p> Source code in <code>FEMpy/Elements/TriElement2D.py</code> <pre><code>def getIntegrationPointCoords(self, order=None):\n    \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element\n\n    Parameters\n    ----------\n    order : int\n        Integration order\n\n    Returns\n    -------\n    numIntpoint x numDim array\n        Integration point coordinates\n    \"\"\"\n    if order is None:\n        order = self.quadratureOrder\n    return getTriQuadPoints(order)\n</code></pre>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getIntegrationPointWeights","title":"<code>getIntegrationPointWeights(order=None)</code>","text":"<p>Compute the integration point weights for a given quadrature order on this element</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getIntegrationPointWeights--parameters","title":"Parameters","text":"<p>order : int     Integration order</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getIntegrationPointWeights--returns","title":"Returns","text":"<p>array of length numIntpoint     Integration point weights</p> Source code in <code>FEMpy/Elements/TriElement2D.py</code> <pre><code>def getIntegrationPointWeights(self, order=None):\n    \"\"\"Compute the integration point weights for a given quadrature order on this element\n\n    Parameters\n    ----------\n    order : int\n        Integration order\n\n    Returns\n    -------\n    array of length numIntpoint\n        Integration point weights\n    \"\"\"\n    if order is None:\n        order = self.quadratureOrder\n    return getTriQuadWeights(order)\n</code></pre>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getRandParamCoord","title":"<code>getRandParamCoord(n, rng=None)</code>","text":"<p>Generate a set of random parametric coordinates For a tri element we need u and v in range [0,1] and u + v &lt;= 1, we can generate these points by generating random points in a square on the domain [0,1] and then reflecting any points outside the triangle to the inside. Parameters</p> <p>n : int, optional     number of points to generate, by default 1 rng : numpy random Generator, optional     Random number generator to use, useful for creating consistent test behaviour, by default None, in which     case a new one is created for this call</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getRandParamCoord--returns","title":"Returns","text":"<p>paramCoords : n x numDim array     isoparametric coordinates, one row for each point</p> Source code in <code>FEMpy/Elements/TriElement2D.py</code> <pre><code>def getRandParamCoord(self, n, rng=None):\n    \"\"\"Generate a set of random parametric coordinates\n    For a tri element we need u and v in range [0,1] and u + v &lt;= 1, we can generate these points by generating\n    random points in a square on the domain [0,1] and then reflecting any points outside the triangle to the inside.\n    Parameters\n    ----------\n    n : int, optional\n        number of points to generate, by default 1\n    rng : numpy random Generator, optional\n        Random number generator to use, useful for creating consistent test behaviour, by default None, in which\n        case a new one is created for this call\n\n    Returns\n    -------\n    paramCoords : n x numDim array\n        isoparametric coordinates, one row for each point\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    coords = np.atleast_2d(rng.random((n, 2)))\n    for i in range(n):\n        coordSum = coords[i, 0] + coords[i, 1]\n        if coordSum &gt; 1:\n            coords[i] = 1 - coords[i]\n    return coords\n</code></pre>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getReferenceElementCoordinates","title":"<code>getReferenceElementCoordinates()</code>","text":"<p>Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined</p>"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getReferenceElementCoordinates--returns","title":"Returns","text":"<p>numNodes x numDim array     Element node coordinates</p> Source code in <code>FEMpy/Elements/TriElement2D.py</code> <pre><code>def getReferenceElementCoordinates(self):\n    \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined\n\n    Returns\n    -------\n    numNodes x numDim array\n        Element node coordinates\n    \"\"\"\n    if self.order == 1:\n        return np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]])\n    elif self.order == 2:\n        return np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [0.5, 0.0], [0.5, 0.5], [0.0, 0.5]])\n    elif self.order == 3:\n        return np.array(\n            [\n                [0.0, 0.0],\n                [1.0, 0.0],\n                [0.0, 1.0],\n                [1 / 3, 0.0],\n                [2 / 3, 0.0],\n                [2 / 3, 1 / 3],\n                [1 / 3, 2 / 3],\n                [0.0, 2 / 3],\n                [0.0, 1 / 3],\n                [1 / 3, 1 / 3],\n            ]\n        )\n</code></pre>"},{"location":"Theory/Theory/","title":"Finite Element Theory (or FEMpy's version of it at least)","text":""},{"location":"Theory/Theory/#isoparametric-elements","title":"Isoparametric Elements","text":"<p>In FEMpy, elements defining the mapping between the discrete and continuous. An element has a certain number of nodes which have coordinates in real space (reffered to as \\(\\vec{x}\\)), and at which the state, \\(u\\) is defined. Depending on the PDE being modelled, the state can be a scalar or a vector, (a single temperature value, or a 3-component displacement).</p>"}]}