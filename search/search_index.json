{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FEMpy FEMpy is my attempt to implement a basic object-oriented finite element method in python that's as fast and flexible as possible. FEMpy uses Numba JIT compilation extensively to perform fast, multithread operations over many elements at once. It uses scipy's sparse matrix implementation and can use the super-fast Paradiso solver from Intel's MKL to assemble and solve problems with 500,000 degrees of freedom in a few seconds. How to install Inside the FEMpy root directory run: pip install . Or, if you want to make changes to the code: pip install -e . To run unit tests. testflo -n 1 -v .","title":"Home"},{"location":"#fempy","text":"FEMpy is my attempt to implement a basic object-oriented finite element method in python that's as fast and flexible as possible. FEMpy uses Numba JIT compilation extensively to perform fast, multithread operations over many elements at once. It uses scipy's sparse matrix implementation and can use the super-fast Paradiso solver from Intel's MKL to assemble and solve problems with 500,000 degrees of freedom in a few seconds.","title":"FEMpy"},{"location":"#how-to-install","text":"Inside the FEMpy root directory run: pip install . Or, if you want to make changes to the code: pip install -e . To run unit tests. testflo -n 1 -v .","title":"How to install"},{"location":"ConstitutiveModels/ConstitutiveModel/","text":"Constitutive Model Base Class The base class for all FEMpy constitutive models The constitutive model defines the underlying PDE being solved. Currently, this base class is defined for solid mechanics problems, but in future it may be extended for other PDE types. It contains information on: The number of spatial dimensions the model is valid for The number and names of the PDE states The number and names of the stresses and strains for this model The number and names of the design variables associated with the PDE The names of functions which can be computed for this constitutive model (e.g mass, Von Mises stress etc) And contains methods to: Given the coordinates, state value, state gradient, and design variables at a point, compute: The strain components The sensitivities of the strain components The stress components The sensitivities of the stress components The pointwise mass The volume integral scaling parameter (e.g thickness for 2D plane models or \\(2 \\pi r\\) for 2D axisymmetric problems) The weak form residual The weak form residual Jacobian Other arbitrary output values (e.g failure criterion) Source code in FEMpy/Constitutive/ConstitutiveModel.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 class ConstitutiveModel : \"\"\"The base class for all FEMpy constitutive models The constitutive model defines the underlying PDE being solved. Currently, this base class is defined for solid mechanics problems, but in future it may be extended for other PDE types. It contains information on: - The number of spatial dimensions the model is valid for - The number and names of the PDE states - The number and names of the stresses and strains for this model - The number and names of the design variables associated with the PDE - The names of functions which can be computed for this constitutive model (e.g mass, Von Mises stress etc) And contains methods to: - Given the coordinates, state value, state gradient, and design variables at a point, compute: - The strain components - The sensitivities of the strain components - The stress components - The sensitivities of the stress components - The pointwise mass - The volume integral scaling parameter (e.g thickness for 2D plane models or $2 \\pi r$ for 2D axisymmetric problems) - The weak form residual - The weak form residual Jacobian - Other arbitrary output values (e.g failure criterion) \"\"\" def __init__ ( self , numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear = True ) -> None : \"\"\"_summary_ Parameters ---------- numDim : int Number of spatial dimensions the model is valid for stateNames : list of str Names for each state variable strainNames : list of str Names for each strain component stressNames : list of str Names for each stress component designVars : dict A nested dictionary of design variables, with the key being the name of the design variable and the value being a dictionary that contains various pieces of information about that DV, including: - \"defaultValue\" : The default value of that DV functionNames : list of str The names of functions that can be computed with this constitutive model linear : bool, optional Whether the constitutive model is linear or not, a.k.a whether the weak residual is a linear function of the states/state gradients, by default True \"\"\" self . numDim = numDim self . stateNames = stateNames self . numStates = len ( stateNames ) self . strainNames = strainNames self . numStrains = len ( strainNames ) if len ( stressNames ) != self . numStrains : raise ValueError ( \"Number of strains must equal number of stresses\" ) self . stressNames = stressNames self . designVariables = designVars self . numDesignVariables = len ( designVars ) self . functionNames = functionNames self . lowerCaseFuncNames = [ func . lower () for func in self . functionNames ] self . isLinear = linear # ============================================================================== # Abstract methods: To be implemented by derived classes # ============================================================================== @abc . abstractmethod def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStrains array Strain components at each point \"\"\" raise NotImplementedError @abc . abstractmethod def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" raise NotImplementedError @abc . abstractmethod def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStresses array Stress components at each point \"\"\" raise NotImplementedError @abc . abstractmethod def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" raise NotImplementedError @abc . abstractmethod def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one The volume scaling parameter is used to scale functions that are integrated over the element to get a true volume integral. For example, in a 2D plane stress model, we need to multiply by the thickness of the element to get a true volume integral. In a 2D axisymmetric model, we need to multiply by 2*pi*r to get a true volume integral. Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" raise NotImplementedError @abc . abstractmethod def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, `f(states, stateGradients, coords, dvs)`, where: - states is a numPoints x numStates array - stateGradients is a numPoints x numStates x numDim array - coords is a numPoints x numDim array - dvs is a dictionary of numPoints length arrays \"\"\" raise NotImplementedError # ============================================================================== # Public methods # ============================================================================== def computeWeakResiduals ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual integrand For a solid mechanics problem, the weak residual, derived from the virtual work principle is: $R = \\int r dV = \\int (du'/dq)^T (d\\epsilon/du')^T \\sigma \\\\theta d\\Omega$ Where: - $du'/dq$ is the sensitivity of the state gradient to the nodal state values, this is handled by the element - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient - $\\sigma$ are the stresses - $\\\\theta$ is the volume scaling parameter - $\\Omega$ is the element This function computes $(de/du')^T * \\sigma * \\\\theta$ at each point Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- residuals : numPoints x self.numDim x self.numStates array Weak residual integrand at each point \"\"\" numPoints = coords . shape [ 0 ] strain = self . computeStrains ( states , stateGradients , coords , dvs ) stress = self . computeStresses ( strain , dvs ) scale = self . computeVolumeScaling ( coords , dvs ) strainSens = self . computeStrainStateGradSens ( states , stateGradients , coords , dvs ) residuals = np . zeros (( numPoints , self . numDim , self . numStates )) _computeWeakResidualProduct ( strainSens , stress , scale , residuals ) return residuals # return np.einsum(\"pesd,pe,p->pds\", strainSens, stress, scale, optimize=[\"einsum_path\", (0, 1), (0, 1)]) def computeWeakResidualJacobian ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual jacobian integrand $j = (d\\epsilon/du')^T \\\\times d\\sigma/d\\epsilon \\\\times d\\epsilon/du'$ Where: - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient - $d\\sigma/d\\epsilon$ the sensitivity of the stress to the strain gradient This function computes `de/du'^T * sigma * scale` at each point Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- Jacobians : numPoints x numDim x numStates x numStates x numDim array The sensibility of the weak residual integrand components to the state gradients at each point \"\"\" strainSens = self . computeStrainStateGradSens ( states , stateGradients , coords , dvs ) strain = self . computeStrains ( states , stateGradients , coords , dvs ) stressSens = self . computeStressStrainSens ( strain , dvs ) scale = self . computeVolumeScaling ( coords , dvs ) numPoints = states . shape [ 0 ] # strainSens = strainSens.reshape(numPoints, self.numStrains, self.numStates * self.numDim) # Jacobian = _computeWeakJacobianProduct(strainSens, stressSens, scale) # points = p # strains = e # stress = o # states = s # dim = d # Jacobians = np.einsum( # \"posd,poe,peSD,p->pdsSD\", # strainSens, # stressSens, # strainSens, # scale, # optimize=[\"einsum_path\", (1, 3), (0, 2), (0, 1)], # ) Jacobians = np . zeros (( numPoints , self . numDim , self . numStates , self . numStates , self . numDim )) _computeWeakJacobianProduct ( strainSens , stressSens , scale , Jacobians ) return Jacobians designVariables = designVars instance-attribute functionNames = functionNames instance-attribute isLinear = linear instance-attribute lowerCaseFuncNames = [ func . lower () for func in self . functionNames ] instance-attribute numDesignVariables = len ( designVars ) instance-attribute numDim = numDim instance-attribute numStates = len ( stateNames ) instance-attribute numStrains = len ( strainNames ) instance-attribute stateNames = stateNames instance-attribute strainNames = strainNames instance-attribute stressNames = stressNames instance-attribute __init__ ( numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear = True ) summary Parameters: Name Type Description Default numDim int Number of spatial dimensions the model is valid for required stateNames list of str Names for each state variable required strainNames list of str Names for each strain component required stressNames list of str Names for each stress component required designVars dict A nested dictionary of design variables, with the key being the name of the design variable and the value being a dictionary that contains various pieces of information about that DV, including: - \"defaultValue\" : The default value of that DV required functionNames list of str The names of functions that can be computed with this constitutive model required linear bool , optional Whether the constitutive model is linear or not, a.k.a whether the weak residual is a linear function of the states/state gradients, by default True True Source code in FEMpy/Constitutive/ConstitutiveModel.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def __init__ ( self , numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear = True ) -> None : \"\"\"_summary_ Parameters ---------- numDim : int Number of spatial dimensions the model is valid for stateNames : list of str Names for each state variable strainNames : list of str Names for each strain component stressNames : list of str Names for each stress component designVars : dict A nested dictionary of design variables, with the key being the name of the design variable and the value being a dictionary that contains various pieces of information about that DV, including: - \"defaultValue\" : The default value of that DV functionNames : list of str The names of functions that can be computed with this constitutive model linear : bool, optional Whether the constitutive model is linear or not, a.k.a whether the weak residual is a linear function of the states/state gradients, by default True \"\"\" self . numDim = numDim self . stateNames = stateNames self . numStates = len ( stateNames ) self . strainNames = strainNames self . numStrains = len ( strainNames ) if len ( stressNames ) != self . numStrains : raise ValueError ( \"Number of strains must equal number of stresses\" ) self . stressNames = stressNames self . designVariables = designVars self . numDesignVariables = len ( designVars ) self . functionNames = functionNames self . lowerCaseFuncNames = [ func . lower () for func in self . functionNames ] self . isLinear = linear computeStrainStateGradSens ( states , stateGradients , coords , dvs ) abstractmethod Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Type Description numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/ConstitutiveModel.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @abc . abstractmethod def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" raise NotImplementedError computeStrains ( states , stateGradients , coords , dvs ) abstractmethod Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Type Description numPoints x numStrains array Strain components at each point Source code in FEMpy/Constitutive/ConstitutiveModel.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @abc . abstractmethod def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStrains array Strain components at each point \"\"\" raise NotImplementedError computeStressStrainSens ( strains , dvs ) abstractmethod Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Name Type Description sens numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/ConstitutiveModel.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 @abc . abstractmethod def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" raise NotImplementedError computeStresses ( strains , dvs ) abstractmethod Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Type Description numPoints x numStresses array Stress components at each point Source code in FEMpy/Constitutive/ConstitutiveModel.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 @abc . abstractmethod def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStresses array Stress components at each point \"\"\" raise NotImplementedError computeVolumeScaling ( coords , dvs ) abstractmethod Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one The volume scaling parameter is used to scale functions that are integrated over the element to get a true volume integral. For example, in a 2D plane stress model, we need to multiply by the thickness of the element to get a true volume integral. In a 2D axisymmetric model, we need to multiply by 2 pi r to get a true volume integral. Parameters: Name Type Description Default coords numPoints x numDim array Coordinates of each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Type Description numPoints length array Volume scaling parameter at each point Source code in FEMpy/Constitutive/ConstitutiveModel.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 @abc . abstractmethod def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one The volume scaling parameter is used to scale functions that are integrated over the element to get a true volume integral. For example, in a 2D plane stress model, we need to multiply by the thickness of the element to get a true volume integral. In a 2D axisymmetric model, we need to multiply by 2*pi*r to get a true volume integral. Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" raise NotImplementedError computeWeakResidualJacobian ( states , stateGradients , coords , dvs ) Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual jacobian integrand \\(j = (d\\epsilon/du')^T \\times d\\sigma/d\\epsilon \\times d\\epsilon/du'\\) Where: \\(d\\epsilon/du'\\) is the sensitivity of the strain to the state gradient \\(d\\sigma/d\\epsilon\\) the sensitivity of the stress to the strain gradient This function computes de/du'^T * sigma * scale at each point Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Name Type Description Jacobians numPoints x numDim x numStates x numStates x numDim array The sensibility of the weak residual integrand components to the state gradients at each point Source code in FEMpy/Constitutive/ConstitutiveModel.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def computeWeakResidualJacobian ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual jacobian integrand $j = (d\\epsilon/du')^T \\\\times d\\sigma/d\\epsilon \\\\times d\\epsilon/du'$ Where: - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient - $d\\sigma/d\\epsilon$ the sensitivity of the stress to the strain gradient This function computes `de/du'^T * sigma * scale` at each point Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- Jacobians : numPoints x numDim x numStates x numStates x numDim array The sensibility of the weak residual integrand components to the state gradients at each point \"\"\" strainSens = self . computeStrainStateGradSens ( states , stateGradients , coords , dvs ) strain = self . computeStrains ( states , stateGradients , coords , dvs ) stressSens = self . computeStressStrainSens ( strain , dvs ) scale = self . computeVolumeScaling ( coords , dvs ) numPoints = states . shape [ 0 ] # strainSens = strainSens.reshape(numPoints, self.numStrains, self.numStates * self.numDim) # Jacobian = _computeWeakJacobianProduct(strainSens, stressSens, scale) # points = p # strains = e # stress = o # states = s # dim = d # Jacobians = np.einsum( # \"posd,poe,peSD,p->pdsSD\", # strainSens, # stressSens, # strainSens, # scale, # optimize=[\"einsum_path\", (1, 3), (0, 2), (0, 1)], # ) Jacobians = np . zeros (( numPoints , self . numDim , self . numStates , self . numStates , self . numDim )) _computeWeakJacobianProduct ( strainSens , stressSens , scale , Jacobians ) return Jacobians computeWeakResiduals ( states , stateGradients , coords , dvs ) Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual integrand For a solid mechanics problem, the weak residual, derived from the virtual work principle is: \\(R = \\int r dV = \\int (du'/dq)^T (d\\epsilon/du')^T \\sigma \\theta d\\Omega\\) Where: \\(du'/dq\\) is the sensitivity of the state gradient to the nodal state values, this is handled by the element \\(d\\epsilon/du'\\) is the sensitivity of the strain to the state gradient \\(\\sigma\\) are the stresses \\(\\theta\\) is the volume scaling parameter \\(\\Omega\\) is the element This function computes \\((de/du')^T * \\sigma * \\theta\\) at each point Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Name Type Description residuals numPoints x self.numDim x self.numStates array Weak residual integrand at each point Source code in FEMpy/Constitutive/ConstitutiveModel.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def computeWeakResiduals ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual integrand For a solid mechanics problem, the weak residual, derived from the virtual work principle is: $R = \\int r dV = \\int (du'/dq)^T (d\\epsilon/du')^T \\sigma \\\\theta d\\Omega$ Where: - $du'/dq$ is the sensitivity of the state gradient to the nodal state values, this is handled by the element - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient - $\\sigma$ are the stresses - $\\\\theta$ is the volume scaling parameter - $\\Omega$ is the element This function computes $(de/du')^T * \\sigma * \\\\theta$ at each point Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- residuals : numPoints x self.numDim x self.numStates array Weak residual integrand at each point \"\"\" numPoints = coords . shape [ 0 ] strain = self . computeStrains ( states , stateGradients , coords , dvs ) stress = self . computeStresses ( strain , dvs ) scale = self . computeVolumeScaling ( coords , dvs ) strainSens = self . computeStrainStateGradSens ( states , stateGradients , coords , dvs ) residuals = np . zeros (( numPoints , self . numDim , self . numStates )) _computeWeakResidualProduct ( strainSens , stress , scale , residuals ) return residuals getFunction ( name ) abstractmethod Return a function that can be computed for this constitutive model Parameters: Name Type Description Default name str Name of the function to compute required Returns: Type Description callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) , where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays Source code in FEMpy/Constitutive/ConstitutiveModel.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 @abc . abstractmethod def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, `f(states, stateGradients, coords, dvs)`, where: - states is a numPoints x numStates array - stateGradients is a numPoints x numStates x numDim array - coords is a numPoints x numDim array - dvs is a dictionary of numPoints length arrays \"\"\" raise NotImplementedError","title":"Constitutive Model Base Class"},{"location":"ConstitutiveModels/ConstitutiveModel/#constitutive-model-base-class","text":"The base class for all FEMpy constitutive models The constitutive model defines the underlying PDE being solved. Currently, this base class is defined for solid mechanics problems, but in future it may be extended for other PDE types. It contains information on: The number of spatial dimensions the model is valid for The number and names of the PDE states The number and names of the stresses and strains for this model The number and names of the design variables associated with the PDE The names of functions which can be computed for this constitutive model (e.g mass, Von Mises stress etc) And contains methods to: Given the coordinates, state value, state gradient, and design variables at a point, compute: The strain components The sensitivities of the strain components The stress components The sensitivities of the stress components The pointwise mass The volume integral scaling parameter (e.g thickness for 2D plane models or \\(2 \\pi r\\) for 2D axisymmetric problems) The weak form residual The weak form residual Jacobian Other arbitrary output values (e.g failure criterion) Source code in FEMpy/Constitutive/ConstitutiveModel.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 class ConstitutiveModel : \"\"\"The base class for all FEMpy constitutive models The constitutive model defines the underlying PDE being solved. Currently, this base class is defined for solid mechanics problems, but in future it may be extended for other PDE types. It contains information on: - The number of spatial dimensions the model is valid for - The number and names of the PDE states - The number and names of the stresses and strains for this model - The number and names of the design variables associated with the PDE - The names of functions which can be computed for this constitutive model (e.g mass, Von Mises stress etc) And contains methods to: - Given the coordinates, state value, state gradient, and design variables at a point, compute: - The strain components - The sensitivities of the strain components - The stress components - The sensitivities of the stress components - The pointwise mass - The volume integral scaling parameter (e.g thickness for 2D plane models or $2 \\pi r$ for 2D axisymmetric problems) - The weak form residual - The weak form residual Jacobian - Other arbitrary output values (e.g failure criterion) \"\"\" def __init__ ( self , numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear = True ) -> None : \"\"\"_summary_ Parameters ---------- numDim : int Number of spatial dimensions the model is valid for stateNames : list of str Names for each state variable strainNames : list of str Names for each strain component stressNames : list of str Names for each stress component designVars : dict A nested dictionary of design variables, with the key being the name of the design variable and the value being a dictionary that contains various pieces of information about that DV, including: - \"defaultValue\" : The default value of that DV functionNames : list of str The names of functions that can be computed with this constitutive model linear : bool, optional Whether the constitutive model is linear or not, a.k.a whether the weak residual is a linear function of the states/state gradients, by default True \"\"\" self . numDim = numDim self . stateNames = stateNames self . numStates = len ( stateNames ) self . strainNames = strainNames self . numStrains = len ( strainNames ) if len ( stressNames ) != self . numStrains : raise ValueError ( \"Number of strains must equal number of stresses\" ) self . stressNames = stressNames self . designVariables = designVars self . numDesignVariables = len ( designVars ) self . functionNames = functionNames self . lowerCaseFuncNames = [ func . lower () for func in self . functionNames ] self . isLinear = linear # ============================================================================== # Abstract methods: To be implemented by derived classes # ============================================================================== @abc . abstractmethod def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStrains array Strain components at each point \"\"\" raise NotImplementedError @abc . abstractmethod def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" raise NotImplementedError @abc . abstractmethod def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStresses array Stress components at each point \"\"\" raise NotImplementedError @abc . abstractmethod def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" raise NotImplementedError @abc . abstractmethod def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one The volume scaling parameter is used to scale functions that are integrated over the element to get a true volume integral. For example, in a 2D plane stress model, we need to multiply by the thickness of the element to get a true volume integral. In a 2D axisymmetric model, we need to multiply by 2*pi*r to get a true volume integral. Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" raise NotImplementedError @abc . abstractmethod def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, `f(states, stateGradients, coords, dvs)`, where: - states is a numPoints x numStates array - stateGradients is a numPoints x numStates x numDim array - coords is a numPoints x numDim array - dvs is a dictionary of numPoints length arrays \"\"\" raise NotImplementedError # ============================================================================== # Public methods # ============================================================================== def computeWeakResiduals ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual integrand For a solid mechanics problem, the weak residual, derived from the virtual work principle is: $R = \\int r dV = \\int (du'/dq)^T (d\\epsilon/du')^T \\sigma \\\\theta d\\Omega$ Where: - $du'/dq$ is the sensitivity of the state gradient to the nodal state values, this is handled by the element - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient - $\\sigma$ are the stresses - $\\\\theta$ is the volume scaling parameter - $\\Omega$ is the element This function computes $(de/du')^T * \\sigma * \\\\theta$ at each point Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- residuals : numPoints x self.numDim x self.numStates array Weak residual integrand at each point \"\"\" numPoints = coords . shape [ 0 ] strain = self . computeStrains ( states , stateGradients , coords , dvs ) stress = self . computeStresses ( strain , dvs ) scale = self . computeVolumeScaling ( coords , dvs ) strainSens = self . computeStrainStateGradSens ( states , stateGradients , coords , dvs ) residuals = np . zeros (( numPoints , self . numDim , self . numStates )) _computeWeakResidualProduct ( strainSens , stress , scale , residuals ) return residuals # return np.einsum(\"pesd,pe,p->pds\", strainSens, stress, scale, optimize=[\"einsum_path\", (0, 1), (0, 1)]) def computeWeakResidualJacobian ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual jacobian integrand $j = (d\\epsilon/du')^T \\\\times d\\sigma/d\\epsilon \\\\times d\\epsilon/du'$ Where: - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient - $d\\sigma/d\\epsilon$ the sensitivity of the stress to the strain gradient This function computes `de/du'^T * sigma * scale` at each point Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- Jacobians : numPoints x numDim x numStates x numStates x numDim array The sensibility of the weak residual integrand components to the state gradients at each point \"\"\" strainSens = self . computeStrainStateGradSens ( states , stateGradients , coords , dvs ) strain = self . computeStrains ( states , stateGradients , coords , dvs ) stressSens = self . computeStressStrainSens ( strain , dvs ) scale = self . computeVolumeScaling ( coords , dvs ) numPoints = states . shape [ 0 ] # strainSens = strainSens.reshape(numPoints, self.numStrains, self.numStates * self.numDim) # Jacobian = _computeWeakJacobianProduct(strainSens, stressSens, scale) # points = p # strains = e # stress = o # states = s # dim = d # Jacobians = np.einsum( # \"posd,poe,peSD,p->pdsSD\", # strainSens, # stressSens, # strainSens, # scale, # optimize=[\"einsum_path\", (1, 3), (0, 2), (0, 1)], # ) Jacobians = np . zeros (( numPoints , self . numDim , self . numStates , self . numStates , self . numDim )) _computeWeakJacobianProduct ( strainSens , stressSens , scale , Jacobians ) return Jacobians","title":"Constitutive Model Base Class"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.designVariables","text":"","title":"designVariables"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.functionNames","text":"","title":"functionNames"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.isLinear","text":"","title":"isLinear"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.lowerCaseFuncNames","text":"","title":"lowerCaseFuncNames"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.numDesignVariables","text":"","title":"numDesignVariables"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.numDim","text":"","title":"numDim"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.numStates","text":"","title":"numStates"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.numStrains","text":"","title":"numStrains"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.stateNames","text":"","title":"stateNames"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.strainNames","text":"","title":"strainNames"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.stressNames","text":"","title":"stressNames"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.__init__","text":"summary Parameters: Name Type Description Default numDim int Number of spatial dimensions the model is valid for required stateNames list of str Names for each state variable required strainNames list of str Names for each strain component required stressNames list of str Names for each stress component required designVars dict A nested dictionary of design variables, with the key being the name of the design variable and the value being a dictionary that contains various pieces of information about that DV, including: - \"defaultValue\" : The default value of that DV required functionNames list of str The names of functions that can be computed with this constitutive model required linear bool , optional Whether the constitutive model is linear or not, a.k.a whether the weak residual is a linear function of the states/state gradients, by default True True Source code in FEMpy/Constitutive/ConstitutiveModel.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def __init__ ( self , numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear = True ) -> None : \"\"\"_summary_ Parameters ---------- numDim : int Number of spatial dimensions the model is valid for stateNames : list of str Names for each state variable strainNames : list of str Names for each strain component stressNames : list of str Names for each stress component designVars : dict A nested dictionary of design variables, with the key being the name of the design variable and the value being a dictionary that contains various pieces of information about that DV, including: - \"defaultValue\" : The default value of that DV functionNames : list of str The names of functions that can be computed with this constitutive model linear : bool, optional Whether the constitutive model is linear or not, a.k.a whether the weak residual is a linear function of the states/state gradients, by default True \"\"\" self . numDim = numDim self . stateNames = stateNames self . numStates = len ( stateNames ) self . strainNames = strainNames self . numStrains = len ( strainNames ) if len ( stressNames ) != self . numStrains : raise ValueError ( \"Number of strains must equal number of stresses\" ) self . stressNames = stressNames self . designVariables = designVars self . numDesignVariables = len ( designVars ) self . functionNames = functionNames self . lowerCaseFuncNames = [ func . lower () for func in self . functionNames ] self . isLinear = linear","title":"__init__()"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStrainStateGradSens","text":"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Type Description numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/ConstitutiveModel.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @abc . abstractmethod def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" raise NotImplementedError","title":"computeStrainStateGradSens()"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStrains","text":"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Type Description numPoints x numStrains array Strain components at each point Source code in FEMpy/Constitutive/ConstitutiveModel.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @abc . abstractmethod def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStrains array Strain components at each point \"\"\" raise NotImplementedError","title":"computeStrains()"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStressStrainSens","text":"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Name Type Description sens numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/ConstitutiveModel.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 @abc . abstractmethod def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" raise NotImplementedError","title":"computeStressStrainSens()"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeStresses","text":"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Type Description numPoints x numStresses array Stress components at each point Source code in FEMpy/Constitutive/ConstitutiveModel.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 @abc . abstractmethod def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints x numStresses array Stress components at each point \"\"\" raise NotImplementedError","title":"computeStresses()"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeVolumeScaling","text":"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one The volume scaling parameter is used to scale functions that are integrated over the element to get a true volume integral. For example, in a 2D plane stress model, we need to multiply by the thickness of the element to get a true volume integral. In a 2D axisymmetric model, we need to multiply by 2 pi r to get a true volume integral. Parameters: Name Type Description Default coords numPoints x numDim array Coordinates of each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Type Description numPoints length array Volume scaling parameter at each point Source code in FEMpy/Constitutive/ConstitutiveModel.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 @abc . abstractmethod def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one The volume scaling parameter is used to scale functions that are integrated over the element to get a true volume integral. For example, in a 2D plane stress model, we need to multiply by the thickness of the element to get a true volume integral. In a 2D axisymmetric model, we need to multiply by 2*pi*r to get a true volume integral. Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" raise NotImplementedError","title":"computeVolumeScaling()"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeWeakResidualJacobian","text":"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual jacobian integrand \\(j = (d\\epsilon/du')^T \\times d\\sigma/d\\epsilon \\times d\\epsilon/du'\\) Where: \\(d\\epsilon/du'\\) is the sensitivity of the strain to the state gradient \\(d\\sigma/d\\epsilon\\) the sensitivity of the stress to the strain gradient This function computes de/du'^T * sigma * scale at each point Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Name Type Description Jacobians numPoints x numDim x numStates x numStates x numDim array The sensibility of the weak residual integrand components to the state gradients at each point Source code in FEMpy/Constitutive/ConstitutiveModel.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def computeWeakResidualJacobian ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual jacobian integrand $j = (d\\epsilon/du')^T \\\\times d\\sigma/d\\epsilon \\\\times d\\epsilon/du'$ Where: - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient - $d\\sigma/d\\epsilon$ the sensitivity of the stress to the strain gradient This function computes `de/du'^T * sigma * scale` at each point Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- Jacobians : numPoints x numDim x numStates x numStates x numDim array The sensibility of the weak residual integrand components to the state gradients at each point \"\"\" strainSens = self . computeStrainStateGradSens ( states , stateGradients , coords , dvs ) strain = self . computeStrains ( states , stateGradients , coords , dvs ) stressSens = self . computeStressStrainSens ( strain , dvs ) scale = self . computeVolumeScaling ( coords , dvs ) numPoints = states . shape [ 0 ] # strainSens = strainSens.reshape(numPoints, self.numStrains, self.numStates * self.numDim) # Jacobian = _computeWeakJacobianProduct(strainSens, stressSens, scale) # points = p # strains = e # stress = o # states = s # dim = d # Jacobians = np.einsum( # \"posd,poe,peSD,p->pdsSD\", # strainSens, # stressSens, # strainSens, # scale, # optimize=[\"einsum_path\", (1, 3), (0, 2), (0, 1)], # ) Jacobians = np . zeros (( numPoints , self . numDim , self . numStates , self . numStates , self . numDim )) _computeWeakJacobianProduct ( strainSens , stressSens , scale , Jacobians ) return Jacobians","title":"computeWeakResidualJacobian()"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.computeWeakResiduals","text":"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual integrand For a solid mechanics problem, the weak residual, derived from the virtual work principle is: \\(R = \\int r dV = \\int (du'/dq)^T (d\\epsilon/du')^T \\sigma \\theta d\\Omega\\) Where: \\(du'/dq\\) is the sensitivity of the state gradient to the nodal state values, this is handled by the element \\(d\\epsilon/du'\\) is the sensitivity of the strain to the state gradient \\(\\sigma\\) are the stresses \\(\\theta\\) is the volume scaling parameter \\(\\Omega\\) is the element This function computes \\((de/du')^T * \\sigma * \\theta\\) at each point Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs dictionary of len(numpoints) array design variable values at each point required Returns: Name Type Description residuals numPoints x self.numDim x self.numStates array Weak residual integrand at each point Source code in FEMpy/Constitutive/ConstitutiveModel.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def computeWeakResiduals ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the weak residual integrand For a solid mechanics problem, the weak residual, derived from the virtual work principle is: $R = \\int r dV = \\int (du'/dq)^T (d\\epsilon/du')^T \\sigma \\\\theta d\\Omega$ Where: - $du'/dq$ is the sensitivity of the state gradient to the nodal state values, this is handled by the element - $d\\epsilon/du'$ is the sensitivity of the strain to the state gradient - $\\sigma$ are the stresses - $\\\\theta$ is the volume scaling parameter - $\\Omega$ is the element This function computes $(de/du')^T * \\sigma * \\\\theta$ at each point Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : dictionary of len(numpoints) array design variable values at each point Returns ------- residuals : numPoints x self.numDim x self.numStates array Weak residual integrand at each point \"\"\" numPoints = coords . shape [ 0 ] strain = self . computeStrains ( states , stateGradients , coords , dvs ) stress = self . computeStresses ( strain , dvs ) scale = self . computeVolumeScaling ( coords , dvs ) strainSens = self . computeStrainStateGradSens ( states , stateGradients , coords , dvs ) residuals = np . zeros (( numPoints , self . numDim , self . numStates )) _computeWeakResidualProduct ( strainSens , stress , scale , residuals ) return residuals","title":"computeWeakResiduals()"},{"location":"ConstitutiveModels/ConstitutiveModel/#FEMpy.Constitutive.ConstitutiveModel.ConstitutiveModel.getFunction","text":"Return a function that can be computed for this constitutive model Parameters: Name Type Description Default name str Name of the function to compute required Returns: Type Description callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) , where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays Source code in FEMpy/Constitutive/ConstitutiveModel.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 @abc . abstractmethod def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, `f(states, stateGradients, coords, dvs)`, where: - states is a numPoints x numStates array - stateGradients is a numPoints x numStates x numDim array - coords is a numPoints x numDim array - dvs is a dictionary of numPoints length arrays \"\"\" raise NotImplementedError","title":"getFunction()"},{"location":"ConstitutiveModels/IsoPlaneStrain/","text":"Isotropic Plane Strain Bases: ConstitutiveModel A constitutive model for the 2D isotropic plane strain equations Inherits ConstitutiveModel : type The base class for FEMpy constitutive models Source code in FEMpy/Constitutive/IsoPlaneStrain.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 class IsoPlaneStrain ( ConstitutiveModel ): \"\"\"A constitutive model for the 2D isotropic plane strain equations Inherits ---------- ConstitutiveModel : _type_ The base class for FEMpy constitutive models \"\"\" def __init__ ( self , E , nu , rho , t , linear = True ): \"\"\"Create an isotropic plane stress constitutive model Parameters ---------- E : float Elastic Modulus nu : float Poisson's ratio rho : float Density t : float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model linear : bool, optional Whether to use the linear kinematic equations for strains, by default True \"\"\" # --- Design variables --- # This model has only one design variable, the thickness of the material designVars = {} designVars [ \"Thickness\" ] = { \"defaultValue\" : t } # --- States --- stateNames = [ \"X-Displacement\" , \"Y-Displacement\" ] # --- Strains --- strainNames = [ \"e_xx\" , \"e_yy\" , \"gamma_xy\" ] # --- Stresses --- stressNames = [ \"sigma_xx\" , \"sigma_yy\" , \"tau_xy\" ] # --- Functions --- functionNames = [ \"Mass\" , \"Von-Mises-Stress\" ] # --- Material properties --- self . E = E self . nu = nu self . rho = rho numDim = 2 super () . __init__ ( numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear ) def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains array Strain components at each point \"\"\" return strain2D ( UPrime = stateGradients , nonlinear = not self . isLinear ) def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return strain2DSens ( UPrime = stateGradients , nonlinear = not self . isLinear ) def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- numPoints x numStresses array Stress components at each point \"\"\" return isoPlaneStrainStress ( strains , E = self . E , nu = self . nu ) def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return isoPlaneStrainStressStrainSens ( strains , E = self . E , nu = self . nu ) def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" return dvs [ \"Thickness\" ] def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays \"\"\" lowerCaseFuncNames = [ func . lower () for func in self . functionNames ] if name . lower () not in self . lowerCaseFuncNames : raise ValueError ( f \" { name } is not a valid function name for this constitutive model, valid choices are { self . functionNames } \" ) if name . lower () == \"mass\" : def func ( states , stateGradients , coords , dvs ): return np . ones ( states . shape [ 0 ]) * self . rho if name . lower () == \"von-mises-stress\" : def func ( states , stateGradients , coords , dvs ): strains = self . computeStrains ( states , stateGradients , coords , dvs ) stresses = self . computeStresses ( strains , dvs ) return vonMises2DPlaneStrain ( stresses , self . nu ) return func E = E instance-attribute nu = nu instance-attribute rho = rho instance-attribute __init__ ( E , nu , rho , t , linear = True ) Create an isotropic plane stress constitutive model Parameters: Name Type Description Default E float Elastic Modulus required nu float Poisson's ratio required rho float Density required t float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model required linear bool , optional Whether to use the linear kinematic equations for strains, by default True True Source code in FEMpy/Constitutive/IsoPlaneStrain.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , E , nu , rho , t , linear = True ): \"\"\"Create an isotropic plane stress constitutive model Parameters ---------- E : float Elastic Modulus nu : float Poisson's ratio rho : float Density t : float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model linear : bool, optional Whether to use the linear kinematic equations for strains, by default True \"\"\" # --- Design variables --- # This model has only one design variable, the thickness of the material designVars = {} designVars [ \"Thickness\" ] = { \"defaultValue\" : t } # --- States --- stateNames = [ \"X-Displacement\" , \"Y-Displacement\" ] # --- Strains --- strainNames = [ \"e_xx\" , \"e_yy\" , \"gamma_xy\" ] # --- Stresses --- stressNames = [ \"sigma_xx\" , \"sigma_yy\" , \"tau_xy\" ] # --- Functions --- functionNames = [ \"Mass\" , \"Von-Mises-Stress\" ] # --- Material properties --- self . E = E self . nu = nu self . rho = rho numDim = 2 super () . __init__ ( numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear ) computeStrainStateGradSens ( states , stateGradients , coords , dvs ) Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/IsoPlaneStrain.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return strain2DSens ( UPrime = stateGradients , nonlinear = not self . isLinear ) computeStrains ( states , stateGradients , coords , dvs ) Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints x numStrains array Strain components at each point Source code in FEMpy/Constitutive/IsoPlaneStrain.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains array Strain components at each point \"\"\" return strain2D ( UPrime = stateGradients , nonlinear = not self . isLinear ) computeStressStrainSens ( strains , dvs ) Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs _type_ description required Returns: Name Type Description sens numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/IsoPlaneStrain.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return isoPlaneStrainStressStrainSens ( strains , E = self . E , nu = self . nu ) computeStresses ( strains , dvs ) Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs _type_ description required Returns: Type Description numPoints x numStresses array Stress components at each point Source code in FEMpy/Constitutive/IsoPlaneStrain.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- numPoints x numStresses array Stress components at each point \"\"\" return isoPlaneStrainStress ( strains , E = self . E , nu = self . nu ) computeVolumeScaling ( coords , dvs ) Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters: Name Type Description Default coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints length array Volume scaling parameter at each point Source code in FEMpy/Constitutive/IsoPlaneStrain.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" return dvs [ \"Thickness\" ] getFunction ( name ) Return a function that can be computed for this constitutive model Parameters: Name Type Description Default name str Name of the function to compute required Returns: Type Description callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays Source code in FEMpy/Constitutive/IsoPlaneStrain.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays \"\"\" lowerCaseFuncNames = [ func . lower () for func in self . functionNames ] if name . lower () not in self . lowerCaseFuncNames : raise ValueError ( f \" { name } is not a valid function name for this constitutive model, valid choices are { self . functionNames } \" ) if name . lower () == \"mass\" : def func ( states , stateGradients , coords , dvs ): return np . ones ( states . shape [ 0 ]) * self . rho if name . lower () == \"von-mises-stress\" : def func ( states , stateGradients , coords , dvs ): strains = self . computeStrains ( states , stateGradients , coords , dvs ) stresses = self . computeStresses ( strains , dvs ) return vonMises2DPlaneStrain ( stresses , self . nu ) return func","title":"Isotropic Plane Strain"},{"location":"ConstitutiveModels/IsoPlaneStrain/#isotropic-plane-strain","text":"Bases: ConstitutiveModel A constitutive model for the 2D isotropic plane strain equations","title":"Isotropic Plane Strain"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain--inherits","text":"ConstitutiveModel : type The base class for FEMpy constitutive models Source code in FEMpy/Constitutive/IsoPlaneStrain.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 class IsoPlaneStrain ( ConstitutiveModel ): \"\"\"A constitutive model for the 2D isotropic plane strain equations Inherits ---------- ConstitutiveModel : _type_ The base class for FEMpy constitutive models \"\"\" def __init__ ( self , E , nu , rho , t , linear = True ): \"\"\"Create an isotropic plane stress constitutive model Parameters ---------- E : float Elastic Modulus nu : float Poisson's ratio rho : float Density t : float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model linear : bool, optional Whether to use the linear kinematic equations for strains, by default True \"\"\" # --- Design variables --- # This model has only one design variable, the thickness of the material designVars = {} designVars [ \"Thickness\" ] = { \"defaultValue\" : t } # --- States --- stateNames = [ \"X-Displacement\" , \"Y-Displacement\" ] # --- Strains --- strainNames = [ \"e_xx\" , \"e_yy\" , \"gamma_xy\" ] # --- Stresses --- stressNames = [ \"sigma_xx\" , \"sigma_yy\" , \"tau_xy\" ] # --- Functions --- functionNames = [ \"Mass\" , \"Von-Mises-Stress\" ] # --- Material properties --- self . E = E self . nu = nu self . rho = rho numDim = 2 super () . __init__ ( numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear ) def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains array Strain components at each point \"\"\" return strain2D ( UPrime = stateGradients , nonlinear = not self . isLinear ) def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return strain2DSens ( UPrime = stateGradients , nonlinear = not self . isLinear ) def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- numPoints x numStresses array Stress components at each point \"\"\" return isoPlaneStrainStress ( strains , E = self . E , nu = self . nu ) def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return isoPlaneStrainStressStrainSens ( strains , E = self . E , nu = self . nu ) def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" return dvs [ \"Thickness\" ] def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays \"\"\" lowerCaseFuncNames = [ func . lower () for func in self . functionNames ] if name . lower () not in self . lowerCaseFuncNames : raise ValueError ( f \" { name } is not a valid function name for this constitutive model, valid choices are { self . functionNames } \" ) if name . lower () == \"mass\" : def func ( states , stateGradients , coords , dvs ): return np . ones ( states . shape [ 0 ]) * self . rho if name . lower () == \"von-mises-stress\" : def func ( states , stateGradients , coords , dvs ): strains = self . computeStrains ( states , stateGradients , coords , dvs ) stresses = self . computeStresses ( strains , dvs ) return vonMises2DPlaneStrain ( stresses , self . nu ) return func","title":"Inherits"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.E","text":"","title":"E"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.nu","text":"","title":"nu"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.rho","text":"","title":"rho"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.__init__","text":"Create an isotropic plane stress constitutive model Parameters: Name Type Description Default E float Elastic Modulus required nu float Poisson's ratio required rho float Density required t float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model required linear bool , optional Whether to use the linear kinematic equations for strains, by default True True Source code in FEMpy/Constitutive/IsoPlaneStrain.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , E , nu , rho , t , linear = True ): \"\"\"Create an isotropic plane stress constitutive model Parameters ---------- E : float Elastic Modulus nu : float Poisson's ratio rho : float Density t : float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model linear : bool, optional Whether to use the linear kinematic equations for strains, by default True \"\"\" # --- Design variables --- # This model has only one design variable, the thickness of the material designVars = {} designVars [ \"Thickness\" ] = { \"defaultValue\" : t } # --- States --- stateNames = [ \"X-Displacement\" , \"Y-Displacement\" ] # --- Strains --- strainNames = [ \"e_xx\" , \"e_yy\" , \"gamma_xy\" ] # --- Stresses --- stressNames = [ \"sigma_xx\" , \"sigma_yy\" , \"tau_xy\" ] # --- Functions --- functionNames = [ \"Mass\" , \"Von-Mises-Stress\" ] # --- Material properties --- self . E = E self . nu = nu self . rho = rho numDim = 2 super () . __init__ ( numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear )","title":"__init__()"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStrainStateGradSens","text":"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/IsoPlaneStrain.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return strain2DSens ( UPrime = stateGradients , nonlinear = not self . isLinear )","title":"computeStrainStateGradSens()"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStrains","text":"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints x numStrains array Strain components at each point Source code in FEMpy/Constitutive/IsoPlaneStrain.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains array Strain components at each point \"\"\" return strain2D ( UPrime = stateGradients , nonlinear = not self . isLinear )","title":"computeStrains()"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStressStrainSens","text":"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs _type_ description required Returns: Name Type Description sens numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/IsoPlaneStrain.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return isoPlaneStrainStressStrainSens ( strains , E = self . E , nu = self . nu )","title":"computeStressStrainSens()"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeStresses","text":"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs _type_ description required Returns: Type Description numPoints x numStresses array Stress components at each point Source code in FEMpy/Constitutive/IsoPlaneStrain.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- numPoints x numStresses array Stress components at each point \"\"\" return isoPlaneStrainStress ( strains , E = self . E , nu = self . nu )","title":"computeStresses()"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.computeVolumeScaling","text":"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters: Name Type Description Default coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints length array Volume scaling parameter at each point Source code in FEMpy/Constitutive/IsoPlaneStrain.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" return dvs [ \"Thickness\" ]","title":"computeVolumeScaling()"},{"location":"ConstitutiveModels/IsoPlaneStrain/#FEMpy.Constitutive.IsoPlaneStrain.IsoPlaneStrain.getFunction","text":"Return a function that can be computed for this constitutive model Parameters: Name Type Description Default name str Name of the function to compute required Returns: Type Description callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays Source code in FEMpy/Constitutive/IsoPlaneStrain.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays \"\"\" lowerCaseFuncNames = [ func . lower () for func in self . functionNames ] if name . lower () not in self . lowerCaseFuncNames : raise ValueError ( f \" { name } is not a valid function name for this constitutive model, valid choices are { self . functionNames } \" ) if name . lower () == \"mass\" : def func ( states , stateGradients , coords , dvs ): return np . ones ( states . shape [ 0 ]) * self . rho if name . lower () == \"von-mises-stress\" : def func ( states , stateGradients , coords , dvs ): strains = self . computeStrains ( states , stateGradients , coords , dvs ) stresses = self . computeStresses ( strains , dvs ) return vonMises2DPlaneStrain ( stresses , self . nu ) return func","title":"getFunction()"},{"location":"ConstitutiveModels/IsoPlaneStress/","text":"Isotropic Plane Stress Bases: ConstitutiveModel A constitutive model for the 2D isotropic plane stress equations Inherits ConstitutiveModel : The base class for FEMpy constitutive models Source code in FEMpy/Constitutive/IsoPlaneStress.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 class IsoPlaneStress ( ConstitutiveModel ): \"\"\"A constitutive model for the 2D isotropic plane stress equations Inherits ---------- ConstitutiveModel : The base class for FEMpy constitutive models \"\"\" def __init__ ( self , E , nu , rho , t , linear = True ): \"\"\"Create an isotropic plane stress constitutive model Parameters ---------- E : float Elastic Modulus nu : float Poisson's ratio rho : float Density t : float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model linear : bool, optional Whether to use the linear kinematic equations for strains, by default True \"\"\" # --- Design variables --- # This model has only one design variable, the thickness of the material designVars = {} designVars [ \"Thickness\" ] = { \"defaultValue\" : t } # --- States --- stateNames = [ \"X-Displacement\" , \"Y-Displacement\" ] # --- Strains --- strainNames = [ \"e_xx\" , \"e_yy\" , \"gamma_xy\" ] # --- Stresses --- stressNames = [ \"sigma_xx\" , \"sigma_yy\" , \"tau_xy\" ] # --- Functions --- functionNames = [ \"Mass\" , \"Von-Mises-Stress\" ] # --- Material properties --- self . E = E self . nu = nu self . rho = rho numDim = 2 super () . __init__ ( numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear ) def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains array Strain components at each point \"\"\" return strain2D ( UPrime = stateGradients , nonlinear = not self . isLinear ) def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return strain2DSens ( UPrime = stateGradients , nonlinear = not self . isLinear ) def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- numPoints x numStresses array Stress components at each point \"\"\" return isoPlaneStressStress ( strains , E = self . E , nu = self . nu ) def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return isoPlaneStressStressStrainSens ( strains , E = self . E , nu = self . nu ) def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" return dvs [ \"Thickness\" ] def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays \"\"\" if name . lower () not in self . lowerCaseFuncNames : raise ValueError ( f \" { name } is not a valid function name for this constitutive model, valid choices are { self . functionNames } \" ) if name . lower () == \"mass\" : def func ( states , stateGradients , coords , dvs ): return np . ones ( states . shape [ 0 ]) * self . rho if name . lower () == \"von-mises-stress\" : def func ( states , stateGradients , coords , dvs ): strains = self . computeStrains ( states , stateGradients , coords , dvs ) stresses = self . computeStresses ( strains , dvs ) return vonMises2DPlaneStress ( stresses ) return func E = E instance-attribute nu = nu instance-attribute rho = rho instance-attribute __init__ ( E , nu , rho , t , linear = True ) Create an isotropic plane stress constitutive model Parameters: Name Type Description Default E float Elastic Modulus required nu float Poisson's ratio required rho float Density required t float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model required linear bool , optional Whether to use the linear kinematic equations for strains, by default True True Source code in FEMpy/Constitutive/IsoPlaneStress.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , E , nu , rho , t , linear = True ): \"\"\"Create an isotropic plane stress constitutive model Parameters ---------- E : float Elastic Modulus nu : float Poisson's ratio rho : float Density t : float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model linear : bool, optional Whether to use the linear kinematic equations for strains, by default True \"\"\" # --- Design variables --- # This model has only one design variable, the thickness of the material designVars = {} designVars [ \"Thickness\" ] = { \"defaultValue\" : t } # --- States --- stateNames = [ \"X-Displacement\" , \"Y-Displacement\" ] # --- Strains --- strainNames = [ \"e_xx\" , \"e_yy\" , \"gamma_xy\" ] # --- Stresses --- stressNames = [ \"sigma_xx\" , \"sigma_yy\" , \"tau_xy\" ] # --- Functions --- functionNames = [ \"Mass\" , \"Von-Mises-Stress\" ] # --- Material properties --- self . E = E self . nu = nu self . rho = rho numDim = 2 super () . __init__ ( numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear ) computeStrainStateGradSens ( states , stateGradients , coords , dvs ) Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/IsoPlaneStress.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return strain2DSens ( UPrime = stateGradients , nonlinear = not self . isLinear ) computeStrains ( states , stateGradients , coords , dvs ) Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints x numStrains array Strain components at each point Source code in FEMpy/Constitutive/IsoPlaneStress.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains array Strain components at each point \"\"\" return strain2D ( UPrime = stateGradients , nonlinear = not self . isLinear ) computeStressStrainSens ( strains , dvs ) Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs _type_ description required Returns: Name Type Description sens numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/IsoPlaneStress.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return isoPlaneStressStressStrainSens ( strains , E = self . E , nu = self . nu ) computeStresses ( strains , dvs ) Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs _type_ description required Returns: Type Description numPoints x numStresses array Stress components at each point Source code in FEMpy/Constitutive/IsoPlaneStress.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- numPoints x numStresses array Stress components at each point \"\"\" return isoPlaneStressStress ( strains , E = self . E , nu = self . nu ) computeVolumeScaling ( coords , dvs ) Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters: Name Type Description Default coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints length array Volume scaling parameter at each point Source code in FEMpy/Constitutive/IsoPlaneStress.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" return dvs [ \"Thickness\" ] getFunction ( name ) Return a function that can be computed for this constitutive model Parameters: Name Type Description Default name str Name of the function to compute required Returns: Type Description callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays Source code in FEMpy/Constitutive/IsoPlaneStress.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays \"\"\" if name . lower () not in self . lowerCaseFuncNames : raise ValueError ( f \" { name } is not a valid function name for this constitutive model, valid choices are { self . functionNames } \" ) if name . lower () == \"mass\" : def func ( states , stateGradients , coords , dvs ): return np . ones ( states . shape [ 0 ]) * self . rho if name . lower () == \"von-mises-stress\" : def func ( states , stateGradients , coords , dvs ): strains = self . computeStrains ( states , stateGradients , coords , dvs ) stresses = self . computeStresses ( strains , dvs ) return vonMises2DPlaneStress ( stresses ) return func","title":"Isotropic Plane Stress"},{"location":"ConstitutiveModels/IsoPlaneStress/#isotropic-plane-stress","text":"Bases: ConstitutiveModel A constitutive model for the 2D isotropic plane stress equations","title":"Isotropic Plane Stress"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress--inherits","text":"ConstitutiveModel : The base class for FEMpy constitutive models Source code in FEMpy/Constitutive/IsoPlaneStress.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 class IsoPlaneStress ( ConstitutiveModel ): \"\"\"A constitutive model for the 2D isotropic plane stress equations Inherits ---------- ConstitutiveModel : The base class for FEMpy constitutive models \"\"\" def __init__ ( self , E , nu , rho , t , linear = True ): \"\"\"Create an isotropic plane stress constitutive model Parameters ---------- E : float Elastic Modulus nu : float Poisson's ratio rho : float Density t : float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model linear : bool, optional Whether to use the linear kinematic equations for strains, by default True \"\"\" # --- Design variables --- # This model has only one design variable, the thickness of the material designVars = {} designVars [ \"Thickness\" ] = { \"defaultValue\" : t } # --- States --- stateNames = [ \"X-Displacement\" , \"Y-Displacement\" ] # --- Strains --- strainNames = [ \"e_xx\" , \"e_yy\" , \"gamma_xy\" ] # --- Stresses --- stressNames = [ \"sigma_xx\" , \"sigma_yy\" , \"tau_xy\" ] # --- Functions --- functionNames = [ \"Mass\" , \"Von-Mises-Stress\" ] # --- Material properties --- self . E = E self . nu = nu self . rho = rho numDim = 2 super () . __init__ ( numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear ) def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains array Strain components at each point \"\"\" return strain2D ( UPrime = stateGradients , nonlinear = not self . isLinear ) def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return strain2DSens ( UPrime = stateGradients , nonlinear = not self . isLinear ) def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- numPoints x numStresses array Stress components at each point \"\"\" return isoPlaneStressStress ( strains , E = self . E , nu = self . nu ) def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return isoPlaneStressStressStrainSens ( strains , E = self . E , nu = self . nu ) def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" return dvs [ \"Thickness\" ] def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays \"\"\" if name . lower () not in self . lowerCaseFuncNames : raise ValueError ( f \" { name } is not a valid function name for this constitutive model, valid choices are { self . functionNames } \" ) if name . lower () == \"mass\" : def func ( states , stateGradients , coords , dvs ): return np . ones ( states . shape [ 0 ]) * self . rho if name . lower () == \"von-mises-stress\" : def func ( states , stateGradients , coords , dvs ): strains = self . computeStrains ( states , stateGradients , coords , dvs ) stresses = self . computeStresses ( strains , dvs ) return vonMises2DPlaneStress ( stresses ) return func","title":"Inherits"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.E","text":"","title":"E"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.nu","text":"","title":"nu"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.rho","text":"","title":"rho"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.__init__","text":"Create an isotropic plane stress constitutive model Parameters: Name Type Description Default E float Elastic Modulus required nu float Poisson's ratio required rho float Density required t float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model required linear bool , optional Whether to use the linear kinematic equations for strains, by default True True Source code in FEMpy/Constitutive/IsoPlaneStress.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , E , nu , rho , t , linear = True ): \"\"\"Create an isotropic plane stress constitutive model Parameters ---------- E : float Elastic Modulus nu : float Poisson's ratio rho : float Density t : float Thickness, this will be used as the initial thickness value for all elements but can be changed later by calling setDesignVariables in the model linear : bool, optional Whether to use the linear kinematic equations for strains, by default True \"\"\" # --- Design variables --- # This model has only one design variable, the thickness of the material designVars = {} designVars [ \"Thickness\" ] = { \"defaultValue\" : t } # --- States --- stateNames = [ \"X-Displacement\" , \"Y-Displacement\" ] # --- Strains --- strainNames = [ \"e_xx\" , \"e_yy\" , \"gamma_xy\" ] # --- Stresses --- stressNames = [ \"sigma_xx\" , \"sigma_yy\" , \"tau_xy\" ] # --- Functions --- functionNames = [ \"Mass\" , \"Von-Mises-Stress\" ] # --- Material properties --- self . E = E self . nu = nu self . rho = rho numDim = 2 super () . __init__ ( numDim , stateNames , strainNames , stressNames , designVars , functionNames , linear )","title":"__init__()"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStrainStateGradSens","text":"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/IsoPlaneStress.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def computeStrainStateGradSens ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the sensitivity of the strains to the state gradient at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return strain2DSens ( UPrime = stateGradients , nonlinear = not self . isLinear )","title":"computeStrainStateGradSens()"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStrains","text":"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters: Name Type Description Default states numPoints x numStates array State values at each point required stateGradients numPoints x numStates x numDim array State gradients at each point required coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints x numStrains array Strain components at each point Source code in FEMpy/Constitutive/IsoPlaneStress.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def computeStrains ( self , states , stateGradients , coords , dvs ): \"\"\"Given the coordinates, state value, state gradient, and design variables at a bunch of points, compute the strains at each one Parameters ---------- states : numPoints x numStates array State values at each point stateGradients : numPoints x numStates x numDim array State gradients at each point coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints x numStrains array Strain components at each point \"\"\" return strain2D ( UPrime = stateGradients , nonlinear = not self . isLinear )","title":"computeStrains()"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStressStrainSens","text":"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs _type_ description required Returns: Name Type Description sens numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l Source code in FEMpy/Constitutive/IsoPlaneStress.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def computeStressStrainSens ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the sensitivity of the stresses to the strains at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- sens : numPoints x numStrains x numStates x numDim array Strain sensitivities, sens[i,j,k,l] is the sensitivity of strain component j at point i to state gradient du_k/dx_l \"\"\" return isoPlaneStressStressStrainSens ( strains , E = self . E , nu = self . nu )","title":"computeStressStrainSens()"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeStresses","text":"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters: Name Type Description Default strains numPoints x numStrains array Strain components at each point required dvs _type_ description required Returns: Type Description numPoints x numStresses array Stress components at each point Source code in FEMpy/Constitutive/IsoPlaneStress.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def computeStresses ( self , strains , dvs ): \"\"\"Given the strains and design variables at a bunch of points, compute the stresses at each one Parameters ---------- strains : numPoints x numStrains array Strain components at each point dvs : _type_ _description_ Returns ------- numPoints x numStresses array Stress components at each point \"\"\" return isoPlaneStressStress ( strains , E = self . E , nu = self . nu )","title":"computeStresses()"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.computeVolumeScaling","text":"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters: Name Type Description Default coords numPoints x numDim array Coordinates of each point required dvs _type_ description required Returns: Type Description numPoints length array Volume scaling parameter at each point Source code in FEMpy/Constitutive/IsoPlaneStress.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def computeVolumeScaling ( self , coords , dvs ): \"\"\"Given the coordinates and design variables at a bunch of points, compute the volume scaling parameter at each one For this 2D model, the volume scaling is just the thickness Parameters ---------- coords : numPoints x numDim array Coordinates of each point dvs : _type_ _description_ Returns ------- numPoints length array Volume scaling parameter at each point \"\"\" return dvs [ \"Thickness\" ]","title":"computeVolumeScaling()"},{"location":"ConstitutiveModels/IsoPlaneStress/#FEMpy.Constitutive.IsoPlaneStress.IsoPlaneStress.getFunction","text":"Return a function that can be computed for this constitutive model Parameters: Name Type Description Default name str Name of the function to compute required Returns: Type Description callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays Source code in FEMpy/Constitutive/IsoPlaneStress.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def getFunction ( self , name ): \"\"\"Return a function that can be computed for this constitutive model Parameters ---------- name : str Name of the function to compute Returns ------- callable A function that can be called to compute the desired function at a bunch of points with the signature, f(states, stateGradients, coords, dvs) where: states is a numPoints x numStates array stateGradients is a numPoints x numStates x numDim array coords is a numPoints x numDim array dvs is a dictionary of numPoints length arrays \"\"\" if name . lower () not in self . lowerCaseFuncNames : raise ValueError ( f \" { name } is not a valid function name for this constitutive model, valid choices are { self . functionNames } \" ) if name . lower () == \"mass\" : def func ( states , stateGradients , coords , dvs ): return np . ones ( states . shape [ 0 ]) * self . rho if name . lower () == \"von-mises-stress\" : def func ( states , stateGradients , coords , dvs ): strains = self . computeStrains ( states , stateGradients , coords , dvs ) stresses = self . computeStresses ( strains , dvs ) return vonMises2DPlaneStress ( stresses ) return func","title":"getFunction()"},{"location":"DevelopmentGuide/DevelopmentGuide/","text":"Contributors Guide Code formatting and Linting The following checks will be run on any PR using pre-commit before it can be merged into the main branch: Black code formatter, with 120 column line width and target python versions 3.8-3.10 Flake8 linter, using the MDO Lab's configuration file Interrogate docstring check check-yaml - checks yaml files for parseable syntax. check-json - checks json files for parseable syntax. check-added-large-files - prevents giant files from being committed. mixed-line-ending - replaces or checks mixed line ending. check-merge-conflict - checks for files that contain merge conflict strings. debug-statements - checks for debugger imports and py37+ breakpoint() calls in python source. If you want to contribute to FEMpy please install FEMpy in editable mode and setup the pre-commit hooks to ensure consistent code formatting. The full installation process is then: # Install FEMpy in editable mode pip install -e . [ dev ] # Download the MDO Lab's flake8 configuration wget https://raw.githubusercontent.com/mdolab/.github/master/.flake8 # Install the pre-commit hooks pre-commit install If the wget command doesn't work on your OS, simply download the file here and place it in the root directory of your FEMpy repository.","title":"Contributing"},{"location":"DevelopmentGuide/DevelopmentGuide/#contributors-guide","text":"","title":"Contributors Guide"},{"location":"DevelopmentGuide/DevelopmentGuide/#code-formatting-and-linting","text":"The following checks will be run on any PR using pre-commit before it can be merged into the main branch: Black code formatter, with 120 column line width and target python versions 3.8-3.10 Flake8 linter, using the MDO Lab's configuration file Interrogate docstring check check-yaml - checks yaml files for parseable syntax. check-json - checks json files for parseable syntax. check-added-large-files - prevents giant files from being committed. mixed-line-ending - replaces or checks mixed line ending. check-merge-conflict - checks for files that contain merge conflict strings. debug-statements - checks for debugger imports and py37+ breakpoint() calls in python source. If you want to contribute to FEMpy please install FEMpy in editable mode and setup the pre-commit hooks to ensure consistent code formatting. The full installation process is then: # Install FEMpy in editable mode pip install -e . [ dev ] # Download the MDO Lab's flake8 configuration wget https://raw.githubusercontent.com/mdolab/.github/master/.flake8 # Install the pre-commit hooks pre-commit install If the wget command doesn't work on your OS, simply download the file here and place it in the root directory of your FEMpy repository.","title":"Code formatting and Linting"},{"location":"Elements/Element/","text":"Element Base Class The base class from which all other elements are derived. Source code in FEMpy/Elements/Element.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 class Element : \"\"\"The base class from which all other elements are derived.\"\"\" def __init__ ( self , numNodes , numDim , quadratureOrder , numStates = None ): \"\"\"Instantiate an element object Parameters ---------- numNodes : int Number of nodes in the element numDim : int Number of spatial dimensions the element lives in quadratureOrder : int Integration quadrature order numStates : int, optional Number of states in the underlying PDE, a.k.a the number of DOF per node, by default uses numDim \"\"\" self . numNodes = numNodes self . numDim = numDim self . numStates = numStates if numStates is not None else numDim self . numDOF = self . numNodes * self . numStates self . quadratureOrder = quadratureOrder self . name = f \" { self . numNodes } Node- { self . numStates } Disp- { self . numDim } D-Element\" # --- Parametric coordinate bounds --- # By default it is assumed that the parametric coordinates are in the range [-1, 1] in each dimension, for # elements where this is not true (e.g a 2d triangular element), these attributes should be overwritten self . paramCoordLowerBounds = - np . ones ( self . numDim ) self . paramCoordUpperBounds = np . ones ( self . numDim ) self . paramCoordLinearConstaintMat = None self . paramCoordLinearConstaintUpperBounds = None self . paramCoordLinearConstaintLowerBounds = None # --- Define fast jacobian determinant function based on number of dimensions --- if self . numDim == 1 : self . jacDet = det1 self . jacInv = inv1 elif self . numDim == 2 : self . jacDet = det2 self . jacInv = inv2 elif self . numDim == 3 : self . jacDet = det3 self . jacInv = inv3 if self . numDim not in [ 1 , 2 , 3 ]: raise ValueError ( f \"Sorry, FEMpy doesn't support { self . numDim } -dimensional problems\" ) # ============================================================================== # Abstract methods: Must be implemented by derived classes # ============================================================================== @abc . abstractmethod def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" raise NotImplementedError @abc . abstractmethod def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NPrimeParam: numPoint x numDim x numNodes array Shape function gradient values, NPrimeParam[i][j][k] is the derivative of the kth shape function at the ith point w.r.t the jth parametric coordinate \"\"\" raise NotImplementedError @abc . abstractmethod def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int, optional Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" raise NotImplementedError @abc . abstractmethod def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int, optional Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" raise NotImplementedError @abc . abstractmethod def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns ------- numNodes x numDim array Element node coordinates \"\"\" raise NotImplementedError # ============================================================================== # Implemented methods # ============================================================================== def computeFunction ( self , nodeCoords , nodeStates , elementDVs , function , elementReductionType , intOrder = None ): \"\"\"Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element elementDVs : dict of numElement length arrays Design variable values for each element function : callable Function to evaluate at each point within each element, must have signature f(x, u, u', dvs), where: x is an n x numDim array of coordinates u is an n x numStates array of state values u' is an n x (numStates*numDim) array of state gradients dvs is an n x numDVs array of design variable values elementReductionType : _type_ Type of reduction to do to get a single value for each element, can be: - 'sum' : sum all values - 'mean' : average all values - `integrate` : integrate the function over the element - 'max' : take the maximum value - 'min' : take the minimum value - 'ksmax' : Compute a smooth approximation of the maximum value using KS aggregation - 'ksmin' : Compute a smooth approximation of the minimum value using KS aggregation Returns ------- values : numElements array Value of the function for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , elementDVs , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"DVs\" , \"JacDet\" ], ) values = function ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) values = values . reshape (( numElements , numIntPoints )) # perform element reduction if specified if elementReductionType is not None : assert elementReductionType . lower () in [ \"sum\" , \"mean\" , \"integrate\" , \"min\" , \"max\" , \"ksmax\" , \"ksmin\" , ], \"elementReductionType not valid\" # Simple numpy reductions if elementReductionType . lower () in [ \"sum\" , \"mean\" , \"min\" , \"max\" ]: if elementReductionType . lower () == \"sum\" : reductFunc = np . sum if elementReductionType . lower () == \"mean\" : reductFunc = np . average if elementReductionType . lower () == \"min\" : reductFunc = np . min if elementReductionType . lower () == \"max\" : reductFunc = np . max return reductFunc ( values , axis = 1 ) if elementReductionType . lower () == \"integrate\" : # compute integration using weighted sum of w*values*detJ over each set of element points pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) return np . einsum ( \"ep,ep,p->e\" , values , pointQuantities [ \"JacDet\" ], intPointWeights , optimize = [ \"einsum_path\" , ( 0 , 1 ), ( 0 , 1 )], ) if elementReductionType . lower () in [ \"ksmax\" , \"ksmin\" ]: reducedValues = np . zeros ( numElements ) for i in range ( numElements ): reducedValues [ i ] = ksAgg ( values [ i , :], \"max\" ) return reducedValues if elementReductionType . lower () == \"ksmin\" : reducedValues = np . zeros ( numElements ) for i in range ( numElements ): reducedValues [ i ] = ksAgg ( values [ i , :], \"min\" ) return reducedValues return values def _computeFunctionEvaluationQuantities ( self , paramCoords , nodeStates , nodeCoords , designVars , quantities ): \"\"\"Compute a series of values that are used for evaluating functions at multiple points over multiple elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate quantities at nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element designVars : dict of numElements arrays Design variable values for each element quantities : list of strings, optional List of quantities to compute, by default None are computed, valid quatities are: - \"N\" : Shape function values - \"NPrimeParam\" : Shape function gradients - \"Coord\" : True coordinates - \"State\" : State values - \"StateGrad\" : State gradients - \"DVs\" : Design variable values - \"Jac\" : Jacobian of the transformation from parametric to true coordinates - \"JacInv\" : Inverse of the Jacobian of the transformation from parametric to true coordinates - \"JacDet\" : Determinant of the Jacobian of the transformation from parametric to true coordinates - \"StateGradSens\" : Sensitivity of the state gradients to the nodal states \"\"\" lowerCaseQuantities = [ q . lower () for q in quantities ] outputs = {} numElements = nodeCoords . shape [ 0 ] numPoints = paramCoords . shape [ 0 ] numPointsTotal = numElements * numPoints # - Get shape functions N (du/dq) and their gradients in parametric coordinates at points # (same for all elements of same type) if any ([ q in lowerCaseQuantities for q in [ \"n\" , \"coords\" , \"state\" ]]): N = self . computeShapeFunctions ( paramCoords ) # numPoints x numNodes if \"n\" in lowerCaseQuantities : outputs [ \"N\" ] = N if any ( [ q in lowerCaseQuantities for q in [ \"nprimeparam\" , \"stategrad\" , \"jac\" , \"jacinv\" , \"jacdet\" , \"stategradsens\" ]] ): NPrimeParam = self . computeShapeFunctionGradients ( paramCoords ) # numPoints x numDim x numNodes if \"nprimeparam\" in lowerCaseQuantities : outputs [ \"NPrimeParam\" ] = NPrimeParam # - Compute real coordinates at points (different for each element) if \"coord\" in lowerCaseQuantities : pointCoords = _interpolationProduct ( N [:, : self . numNodes ], nodeCoords ) # numElements x numPoints x numDim outputs [ \"Coord\" ] = pointCoords # - Compute states at points (different for each element) if \"state\" in lowerCaseQuantities : pointStates = _interpolationProduct ( N , nodeStates ) # numElements x numPoints x numStates outputs [ \"State\" ] = pointStates # - Compute Jacobians, their inverses, and their determinants at points (different for each element) if any ([ q in lowerCaseQuantities for q in [ \"jac\" , \"jacinv\" , \"jacdet\" , \"stategrad\" , \"stategradsens\" ]]): pointJacs = np . zeros (( numElements , numPoints , self . numDim , self . numDim )) _computeNPrimeCoordProduct ( NPrimeParam , nodeCoords , pointJacs ) if \"jac\" in lowerCaseQuantities : outputs [ \"Jac\" ] = pointJacs if any ([ q in lowerCaseQuantities for q in [ \"jacinv\" , \"stategrad\" , \"stategradsens\" ]]): pointJacInvs = self . jacInv ( pointJacs ) if \"jacInv\" in lowerCaseQuantities : outputs [ \"JacInv\" ] = pointJacInvs if \"jacdet\" in lowerCaseQuantities : outputs [ \"JacDet\" ] = self . jacDet ( pointJacs ) # numElements x numPoints # - Compute du'/dq at points (different for each element) if \"stategradsens\" in lowerCaseQuantities : pointDUPrimedq = np . zeros (( numElements , numPoints , self . numDim , self . numNodes )) _computeDUPrimeDqProduct ( pointJacInvs , NPrimeParam , pointDUPrimedq ) outputs [ \"StateGradSens\" ] = pointDUPrimedq # - Compute u' at points (different for each element) if \"stategrad\" in lowerCaseQuantities : pointStateGradients = np . zeros (( numElements , numPoints , self . numStates , self . numDim )) _computeUPrimeProduct ( pointJacInvs , NPrimeParam , nodeStates , pointStateGradients ) outputs [ \"StateGrad\" ] = pointStateGradients # Currently everything is in numElements x numPoints x ... arrays, but the constitutive model doesn't care about # the distinction between different elements, so we need to flatten the first two dimensions of each array, so # they're all (numElements x numPoints) x ... for key in outputs : outputs [ key ] = np . ascontiguousarray ( outputs [ key ] . reshape ( numPointsTotal , * outputs [ key ] . shape [ 2 :])) # For the DVs it's a bit different, we have one DV value per element, so we actually need to expand them so that # we have one value per point if \"dvs\" in lowerCaseQuantities : outputs [ \"DVs\" ] = {} for dvName , dvValues in designVars . items (): outputs [ \"DVs\" ][ dvName ] = np . ascontiguousarray ( np . repeat ( dvValues , numPoints )) return outputs def computeResiduals ( self , nodeStates , nodeCoords , designVars , constitutiveModel , intOrder = None ): \"\"\"Compute the local residual for a series of elements Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element designVars : dict of numElements arrays Design variable values for each element constitutiveModel : FEMpy constitutive model object The constitutive model of the element Returns ------- numElement x numNodes x numStates array The local residuals for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , designVars , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"JacDet\" , \"StateGradSens\" , \"DVs\" ], ) weakRes = constitutiveModel . computeWeakResiduals ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) # - Compute r = du'/dq^T * f r = np . zeros (( numElements * numIntPoints , self . numNodes , self . numStates )) _transformResidual ( pointQuantities [ \"StateGradSens\" ], weakRes , r ) r = r . reshape (( numElements , numIntPoints , self . numNodes , self . numStates )) pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) # - Compute R, weighted sum of w * r * detJ over each set of integration points # R = np.einsum( # \"epns,ep,p->ens\", r, pointQuantities[\"JacDet\"], intPointWeights, optimize=[\"einsum_path\", (1, 2), (0, 1)] # ) R = np . zeros (( numElements , self . numNodes , self . numStates )) _integrate ( r , pointQuantities [ \"JacDet\" ], intPointWeights , R ) return R def computeResidualJacobians ( self , nodeStates , nodeCoords , designVars , constitutiveModel , intOrder = None ): \"\"\"Given node coordinates and states, design variable values, and a constitutive model, compute the residual Jacobian for a bunch of elements Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element designVars : dict of numElements arrays Design variable values for each element constitutiveModel : FEMpy constitutive model object The constitutive model of the element Returns ------- numElement x (numNodes * numStates) x (numNodes * numStates) array The local residual Jacobian matrix for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , designVars , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"JacDet\" , \"StateGradSens\" , \"DVs\" ], ) # Compute the weak residual Jacobians, dr/du' weakJacs = constitutiveModel . computeWeakResidualJacobian ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) # Compute dr/dq = du'/dq^T * dr/du' * du'/dq # Jacs = np.einsum( # \"pdn,pdsSD,pDN->pnsNS\", # pointQuantities[\"StateGradSens\"], # weakJacs, # pointQuantities[\"StateGradSens\"], # optimize=[\"einsum_path\", (0, 2), (0, 1)], # ) Jacs = np . zeros (( numElements * numIntPoints , self . numNodes , self . numStates , self . numNodes , self . numStates )) _transformResidualJacobians ( pointQuantities [ \"StateGradSens\" ], weakJacs , Jacs ) Jacs = Jacs . reshape (( numElements , numIntPoints , self . numNodes , self . numStates , self . numNodes , self . numStates )) pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) # - Compute R, weighted sum of w * r * detJ over each set of integration points dRdq = np . zeros (( numElements , self . numNodes , self . numStates , self . numNodes , self . numStates )) _integrate ( Jacs , pointQuantities [ \"JacDet\" ], intPointWeights , dRdq ) return dRdq . reshape (( numElements , self . numDOF , self . numDOF )) def computeStates ( self , paramCoords , nodeStates ): \"\"\"Given nodal DOF, compute the state at given parametric coordinates within the element This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute state at nodeStates : numElements x numNodes x numStates array State values at the nodes of each element Returns ------- states : numElements x numPoint x numStates array State values at the given parametric coordinates for each element \"\"\" # Compute shape functions at the given parametric coordinates N = self . computeShapeFunctions ( paramCoords ) # Then for each element, compute the states at the points, the einsum below is equivalent to: # product = np.zeros((numElements, numPoints, numStates)) # for ii in range(numElements): # product[ii] = N @ nodeStates[ii] return _interpolationProduct ( N , nodeStates ) def computeCoordinates ( self , paramCoords , nodeCoords ): \"\"\"Given nodal coordinates, compute the real coordinates at given parametric coordinates within the element Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute real coordinates of nodeCoords : numElements x numNodes x numDim array Node coordinates for each element \"\"\" # Compute shape functions at the given parametric coordinates N = self . computeShapeFunctions ( paramCoords ) # Then for each element, compute the states at the points, the einsum below is equivalent to: # product = np.zeros((numElements, numPoints, numStates)) # for ii in range(numElements): # product[ii] = N[:, : self.numNodes] @ nodeStates[ii] return _interpolationProduct ( N [:, : self . numNodes ], nodeCoords ) def computeJacobians ( self , paramCoords , nodeCoords ): \"\"\"Compute the Jacobian at a set of parametric coordinates within a set of elements This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute Jacobians at nodeCoords : numElements x numNodes x numDim array Node coordinates for each element Returns ------- Jac : numElements x numPoints x numDim x numDim array The Jacobians at each point in each element \"\"\" NPrimeParam = self . computeShapeFunctionGradients ( paramCoords ) # numPoints x numDim x numNodes numElements = nodeCoords . shape [ 0 ] numPoints = paramCoords . shape [ 0 ] Jac = np . zeros (( numElements , numPoints , self . numDim , self . numDim )) nodeCoords = np . ascontiguousarray ( nodeCoords ) # The function call below does the following: # for ii in range(numElements): # for jj in range(numPoints): # Jac[ii, jj] = NPrimeParam[jj] @ nodeCoords[ii] _computeNPrimeCoordProduct ( NPrimeParam , nodeCoords , Jac ) return Jac def computeStateGradients ( self , paramCoords , nodeStates , nodeCoords ): \"\"\"Given nodal DOF, compute the gradient of the state at given parametric coordinates within the element The gradient of the state at each point in each element is a numStates x numDim array. This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute state at nodeStates : numElements x numNodes x numStates array State values at the nodes of each element nodeCoords : numElements x numNodes x numDim array Node coordinates for each element Returns ------- stateGradients : numElements x numPoint x numStates x numDim array The gradient of the states at each point in each element, stateGradient[i, j, k, l] is the value of $du_k/dx_l$ at the $j^{th}$ point in the $i^{th}$ element \"\"\" numElements = nodeCoords . shape [ 0 ] numPoints = paramCoords . shape [ 0 ] NPrimeParam = self . computeShapeFunctionGradients ( paramCoords ) Jac = np . zeros (( numElements , numPoints , self . numDim , self . numDim )) _computeNPrimeCoordProduct ( NPrimeParam , nodeCoords , Jac ) JacInv = self . jacInv ( np . reshape ( Jac , ( numElements * numPoints , self . numDim , self . numDim ))) JacInv = np . reshape ( JacInv , ( numElements , numPoints , self . numDim , self . numDim )) UPrime = np . zeros (( numElements , numPoints , self . numStates , self . numDim )) # The function call below is equivalent to the following # for ii in range(numElements): # for jj in range(numPoints): # result[ii, jj] = (JacInv[ii, jj] @ NPrimeParam[jj] @ nodeStates[ii]).T _computeUPrimeProduct ( JacInv , NPrimeParam , np . ascontiguousarray ( nodeStates ), UPrime ) return UPrime # Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element def getClosestPoints ( self , nodeCoords , point , ** kwargs ): \"\"\"Given real coordinates of a point, find the parametric coordinates of the closest point on a series of elements to that point Computing the closest point is an optimization problem of the form: min ||X(x) - P||^2 s.t Ax <= b lb <= x <= ub Where X are the real coordinates of a point in the element, x the parametric coordinates of that point, and P is the target point. lb <= x <= ub and Ax <= b are a set of bounds and linear constraints on the parametric coordinates that encode the bounds of the element. Parameters ---------- nodeCoords : numElements x numNodes x numDim array The coordinates of the elements point : array of length numDim Target point coordinates Returns ------- closestParamCoords : numElements x numDim array The parametric coordinates of the closest point in each element closestDistances : numElements array The distances from the closest point in each element to the target point \"\"\" numElements = nodeCoords . shape [ 0 ] closestDistances = np . zeros ( numElements ) closestParamCoords = np . zeros (( numElements , self . numDim )) paramCoordBounds = Bounds ( lb = self . paramCoordLowerBounds , ub = self . paramCoordUpperBounds ) if self . paramCoordLinearConstaintMat is not None : paramCoordLinearConstraints = LinearConstraint ( self . paramCoordLinearConstaintMat , self . paramCoordLinearConstaintLowerBounds , self . paramCoordLinearConstaintUpperBounds , keep_feasible = True , ) else : paramCoordLinearConstraints = None for ii in range ( numElements ): closestParamCoords [ ii ], closestDistances [ ii ] = self . _getClosestPoint ( nodeCoords [ ii ], point , paramCoordBounds , paramCoordLinearConstraints , ** kwargs ) return closestParamCoords , closestDistances def _getClosestPoint ( self , nodeCoords , point , paramCoordBounds , paramCoordLinearConstraints , ** kwargs ): \"\"\"Find the closest point on a single element to a given point Parameters ---------- nodeCoords : numNodes x numDim array The coordinates of the element nodes point : array of length numDim Target point coordinates paramCoordBounds : scipy.optimize.Bounds object Parametric coordinate bounds paramCoordLinearConstraints : scipy.optimize.LinearConstraint object Any linear constraints required to enforce the parametric coordinate bounds Returns ------- array of length numDim The parametric coordinates of the closest point in the element float The distance from the closest point in the element to the target point \"\"\" nodeCoordCopy = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoordCopy [ 0 ] = nodeCoords def r ( xParam ): xTrue = self . computeCoordinates ( np . atleast_2d ( xParam ), nodeCoordCopy ) . flatten () error = np . linalg . norm ( xTrue - point ) print ( f \" { xParam =} , { xTrue =} , { point =} , { error =} \" ) return error def drdxParam ( xParam ): xTrue = self . computeCoordinates ( np . atleast_2d ( xParam ), nodeCoordCopy ) . flatten () Jac = self . computeJacobians ( np . atleast_2d ( xParam ), nodeCoordCopy ) return 2 * ( xTrue - point ) @ Jac [ 0 , 0 ] . T if \"tol\" not in kwargs : kwargs [ \"tol\" ] = 1e-10 maxAttempts = 10 closestPointFound = False for _ in range ( maxAttempts ): x0 = self . getRandParamCoord ( 1 )[ 0 ] sol = minimize ( r , x0 , jac = drdxParam , bounds = paramCoordBounds , constraints = paramCoordLinearConstraints , method = \"trust-constr\" , ** kwargs , ) closestPointFound = sol . fun < 1e-4 if closestPointFound : break return sol . x , sol . fun def getRandomElementCoordinates ( self , rng = None ): \"\"\"Compute random node coordinates for an element The random node coordinates are computed by taking the reference element coordinates and then applying: - Random perturbations to each node - Random translation in each dimension - Random scalings in each dimension - Random rotations around each available axis Parameters ---------- rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () coords = self . getReferenceElementCoordinates () # numNodes x numDim array # Perturb coordinates by up to 10% of the maximum distance between any two nodes maxDistance , _ = _computeMaxMinDistance ( coords ) coords += rng . random ( coords . shape ) * 0.1 * maxDistance # Apply random translation for ii in range ( self . numDim ): translation = rng . random () * 2 * maxDistance - maxDistance coords [:, ii ] += translation # Scale each dimension by a random factor between 0.1 and 10 for dim in range ( self . numDim ): scalingPower = rng . random () * 2 - 1 coords [:, dim ] *= 10 ** scalingPower # Rotate the element around each axis by a random angle if self . numDim == 2 : angle = rng . random () * 4 * np . pi - 2 * np . pi c , s = np . cos ( angle ), np . sin ( angle ) R = np . array ((( c , s ), ( - s , c ))) coords = coords @ R . T elif self . numDim == 3 : R = Rotation . random ( random_state = rng ) coords = coords @ R . as_matrix () . T return coords # ============================================================================== # Testing methods # ============================================================================== def getRandParamCoord ( self , n , rng = None ): \"\"\"Get a random set of parametric coordinates within the element By default this method assumes the the valid parametric coordinates are between -1 and 1 in each direction. If this is not the case for a particular element then that element should reimplemnt this method. Parameters ---------- n : int Number of points to generate rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () return rng . random (( n , self . numDim )) * 2 - 1 def testShapeFunctionDerivatives ( self , n = 10 , rng = None ): \"\"\"Test the implementation of the shape function derivatives using the complex-step method Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" paramCoords = self . getRandParamCoord ( n , rng = rng ) coordPert = np . zeros_like ( paramCoords , dtype = \"complex128\" ) dN = self . computeShapeFunctionGradients ( paramCoords ) dNApprox = np . zeros_like ( dN ) for i in range ( self . numDim ): np . copyto ( coordPert , paramCoords ) coordPert [:, i ] += 1e-200 * 1 j dNApprox [:, i , :] = 1e200 * np . imag ( self . computeShapeFunctions ( coordPert )) return dN - dNApprox def testShapeFunctionSum ( self , n = 10 , rng = None ): \"\"\"Test the basic property that shape function values should sum to 1 everywhere within an element Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" paramCoords = self . getRandParamCoord ( n , rng = rng ) N = self . computeShapeFunctions ( paramCoords ) return np . sum ( N , axis = 1 ) def testInterpolation ( self , n = 10 , rng = None ): \"\"\"Validate that, when the element geometry matches the reference element exactly, the parametric and real coordinates are the same Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getReferenceElementCoordinates () paramCoords = self . getRandParamCoord ( n , rng = rng ) error = np . zeros (( n , self . numDim )) x = self . computeCoordinates ( paramCoords , nodeCoords ) error = x - paramCoords return error def testIdentityJacobian ( self , n = 10 , rng = None ): \"\"\"Validate that, when the element geometry matches the reference element exactly, the mapping Jacobian is the identity matrix everywhere. Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getReferenceElementCoordinates () paramCoords = self . getRandParamCoord ( n , rng = rng ) # The expected Jacobians are a stack of n identity matrices expectedJacs = np . tile ( np . eye ( self . numDim ), ( 1 , n , 1 , 1 )) Jacs = self . computeJacobians ( paramCoords , nodeCoords ) return Jacs - expectedJacs def testStateGradient ( self , n = 10 , rng = None ): \"\"\"Test that the state gradient is correctly reconstructed within the element This test works by generating random node coordinates, then computing the states at each node using the following equation: u_i = a_i * x + b_i * y + c_i * z + d_i This field has a gradient, du/dx, of [a_i, b_i, c_i] everywhere in the element, which should be exactly reproduced by the state gradient computed by the element. Parameters ---------- n : int, optional _description_, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getRandomElementCoordinates ( rng = rng ) paramCoords = self . getRandParamCoord ( n , rng = rng ) randStateGradient = rng . random (( self . numStates , self . numDim )) ExpectedStateGradients = np . tile ( randStateGradient , ( 1 , n , 1 , 1 )) nodeStates = np . zeros (( 1 , self . numNodes , self . numStates )) for ii in range ( self . numNodes ): for jj in range ( self . numStates ): nodeStates [:, ii , jj ] = np . dot ( nodeCoords [ 0 , ii ], randStateGradient [ jj ]) stateGradient = self . computeStateGradients ( paramCoords , nodeStates , nodeCoords ) return stateGradient - ExpectedStateGradients def testGetClosestPoints ( self , n = 10 , tol = 1e-10 , rng = None ): \"\"\"Test the getClosestPoints method This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getClosestPoints match the original random values. Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getRandomElementCoordinates ( rng = rng ) paramCoords = self . getRandParamCoord ( n , rng = rng ) realCoords = self . computeCoordinates ( paramCoords , nodeCoords ) error = np . zeros_like ( realCoords ) for i in range ( n ): coords , _ = self . getClosestPoints ( nodeCoords , realCoords [ 0 , i ], tol = tol ) error [ 0 , i ] = coords - paramCoords [ i ] return error jacDet = det1 instance-attribute jacInv = inv1 instance-attribute name = f ' { self . numNodes } Node- { self . numStates } Disp- { self . numDim } D-Element' instance-attribute numDOF = self . numNodes * self . numStates instance-attribute numDim = numDim instance-attribute numNodes = numNodes instance-attribute numStates = numStates if numStates is not None else numDim instance-attribute paramCoordLinearConstaintLowerBounds = None instance-attribute paramCoordLinearConstaintMat = None instance-attribute paramCoordLinearConstaintUpperBounds = None instance-attribute paramCoordLowerBounds = - np . ones ( self . numDim ) instance-attribute paramCoordUpperBounds = np . ones ( self . numDim ) instance-attribute quadratureOrder = quadratureOrder instance-attribute __init__ ( numNodes , numDim , quadratureOrder , numStates = None ) Instantiate an element object Parameters: Name Type Description Default numNodes int Number of nodes in the element required numDim int Number of spatial dimensions the element lives in required quadratureOrder int Integration quadrature order required numStates int , optional Number of states in the underlying PDE, a.k.a the number of DOF per node, by default uses numDim None Source code in FEMpy/Elements/Element.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __init__ ( self , numNodes , numDim , quadratureOrder , numStates = None ): \"\"\"Instantiate an element object Parameters ---------- numNodes : int Number of nodes in the element numDim : int Number of spatial dimensions the element lives in quadratureOrder : int Integration quadrature order numStates : int, optional Number of states in the underlying PDE, a.k.a the number of DOF per node, by default uses numDim \"\"\" self . numNodes = numNodes self . numDim = numDim self . numStates = numStates if numStates is not None else numDim self . numDOF = self . numNodes * self . numStates self . quadratureOrder = quadratureOrder self . name = f \" { self . numNodes } Node- { self . numStates } Disp- { self . numDim } D-Element\" # --- Parametric coordinate bounds --- # By default it is assumed that the parametric coordinates are in the range [-1, 1] in each dimension, for # elements where this is not true (e.g a 2d triangular element), these attributes should be overwritten self . paramCoordLowerBounds = - np . ones ( self . numDim ) self . paramCoordUpperBounds = np . ones ( self . numDim ) self . paramCoordLinearConstaintMat = None self . paramCoordLinearConstaintUpperBounds = None self . paramCoordLinearConstaintLowerBounds = None # --- Define fast jacobian determinant function based on number of dimensions --- if self . numDim == 1 : self . jacDet = det1 self . jacInv = inv1 elif self . numDim == 2 : self . jacDet = det2 self . jacInv = inv2 elif self . numDim == 3 : self . jacDet = det3 self . jacInv = inv3 if self . numDim not in [ 1 , 2 , 3 ]: raise ValueError ( f \"Sorry, FEMpy doesn't support { self . numDim } -dimensional problems\" ) computeCoordinates ( paramCoords , nodeCoords ) Given nodal coordinates, compute the real coordinates at given parametric coordinates within the element Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to compute real coordinates of required nodeCoords numElements x numNodes x numDim array Node coordinates for each element required Source code in FEMpy/Elements/Element.py 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 def computeCoordinates ( self , paramCoords , nodeCoords ): \"\"\"Given nodal coordinates, compute the real coordinates at given parametric coordinates within the element Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute real coordinates of nodeCoords : numElements x numNodes x numDim array Node coordinates for each element \"\"\" # Compute shape functions at the given parametric coordinates N = self . computeShapeFunctions ( paramCoords ) # Then for each element, compute the states at the points, the einsum below is equivalent to: # product = np.zeros((numElements, numPoints, numStates)) # for ii in range(numElements): # product[ii] = N[:, : self.numNodes] @ nodeStates[ii] return _interpolationProduct ( N [:, : self . numNodes ], nodeCoords ) computeFunction ( nodeCoords , nodeStates , elementDVs , function , elementReductionType , intOrder = None ) Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element Parameters: Name Type Description Default nodeCoords numElements x numNodes x numDim array Node coordinates for each element required nodeStates numElements x numNodes x numStates array State values at the nodes of each element required elementDVs dict of numElement length arrays Design variable values for each element required function callable Function to evaluate at each point within each element, must have signature f(x, u, u', dvs), where: x is an n x numDim array of coordinates u is an n x numStates array of state values u' is an n x (numStates*numDim) array of state gradients dvs is an n x numDVs array of design variable values required elementReductionType _type_ Type of reduction to do to get a single value for each element, can be: - 'sum' : sum all values - 'mean' : average all values - integrate : integrate the function over the element - 'max' : take the maximum value - 'min' : take the minimum value - 'ksmax' : Compute a smooth approximation of the maximum value using KS aggregation - 'ksmin' : Compute a smooth approximation of the minimum value using KS aggregation required Returns: Name Type Description values numElements array Value of the function for each element Source code in FEMpy/Elements/Element.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def computeFunction ( self , nodeCoords , nodeStates , elementDVs , function , elementReductionType , intOrder = None ): \"\"\"Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element elementDVs : dict of numElement length arrays Design variable values for each element function : callable Function to evaluate at each point within each element, must have signature f(x, u, u', dvs), where: x is an n x numDim array of coordinates u is an n x numStates array of state values u' is an n x (numStates*numDim) array of state gradients dvs is an n x numDVs array of design variable values elementReductionType : _type_ Type of reduction to do to get a single value for each element, can be: - 'sum' : sum all values - 'mean' : average all values - `integrate` : integrate the function over the element - 'max' : take the maximum value - 'min' : take the minimum value - 'ksmax' : Compute a smooth approximation of the maximum value using KS aggregation - 'ksmin' : Compute a smooth approximation of the minimum value using KS aggregation Returns ------- values : numElements array Value of the function for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , elementDVs , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"DVs\" , \"JacDet\" ], ) values = function ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) values = values . reshape (( numElements , numIntPoints )) # perform element reduction if specified if elementReductionType is not None : assert elementReductionType . lower () in [ \"sum\" , \"mean\" , \"integrate\" , \"min\" , \"max\" , \"ksmax\" , \"ksmin\" , ], \"elementReductionType not valid\" # Simple numpy reductions if elementReductionType . lower () in [ \"sum\" , \"mean\" , \"min\" , \"max\" ]: if elementReductionType . lower () == \"sum\" : reductFunc = np . sum if elementReductionType . lower () == \"mean\" : reductFunc = np . average if elementReductionType . lower () == \"min\" : reductFunc = np . min if elementReductionType . lower () == \"max\" : reductFunc = np . max return reductFunc ( values , axis = 1 ) if elementReductionType . lower () == \"integrate\" : # compute integration using weighted sum of w*values*detJ over each set of element points pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) return np . einsum ( \"ep,ep,p->e\" , values , pointQuantities [ \"JacDet\" ], intPointWeights , optimize = [ \"einsum_path\" , ( 0 , 1 ), ( 0 , 1 )], ) if elementReductionType . lower () in [ \"ksmax\" , \"ksmin\" ]: reducedValues = np . zeros ( numElements ) for i in range ( numElements ): reducedValues [ i ] = ksAgg ( values [ i , :], \"max\" ) return reducedValues if elementReductionType . lower () == \"ksmin\" : reducedValues = np . zeros ( numElements ) for i in range ( numElements ): reducedValues [ i ] = ksAgg ( values [ i , :], \"min\" ) return reducedValues return values computeJacobians ( paramCoords , nodeCoords ) Compute the Jacobian at a set of parametric coordinates within a set of elements This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to compute Jacobians at required nodeCoords numElements x numNodes x numDim array Node coordinates for each element required Returns: Name Type Description Jac numElements x numPoints x numDim x numDim array The Jacobians at each point in each element Source code in FEMpy/Elements/Element.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def computeJacobians ( self , paramCoords , nodeCoords ): \"\"\"Compute the Jacobian at a set of parametric coordinates within a set of elements This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute Jacobians at nodeCoords : numElements x numNodes x numDim array Node coordinates for each element Returns ------- Jac : numElements x numPoints x numDim x numDim array The Jacobians at each point in each element \"\"\" NPrimeParam = self . computeShapeFunctionGradients ( paramCoords ) # numPoints x numDim x numNodes numElements = nodeCoords . shape [ 0 ] numPoints = paramCoords . shape [ 0 ] Jac = np . zeros (( numElements , numPoints , self . numDim , self . numDim )) nodeCoords = np . ascontiguousarray ( nodeCoords ) # The function call below does the following: # for ii in range(numElements): # for jj in range(numPoints): # Jac[ii, jj] = NPrimeParam[jj] @ nodeCoords[ii] _computeNPrimeCoordProduct ( NPrimeParam , nodeCoords , Jac ) return Jac computeResidualJacobians ( nodeStates , nodeCoords , designVars , constitutiveModel , intOrder = None ) Given node coordinates and states, design variable values, and a constitutive model, compute the residual Jacobian for a bunch of elements Parameters: Name Type Description Default nodeCoords numElements x numNodes x numDim array Node coordinates for each element required nodeStates numElements x numNodes x numStates array State values at the nodes of each element required designVars dict of numElements arrays Design variable values for each element required constitutiveModel FEMpy constitutive model object The constitutive model of the element required Returns: Type Description numElement x (numNodes The local residual Jacobian matrix for each element Source code in FEMpy/Elements/Element.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 def computeResidualJacobians ( self , nodeStates , nodeCoords , designVars , constitutiveModel , intOrder = None ): \"\"\"Given node coordinates and states, design variable values, and a constitutive model, compute the residual Jacobian for a bunch of elements Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element designVars : dict of numElements arrays Design variable values for each element constitutiveModel : FEMpy constitutive model object The constitutive model of the element Returns ------- numElement x (numNodes * numStates) x (numNodes * numStates) array The local residual Jacobian matrix for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , designVars , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"JacDet\" , \"StateGradSens\" , \"DVs\" ], ) # Compute the weak residual Jacobians, dr/du' weakJacs = constitutiveModel . computeWeakResidualJacobian ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) # Compute dr/dq = du'/dq^T * dr/du' * du'/dq # Jacs = np.einsum( # \"pdn,pdsSD,pDN->pnsNS\", # pointQuantities[\"StateGradSens\"], # weakJacs, # pointQuantities[\"StateGradSens\"], # optimize=[\"einsum_path\", (0, 2), (0, 1)], # ) Jacs = np . zeros (( numElements * numIntPoints , self . numNodes , self . numStates , self . numNodes , self . numStates )) _transformResidualJacobians ( pointQuantities [ \"StateGradSens\" ], weakJacs , Jacs ) Jacs = Jacs . reshape (( numElements , numIntPoints , self . numNodes , self . numStates , self . numNodes , self . numStates )) pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) # - Compute R, weighted sum of w * r * detJ over each set of integration points dRdq = np . zeros (( numElements , self . numNodes , self . numStates , self . numNodes , self . numStates )) _integrate ( Jacs , pointQuantities [ \"JacDet\" ], intPointWeights , dRdq ) return dRdq . reshape (( numElements , self . numDOF , self . numDOF )) computeResiduals ( nodeStates , nodeCoords , designVars , constitutiveModel , intOrder = None ) Compute the local residual for a series of elements Parameters: Name Type Description Default nodeCoords numElements x numNodes x numDim array Node coordinates for each element required nodeStates numElements x numNodes x numStates array State values at the nodes of each element required designVars dict of numElements arrays Design variable values for each element required constitutiveModel FEMpy constitutive model object The constitutive model of the element required Returns: Type Description numElement x numNodes x numStates array The local residuals for each element Source code in FEMpy/Elements/Element.py 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def computeResiduals ( self , nodeStates , nodeCoords , designVars , constitutiveModel , intOrder = None ): \"\"\"Compute the local residual for a series of elements Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element designVars : dict of numElements arrays Design variable values for each element constitutiveModel : FEMpy constitutive model object The constitutive model of the element Returns ------- numElement x numNodes x numStates array The local residuals for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , designVars , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"JacDet\" , \"StateGradSens\" , \"DVs\" ], ) weakRes = constitutiveModel . computeWeakResiduals ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) # - Compute r = du'/dq^T * f r = np . zeros (( numElements * numIntPoints , self . numNodes , self . numStates )) _transformResidual ( pointQuantities [ \"StateGradSens\" ], weakRes , r ) r = r . reshape (( numElements , numIntPoints , self . numNodes , self . numStates )) pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) # - Compute R, weighted sum of w * r * detJ over each set of integration points # R = np.einsum( # \"epns,ep,p->ens\", r, pointQuantities[\"JacDet\"], intPointWeights, optimize=[\"einsum_path\", (1, 2), (0, 1)] # ) R = np . zeros (( numElements , self . numNodes , self . numStates )) _integrate ( r , pointQuantities [ \"JacDet\" ], intPointWeights , R ) return R computeShapeFunctionGradients ( paramCoords ) abstractmethod Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at required Returns: Name Type Description NPrimeParam numPoint x numDim x numNodes array Shape function gradient values, NPrimeParam i [k] is the derivative of the kth shape function at the ith point w.r.t the jth parametric coordinate Source code in FEMpy/Elements/Element.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @abc . abstractmethod def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NPrimeParam: numPoint x numDim x numNodes array Shape function gradient values, NPrimeParam[i][j][k] is the derivative of the kth shape function at the ith point w.r.t the jth parametric coordinate \"\"\" raise NotImplementedError computeShapeFunctions ( paramCoords ) abstractmethod Compute the shape function values at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at required Returns: Name Type Description N numPoint x numNodes array Array of shape function values at the given parametric coordinates, N i is the value of the jth shape function at the ith parametric point Source code in FEMpy/Elements/Element.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @abc . abstractmethod def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" raise NotImplementedError computeStateGradients ( paramCoords , nodeStates , nodeCoords ) Given nodal DOF, compute the gradient of the state at given parametric coordinates within the element The gradient of the state at each point in each element is a numStates x numDim array. This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to compute state at required nodeStates numElements x numNodes x numStates array State values at the nodes of each element required nodeCoords numElements x numNodes x numDim array Node coordinates for each element required Returns: Name Type Description stateGradients numElements x numPoint x numStates x numDim array The gradient of the states at each point in each element, stateGradient[i, j, k, l] is the value of \\(du_k/dx_l\\) at the \\(j^{th}\\) point in the \\(i^{th}\\) element Source code in FEMpy/Elements/Element.py 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 def computeStateGradients ( self , paramCoords , nodeStates , nodeCoords ): \"\"\"Given nodal DOF, compute the gradient of the state at given parametric coordinates within the element The gradient of the state at each point in each element is a numStates x numDim array. This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute state at nodeStates : numElements x numNodes x numStates array State values at the nodes of each element nodeCoords : numElements x numNodes x numDim array Node coordinates for each element Returns ------- stateGradients : numElements x numPoint x numStates x numDim array The gradient of the states at each point in each element, stateGradient[i, j, k, l] is the value of $du_k/dx_l$ at the $j^{th}$ point in the $i^{th}$ element \"\"\" numElements = nodeCoords . shape [ 0 ] numPoints = paramCoords . shape [ 0 ] NPrimeParam = self . computeShapeFunctionGradients ( paramCoords ) Jac = np . zeros (( numElements , numPoints , self . numDim , self . numDim )) _computeNPrimeCoordProduct ( NPrimeParam , nodeCoords , Jac ) JacInv = self . jacInv ( np . reshape ( Jac , ( numElements * numPoints , self . numDim , self . numDim ))) JacInv = np . reshape ( JacInv , ( numElements , numPoints , self . numDim , self . numDim )) UPrime = np . zeros (( numElements , numPoints , self . numStates , self . numDim )) # The function call below is equivalent to the following # for ii in range(numElements): # for jj in range(numPoints): # result[ii, jj] = (JacInv[ii, jj] @ NPrimeParam[jj] @ nodeStates[ii]).T _computeUPrimeProduct ( JacInv , NPrimeParam , np . ascontiguousarray ( nodeStates ), UPrime ) return UPrime computeStates ( paramCoords , nodeStates ) Given nodal DOF, compute the state at given parametric coordinates within the element This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to compute state at required nodeStates numElements x numNodes x numStates array State values at the nodes of each element required Returns: Name Type Description states numElements x numPoint x numStates array State values at the given parametric coordinates for each element Source code in FEMpy/Elements/Element.py 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 def computeStates ( self , paramCoords , nodeStates ): \"\"\"Given nodal DOF, compute the state at given parametric coordinates within the element This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute state at nodeStates : numElements x numNodes x numStates array State values at the nodes of each element Returns ------- states : numElements x numPoint x numStates array State values at the given parametric coordinates for each element \"\"\" # Compute shape functions at the given parametric coordinates N = self . computeShapeFunctions ( paramCoords ) # Then for each element, compute the states at the points, the einsum below is equivalent to: # product = np.zeros((numElements, numPoints, numStates)) # for ii in range(numElements): # product[ii] = N @ nodeStates[ii] return _interpolationProduct ( N , nodeStates ) getClosestPoints ( nodeCoords , point , ** kwargs ) Given real coordinates of a point, find the parametric coordinates of the closest point on a series of elements to that point Computing the closest point is an optimization problem of the form: min ||X(x) - P||^2 s.t Ax <= b lb <= x <= ub Where X are the real coordinates of a point in the element, x the parametric coordinates of that point, and P is the target point. lb <= x <= ub and Ax <= b are a set of bounds and linear constraints on the parametric coordinates that encode the bounds of the element. Parameters: Name Type Description Default nodeCoords numElements x numNodes x numDim array The coordinates of the elements required point array of length numDim Target point coordinates required Returns: Name Type Description closestParamCoords numElements x numDim array The parametric coordinates of the closest point in each element closestDistances numElements array The distances from the closest point in each element to the target point Source code in FEMpy/Elements/Element.py 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 def getClosestPoints ( self , nodeCoords , point , ** kwargs ): \"\"\"Given real coordinates of a point, find the parametric coordinates of the closest point on a series of elements to that point Computing the closest point is an optimization problem of the form: min ||X(x) - P||^2 s.t Ax <= b lb <= x <= ub Where X are the real coordinates of a point in the element, x the parametric coordinates of that point, and P is the target point. lb <= x <= ub and Ax <= b are a set of bounds and linear constraints on the parametric coordinates that encode the bounds of the element. Parameters ---------- nodeCoords : numElements x numNodes x numDim array The coordinates of the elements point : array of length numDim Target point coordinates Returns ------- closestParamCoords : numElements x numDim array The parametric coordinates of the closest point in each element closestDistances : numElements array The distances from the closest point in each element to the target point \"\"\" numElements = nodeCoords . shape [ 0 ] closestDistances = np . zeros ( numElements ) closestParamCoords = np . zeros (( numElements , self . numDim )) paramCoordBounds = Bounds ( lb = self . paramCoordLowerBounds , ub = self . paramCoordUpperBounds ) if self . paramCoordLinearConstaintMat is not None : paramCoordLinearConstraints = LinearConstraint ( self . paramCoordLinearConstaintMat , self . paramCoordLinearConstaintLowerBounds , self . paramCoordLinearConstaintUpperBounds , keep_feasible = True , ) else : paramCoordLinearConstraints = None for ii in range ( numElements ): closestParamCoords [ ii ], closestDistances [ ii ] = self . _getClosestPoint ( nodeCoords [ ii ], point , paramCoordBounds , paramCoordLinearConstraints , ** kwargs ) return closestParamCoords , closestDistances getIntegrationPointCoords ( order = None ) abstractmethod Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters: Name Type Description Default order int , optional Integration order None Returns: Type Description numIntpoint x numDim array Integration point coordinates Source code in FEMpy/Elements/Element.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @abc . abstractmethod def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int, optional Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" raise NotImplementedError getIntegrationPointWeights ( order = None ) abstractmethod Compute the integration point weights for a given quadrature order on this element Parameters: Name Type Description Default order int , optional Integration order None Returns: Type Description array of length numIntpoint Integration point weights Source code in FEMpy/Elements/Element.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 @abc . abstractmethod def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int, optional Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" raise NotImplementedError getRandParamCoord ( n , rng = None ) Get a random set of parametric coordinates within the element By default this method assumes the the valid parametric coordinates are between -1 and 1 in each direction. If this is not the case for a particular element then that element should reimplemnt this method. Parameters: Name Type Description Default n int Number of points to generate required rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 def getRandParamCoord ( self , n , rng = None ): \"\"\"Get a random set of parametric coordinates within the element By default this method assumes the the valid parametric coordinates are between -1 and 1 in each direction. If this is not the case for a particular element then that element should reimplemnt this method. Parameters ---------- n : int Number of points to generate rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () return rng . random (( n , self . numDim )) * 2 - 1 getRandomElementCoordinates ( rng = None ) Compute random node coordinates for an element The random node coordinates are computed by taking the reference element coordinates and then applying: - Random perturbations to each node - Random translation in each dimension - Random scalings in each dimension - Random rotations around each available axis Parameters: Name Type Description Default rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 def getRandomElementCoordinates ( self , rng = None ): \"\"\"Compute random node coordinates for an element The random node coordinates are computed by taking the reference element coordinates and then applying: - Random perturbations to each node - Random translation in each dimension - Random scalings in each dimension - Random rotations around each available axis Parameters ---------- rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () coords = self . getReferenceElementCoordinates () # numNodes x numDim array # Perturb coordinates by up to 10% of the maximum distance between any two nodes maxDistance , _ = _computeMaxMinDistance ( coords ) coords += rng . random ( coords . shape ) * 0.1 * maxDistance # Apply random translation for ii in range ( self . numDim ): translation = rng . random () * 2 * maxDistance - maxDistance coords [:, ii ] += translation # Scale each dimension by a random factor between 0.1 and 10 for dim in range ( self . numDim ): scalingPower = rng . random () * 2 - 1 coords [:, dim ] *= 10 ** scalingPower # Rotate the element around each axis by a random angle if self . numDim == 2 : angle = rng . random () * 4 * np . pi - 2 * np . pi c , s = np . cos ( angle ), np . sin ( angle ) R = np . array ((( c , s ), ( - s , c ))) coords = coords @ R . T elif self . numDim == 3 : R = Rotation . random ( random_state = rng ) coords = coords @ R . as_matrix () . T return coords getReferenceElementCoordinates () abstractmethod Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns: Type Description numNodes x numDim array Element node coordinates Source code in FEMpy/Elements/Element.py 149 150 151 152 153 154 155 156 157 158 @abc . abstractmethod def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns ------- numNodes x numDim array Element node coordinates \"\"\" raise NotImplementedError testGetClosestPoints ( n = 10 , tol = 1e-10 , rng = None ) Test the getClosestPoints method This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getClosestPoints match the original random values. Parameters: Name Type Description Default n int , optional Number of random coordinates to generate, by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 def testGetClosestPoints ( self , n = 10 , tol = 1e-10 , rng = None ): \"\"\"Test the getClosestPoints method This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getClosestPoints match the original random values. Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getRandomElementCoordinates ( rng = rng ) paramCoords = self . getRandParamCoord ( n , rng = rng ) realCoords = self . computeCoordinates ( paramCoords , nodeCoords ) error = np . zeros_like ( realCoords ) for i in range ( n ): coords , _ = self . getClosestPoints ( nodeCoords , realCoords [ 0 , i ], tol = tol ) error [ 0 , i ] = coords - paramCoords [ i ] return error testIdentityJacobian ( n = 10 , rng = None ) Validate that, when the element geometry matches the reference element exactly, the mapping Jacobian is the identity matrix everywhere. Parameters: Name Type Description Default n int , optional Number of points to test at, by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 def testIdentityJacobian ( self , n = 10 , rng = None ): \"\"\"Validate that, when the element geometry matches the reference element exactly, the mapping Jacobian is the identity matrix everywhere. Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getReferenceElementCoordinates () paramCoords = self . getRandParamCoord ( n , rng = rng ) # The expected Jacobians are a stack of n identity matrices expectedJacs = np . tile ( np . eye ( self . numDim ), ( 1 , n , 1 , 1 )) Jacs = self . computeJacobians ( paramCoords , nodeCoords ) return Jacs - expectedJacs testInterpolation ( n = 10 , rng = None ) Validate that, when the element geometry matches the reference element exactly, the parametric and real coordinates are the same Parameters: Name Type Description Default n int , optional Number of points to test at, by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 def testInterpolation ( self , n = 10 , rng = None ): \"\"\"Validate that, when the element geometry matches the reference element exactly, the parametric and real coordinates are the same Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getReferenceElementCoordinates () paramCoords = self . getRandParamCoord ( n , rng = rng ) error = np . zeros (( n , self . numDim )) x = self . computeCoordinates ( paramCoords , nodeCoords ) error = x - paramCoords return error testShapeFunctionDerivatives ( n = 10 , rng = None ) Test the implementation of the shape function derivatives using the complex-step method Parameters: Name Type Description Default n int , optional Number of random coordinates to generate, by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 def testShapeFunctionDerivatives ( self , n = 10 , rng = None ): \"\"\"Test the implementation of the shape function derivatives using the complex-step method Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" paramCoords = self . getRandParamCoord ( n , rng = rng ) coordPert = np . zeros_like ( paramCoords , dtype = \"complex128\" ) dN = self . computeShapeFunctionGradients ( paramCoords ) dNApprox = np . zeros_like ( dN ) for i in range ( self . numDim ): np . copyto ( coordPert , paramCoords ) coordPert [:, i ] += 1e-200 * 1 j dNApprox [:, i , :] = 1e200 * np . imag ( self . computeShapeFunctions ( coordPert )) return dN - dNApprox testShapeFunctionSum ( n = 10 , rng = None ) Test the basic property that shape function values should sum to 1 everywhere within an element Parameters: Name Type Description Default n int , optional Number of points to test at, by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def testShapeFunctionSum ( self , n = 10 , rng = None ): \"\"\"Test the basic property that shape function values should sum to 1 everywhere within an element Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" paramCoords = self . getRandParamCoord ( n , rng = rng ) N = self . computeShapeFunctions ( paramCoords ) return np . sum ( N , axis = 1 ) testStateGradient ( n = 10 , rng = None ) Test that the state gradient is correctly reconstructed within the element This test works by generating random node coordinates, then computing the states at each node using the following equation: u_i = a_i * x + b_i * y + c_i * z + d_i This field has a gradient, du/dx, of [a_i, b_i, c_i] everywhere in the element, which should be exactly reproduced by the state gradient computed by the element. Parameters: Name Type Description Default n int , optional description , by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 def testStateGradient ( self , n = 10 , rng = None ): \"\"\"Test that the state gradient is correctly reconstructed within the element This test works by generating random node coordinates, then computing the states at each node using the following equation: u_i = a_i * x + b_i * y + c_i * z + d_i This field has a gradient, du/dx, of [a_i, b_i, c_i] everywhere in the element, which should be exactly reproduced by the state gradient computed by the element. Parameters ---------- n : int, optional _description_, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getRandomElementCoordinates ( rng = rng ) paramCoords = self . getRandParamCoord ( n , rng = rng ) randStateGradient = rng . random (( self . numStates , self . numDim )) ExpectedStateGradients = np . tile ( randStateGradient , ( 1 , n , 1 , 1 )) nodeStates = np . zeros (( 1 , self . numNodes , self . numStates )) for ii in range ( self . numNodes ): for jj in range ( self . numStates ): nodeStates [:, ii , jj ] = np . dot ( nodeCoords [ 0 , ii ], randStateGradient [ jj ]) stateGradient = self . computeStateGradients ( paramCoords , nodeStates , nodeCoords ) return stateGradient - ExpectedStateGradients","title":"Element Base Class"},{"location":"Elements/Element/#element-base-class","text":"The base class from which all other elements are derived. Source code in FEMpy/Elements/Element.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 class Element : \"\"\"The base class from which all other elements are derived.\"\"\" def __init__ ( self , numNodes , numDim , quadratureOrder , numStates = None ): \"\"\"Instantiate an element object Parameters ---------- numNodes : int Number of nodes in the element numDim : int Number of spatial dimensions the element lives in quadratureOrder : int Integration quadrature order numStates : int, optional Number of states in the underlying PDE, a.k.a the number of DOF per node, by default uses numDim \"\"\" self . numNodes = numNodes self . numDim = numDim self . numStates = numStates if numStates is not None else numDim self . numDOF = self . numNodes * self . numStates self . quadratureOrder = quadratureOrder self . name = f \" { self . numNodes } Node- { self . numStates } Disp- { self . numDim } D-Element\" # --- Parametric coordinate bounds --- # By default it is assumed that the parametric coordinates are in the range [-1, 1] in each dimension, for # elements where this is not true (e.g a 2d triangular element), these attributes should be overwritten self . paramCoordLowerBounds = - np . ones ( self . numDim ) self . paramCoordUpperBounds = np . ones ( self . numDim ) self . paramCoordLinearConstaintMat = None self . paramCoordLinearConstaintUpperBounds = None self . paramCoordLinearConstaintLowerBounds = None # --- Define fast jacobian determinant function based on number of dimensions --- if self . numDim == 1 : self . jacDet = det1 self . jacInv = inv1 elif self . numDim == 2 : self . jacDet = det2 self . jacInv = inv2 elif self . numDim == 3 : self . jacDet = det3 self . jacInv = inv3 if self . numDim not in [ 1 , 2 , 3 ]: raise ValueError ( f \"Sorry, FEMpy doesn't support { self . numDim } -dimensional problems\" ) # ============================================================================== # Abstract methods: Must be implemented by derived classes # ============================================================================== @abc . abstractmethod def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" raise NotImplementedError @abc . abstractmethod def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NPrimeParam: numPoint x numDim x numNodes array Shape function gradient values, NPrimeParam[i][j][k] is the derivative of the kth shape function at the ith point w.r.t the jth parametric coordinate \"\"\" raise NotImplementedError @abc . abstractmethod def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int, optional Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" raise NotImplementedError @abc . abstractmethod def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int, optional Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" raise NotImplementedError @abc . abstractmethod def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns ------- numNodes x numDim array Element node coordinates \"\"\" raise NotImplementedError # ============================================================================== # Implemented methods # ============================================================================== def computeFunction ( self , nodeCoords , nodeStates , elementDVs , function , elementReductionType , intOrder = None ): \"\"\"Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element elementDVs : dict of numElement length arrays Design variable values for each element function : callable Function to evaluate at each point within each element, must have signature f(x, u, u', dvs), where: x is an n x numDim array of coordinates u is an n x numStates array of state values u' is an n x (numStates*numDim) array of state gradients dvs is an n x numDVs array of design variable values elementReductionType : _type_ Type of reduction to do to get a single value for each element, can be: - 'sum' : sum all values - 'mean' : average all values - `integrate` : integrate the function over the element - 'max' : take the maximum value - 'min' : take the minimum value - 'ksmax' : Compute a smooth approximation of the maximum value using KS aggregation - 'ksmin' : Compute a smooth approximation of the minimum value using KS aggregation Returns ------- values : numElements array Value of the function for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , elementDVs , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"DVs\" , \"JacDet\" ], ) values = function ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) values = values . reshape (( numElements , numIntPoints )) # perform element reduction if specified if elementReductionType is not None : assert elementReductionType . lower () in [ \"sum\" , \"mean\" , \"integrate\" , \"min\" , \"max\" , \"ksmax\" , \"ksmin\" , ], \"elementReductionType not valid\" # Simple numpy reductions if elementReductionType . lower () in [ \"sum\" , \"mean\" , \"min\" , \"max\" ]: if elementReductionType . lower () == \"sum\" : reductFunc = np . sum if elementReductionType . lower () == \"mean\" : reductFunc = np . average if elementReductionType . lower () == \"min\" : reductFunc = np . min if elementReductionType . lower () == \"max\" : reductFunc = np . max return reductFunc ( values , axis = 1 ) if elementReductionType . lower () == \"integrate\" : # compute integration using weighted sum of w*values*detJ over each set of element points pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) return np . einsum ( \"ep,ep,p->e\" , values , pointQuantities [ \"JacDet\" ], intPointWeights , optimize = [ \"einsum_path\" , ( 0 , 1 ), ( 0 , 1 )], ) if elementReductionType . lower () in [ \"ksmax\" , \"ksmin\" ]: reducedValues = np . zeros ( numElements ) for i in range ( numElements ): reducedValues [ i ] = ksAgg ( values [ i , :], \"max\" ) return reducedValues if elementReductionType . lower () == \"ksmin\" : reducedValues = np . zeros ( numElements ) for i in range ( numElements ): reducedValues [ i ] = ksAgg ( values [ i , :], \"min\" ) return reducedValues return values def _computeFunctionEvaluationQuantities ( self , paramCoords , nodeStates , nodeCoords , designVars , quantities ): \"\"\"Compute a series of values that are used for evaluating functions at multiple points over multiple elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate quantities at nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element designVars : dict of numElements arrays Design variable values for each element quantities : list of strings, optional List of quantities to compute, by default None are computed, valid quatities are: - \"N\" : Shape function values - \"NPrimeParam\" : Shape function gradients - \"Coord\" : True coordinates - \"State\" : State values - \"StateGrad\" : State gradients - \"DVs\" : Design variable values - \"Jac\" : Jacobian of the transformation from parametric to true coordinates - \"JacInv\" : Inverse of the Jacobian of the transformation from parametric to true coordinates - \"JacDet\" : Determinant of the Jacobian of the transformation from parametric to true coordinates - \"StateGradSens\" : Sensitivity of the state gradients to the nodal states \"\"\" lowerCaseQuantities = [ q . lower () for q in quantities ] outputs = {} numElements = nodeCoords . shape [ 0 ] numPoints = paramCoords . shape [ 0 ] numPointsTotal = numElements * numPoints # - Get shape functions N (du/dq) and their gradients in parametric coordinates at points # (same for all elements of same type) if any ([ q in lowerCaseQuantities for q in [ \"n\" , \"coords\" , \"state\" ]]): N = self . computeShapeFunctions ( paramCoords ) # numPoints x numNodes if \"n\" in lowerCaseQuantities : outputs [ \"N\" ] = N if any ( [ q in lowerCaseQuantities for q in [ \"nprimeparam\" , \"stategrad\" , \"jac\" , \"jacinv\" , \"jacdet\" , \"stategradsens\" ]] ): NPrimeParam = self . computeShapeFunctionGradients ( paramCoords ) # numPoints x numDim x numNodes if \"nprimeparam\" in lowerCaseQuantities : outputs [ \"NPrimeParam\" ] = NPrimeParam # - Compute real coordinates at points (different for each element) if \"coord\" in lowerCaseQuantities : pointCoords = _interpolationProduct ( N [:, : self . numNodes ], nodeCoords ) # numElements x numPoints x numDim outputs [ \"Coord\" ] = pointCoords # - Compute states at points (different for each element) if \"state\" in lowerCaseQuantities : pointStates = _interpolationProduct ( N , nodeStates ) # numElements x numPoints x numStates outputs [ \"State\" ] = pointStates # - Compute Jacobians, their inverses, and their determinants at points (different for each element) if any ([ q in lowerCaseQuantities for q in [ \"jac\" , \"jacinv\" , \"jacdet\" , \"stategrad\" , \"stategradsens\" ]]): pointJacs = np . zeros (( numElements , numPoints , self . numDim , self . numDim )) _computeNPrimeCoordProduct ( NPrimeParam , nodeCoords , pointJacs ) if \"jac\" in lowerCaseQuantities : outputs [ \"Jac\" ] = pointJacs if any ([ q in lowerCaseQuantities for q in [ \"jacinv\" , \"stategrad\" , \"stategradsens\" ]]): pointJacInvs = self . jacInv ( pointJacs ) if \"jacInv\" in lowerCaseQuantities : outputs [ \"JacInv\" ] = pointJacInvs if \"jacdet\" in lowerCaseQuantities : outputs [ \"JacDet\" ] = self . jacDet ( pointJacs ) # numElements x numPoints # - Compute du'/dq at points (different for each element) if \"stategradsens\" in lowerCaseQuantities : pointDUPrimedq = np . zeros (( numElements , numPoints , self . numDim , self . numNodes )) _computeDUPrimeDqProduct ( pointJacInvs , NPrimeParam , pointDUPrimedq ) outputs [ \"StateGradSens\" ] = pointDUPrimedq # - Compute u' at points (different for each element) if \"stategrad\" in lowerCaseQuantities : pointStateGradients = np . zeros (( numElements , numPoints , self . numStates , self . numDim )) _computeUPrimeProduct ( pointJacInvs , NPrimeParam , nodeStates , pointStateGradients ) outputs [ \"StateGrad\" ] = pointStateGradients # Currently everything is in numElements x numPoints x ... arrays, but the constitutive model doesn't care about # the distinction between different elements, so we need to flatten the first two dimensions of each array, so # they're all (numElements x numPoints) x ... for key in outputs : outputs [ key ] = np . ascontiguousarray ( outputs [ key ] . reshape ( numPointsTotal , * outputs [ key ] . shape [ 2 :])) # For the DVs it's a bit different, we have one DV value per element, so we actually need to expand them so that # we have one value per point if \"dvs\" in lowerCaseQuantities : outputs [ \"DVs\" ] = {} for dvName , dvValues in designVars . items (): outputs [ \"DVs\" ][ dvName ] = np . ascontiguousarray ( np . repeat ( dvValues , numPoints )) return outputs def computeResiduals ( self , nodeStates , nodeCoords , designVars , constitutiveModel , intOrder = None ): \"\"\"Compute the local residual for a series of elements Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element designVars : dict of numElements arrays Design variable values for each element constitutiveModel : FEMpy constitutive model object The constitutive model of the element Returns ------- numElement x numNodes x numStates array The local residuals for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , designVars , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"JacDet\" , \"StateGradSens\" , \"DVs\" ], ) weakRes = constitutiveModel . computeWeakResiduals ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) # - Compute r = du'/dq^T * f r = np . zeros (( numElements * numIntPoints , self . numNodes , self . numStates )) _transformResidual ( pointQuantities [ \"StateGradSens\" ], weakRes , r ) r = r . reshape (( numElements , numIntPoints , self . numNodes , self . numStates )) pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) # - Compute R, weighted sum of w * r * detJ over each set of integration points # R = np.einsum( # \"epns,ep,p->ens\", r, pointQuantities[\"JacDet\"], intPointWeights, optimize=[\"einsum_path\", (1, 2), (0, 1)] # ) R = np . zeros (( numElements , self . numNodes , self . numStates )) _integrate ( r , pointQuantities [ \"JacDet\" ], intPointWeights , R ) return R def computeResidualJacobians ( self , nodeStates , nodeCoords , designVars , constitutiveModel , intOrder = None ): \"\"\"Given node coordinates and states, design variable values, and a constitutive model, compute the residual Jacobian for a bunch of elements Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element designVars : dict of numElements arrays Design variable values for each element constitutiveModel : FEMpy constitutive model object The constitutive model of the element Returns ------- numElement x (numNodes * numStates) x (numNodes * numStates) array The local residual Jacobian matrix for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , designVars , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"JacDet\" , \"StateGradSens\" , \"DVs\" ], ) # Compute the weak residual Jacobians, dr/du' weakJacs = constitutiveModel . computeWeakResidualJacobian ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) # Compute dr/dq = du'/dq^T * dr/du' * du'/dq # Jacs = np.einsum( # \"pdn,pdsSD,pDN->pnsNS\", # pointQuantities[\"StateGradSens\"], # weakJacs, # pointQuantities[\"StateGradSens\"], # optimize=[\"einsum_path\", (0, 2), (0, 1)], # ) Jacs = np . zeros (( numElements * numIntPoints , self . numNodes , self . numStates , self . numNodes , self . numStates )) _transformResidualJacobians ( pointQuantities [ \"StateGradSens\" ], weakJacs , Jacs ) Jacs = Jacs . reshape (( numElements , numIntPoints , self . numNodes , self . numStates , self . numNodes , self . numStates )) pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) # - Compute R, weighted sum of w * r * detJ over each set of integration points dRdq = np . zeros (( numElements , self . numNodes , self . numStates , self . numNodes , self . numStates )) _integrate ( Jacs , pointQuantities [ \"JacDet\" ], intPointWeights , dRdq ) return dRdq . reshape (( numElements , self . numDOF , self . numDOF )) def computeStates ( self , paramCoords , nodeStates ): \"\"\"Given nodal DOF, compute the state at given parametric coordinates within the element This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute state at nodeStates : numElements x numNodes x numStates array State values at the nodes of each element Returns ------- states : numElements x numPoint x numStates array State values at the given parametric coordinates for each element \"\"\" # Compute shape functions at the given parametric coordinates N = self . computeShapeFunctions ( paramCoords ) # Then for each element, compute the states at the points, the einsum below is equivalent to: # product = np.zeros((numElements, numPoints, numStates)) # for ii in range(numElements): # product[ii] = N @ nodeStates[ii] return _interpolationProduct ( N , nodeStates ) def computeCoordinates ( self , paramCoords , nodeCoords ): \"\"\"Given nodal coordinates, compute the real coordinates at given parametric coordinates within the element Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute real coordinates of nodeCoords : numElements x numNodes x numDim array Node coordinates for each element \"\"\" # Compute shape functions at the given parametric coordinates N = self . computeShapeFunctions ( paramCoords ) # Then for each element, compute the states at the points, the einsum below is equivalent to: # product = np.zeros((numElements, numPoints, numStates)) # for ii in range(numElements): # product[ii] = N[:, : self.numNodes] @ nodeStates[ii] return _interpolationProduct ( N [:, : self . numNodes ], nodeCoords ) def computeJacobians ( self , paramCoords , nodeCoords ): \"\"\"Compute the Jacobian at a set of parametric coordinates within a set of elements This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute Jacobians at nodeCoords : numElements x numNodes x numDim array Node coordinates for each element Returns ------- Jac : numElements x numPoints x numDim x numDim array The Jacobians at each point in each element \"\"\" NPrimeParam = self . computeShapeFunctionGradients ( paramCoords ) # numPoints x numDim x numNodes numElements = nodeCoords . shape [ 0 ] numPoints = paramCoords . shape [ 0 ] Jac = np . zeros (( numElements , numPoints , self . numDim , self . numDim )) nodeCoords = np . ascontiguousarray ( nodeCoords ) # The function call below does the following: # for ii in range(numElements): # for jj in range(numPoints): # Jac[ii, jj] = NPrimeParam[jj] @ nodeCoords[ii] _computeNPrimeCoordProduct ( NPrimeParam , nodeCoords , Jac ) return Jac def computeStateGradients ( self , paramCoords , nodeStates , nodeCoords ): \"\"\"Given nodal DOF, compute the gradient of the state at given parametric coordinates within the element The gradient of the state at each point in each element is a numStates x numDim array. This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute state at nodeStates : numElements x numNodes x numStates array State values at the nodes of each element nodeCoords : numElements x numNodes x numDim array Node coordinates for each element Returns ------- stateGradients : numElements x numPoint x numStates x numDim array The gradient of the states at each point in each element, stateGradient[i, j, k, l] is the value of $du_k/dx_l$ at the $j^{th}$ point in the $i^{th}$ element \"\"\" numElements = nodeCoords . shape [ 0 ] numPoints = paramCoords . shape [ 0 ] NPrimeParam = self . computeShapeFunctionGradients ( paramCoords ) Jac = np . zeros (( numElements , numPoints , self . numDim , self . numDim )) _computeNPrimeCoordProduct ( NPrimeParam , nodeCoords , Jac ) JacInv = self . jacInv ( np . reshape ( Jac , ( numElements * numPoints , self . numDim , self . numDim ))) JacInv = np . reshape ( JacInv , ( numElements , numPoints , self . numDim , self . numDim )) UPrime = np . zeros (( numElements , numPoints , self . numStates , self . numDim )) # The function call below is equivalent to the following # for ii in range(numElements): # for jj in range(numPoints): # result[ii, jj] = (JacInv[ii, jj] @ NPrimeParam[jj] @ nodeStates[ii]).T _computeUPrimeProduct ( JacInv , NPrimeParam , np . ascontiguousarray ( nodeStates ), UPrime ) return UPrime # Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element def getClosestPoints ( self , nodeCoords , point , ** kwargs ): \"\"\"Given real coordinates of a point, find the parametric coordinates of the closest point on a series of elements to that point Computing the closest point is an optimization problem of the form: min ||X(x) - P||^2 s.t Ax <= b lb <= x <= ub Where X are the real coordinates of a point in the element, x the parametric coordinates of that point, and P is the target point. lb <= x <= ub and Ax <= b are a set of bounds and linear constraints on the parametric coordinates that encode the bounds of the element. Parameters ---------- nodeCoords : numElements x numNodes x numDim array The coordinates of the elements point : array of length numDim Target point coordinates Returns ------- closestParamCoords : numElements x numDim array The parametric coordinates of the closest point in each element closestDistances : numElements array The distances from the closest point in each element to the target point \"\"\" numElements = nodeCoords . shape [ 0 ] closestDistances = np . zeros ( numElements ) closestParamCoords = np . zeros (( numElements , self . numDim )) paramCoordBounds = Bounds ( lb = self . paramCoordLowerBounds , ub = self . paramCoordUpperBounds ) if self . paramCoordLinearConstaintMat is not None : paramCoordLinearConstraints = LinearConstraint ( self . paramCoordLinearConstaintMat , self . paramCoordLinearConstaintLowerBounds , self . paramCoordLinearConstaintUpperBounds , keep_feasible = True , ) else : paramCoordLinearConstraints = None for ii in range ( numElements ): closestParamCoords [ ii ], closestDistances [ ii ] = self . _getClosestPoint ( nodeCoords [ ii ], point , paramCoordBounds , paramCoordLinearConstraints , ** kwargs ) return closestParamCoords , closestDistances def _getClosestPoint ( self , nodeCoords , point , paramCoordBounds , paramCoordLinearConstraints , ** kwargs ): \"\"\"Find the closest point on a single element to a given point Parameters ---------- nodeCoords : numNodes x numDim array The coordinates of the element nodes point : array of length numDim Target point coordinates paramCoordBounds : scipy.optimize.Bounds object Parametric coordinate bounds paramCoordLinearConstraints : scipy.optimize.LinearConstraint object Any linear constraints required to enforce the parametric coordinate bounds Returns ------- array of length numDim The parametric coordinates of the closest point in the element float The distance from the closest point in the element to the target point \"\"\" nodeCoordCopy = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoordCopy [ 0 ] = nodeCoords def r ( xParam ): xTrue = self . computeCoordinates ( np . atleast_2d ( xParam ), nodeCoordCopy ) . flatten () error = np . linalg . norm ( xTrue - point ) print ( f \" { xParam =} , { xTrue =} , { point =} , { error =} \" ) return error def drdxParam ( xParam ): xTrue = self . computeCoordinates ( np . atleast_2d ( xParam ), nodeCoordCopy ) . flatten () Jac = self . computeJacobians ( np . atleast_2d ( xParam ), nodeCoordCopy ) return 2 * ( xTrue - point ) @ Jac [ 0 , 0 ] . T if \"tol\" not in kwargs : kwargs [ \"tol\" ] = 1e-10 maxAttempts = 10 closestPointFound = False for _ in range ( maxAttempts ): x0 = self . getRandParamCoord ( 1 )[ 0 ] sol = minimize ( r , x0 , jac = drdxParam , bounds = paramCoordBounds , constraints = paramCoordLinearConstraints , method = \"trust-constr\" , ** kwargs , ) closestPointFound = sol . fun < 1e-4 if closestPointFound : break return sol . x , sol . fun def getRandomElementCoordinates ( self , rng = None ): \"\"\"Compute random node coordinates for an element The random node coordinates are computed by taking the reference element coordinates and then applying: - Random perturbations to each node - Random translation in each dimension - Random scalings in each dimension - Random rotations around each available axis Parameters ---------- rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () coords = self . getReferenceElementCoordinates () # numNodes x numDim array # Perturb coordinates by up to 10% of the maximum distance between any two nodes maxDistance , _ = _computeMaxMinDistance ( coords ) coords += rng . random ( coords . shape ) * 0.1 * maxDistance # Apply random translation for ii in range ( self . numDim ): translation = rng . random () * 2 * maxDistance - maxDistance coords [:, ii ] += translation # Scale each dimension by a random factor between 0.1 and 10 for dim in range ( self . numDim ): scalingPower = rng . random () * 2 - 1 coords [:, dim ] *= 10 ** scalingPower # Rotate the element around each axis by a random angle if self . numDim == 2 : angle = rng . random () * 4 * np . pi - 2 * np . pi c , s = np . cos ( angle ), np . sin ( angle ) R = np . array ((( c , s ), ( - s , c ))) coords = coords @ R . T elif self . numDim == 3 : R = Rotation . random ( random_state = rng ) coords = coords @ R . as_matrix () . T return coords # ============================================================================== # Testing methods # ============================================================================== def getRandParamCoord ( self , n , rng = None ): \"\"\"Get a random set of parametric coordinates within the element By default this method assumes the the valid parametric coordinates are between -1 and 1 in each direction. If this is not the case for a particular element then that element should reimplemnt this method. Parameters ---------- n : int Number of points to generate rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () return rng . random (( n , self . numDim )) * 2 - 1 def testShapeFunctionDerivatives ( self , n = 10 , rng = None ): \"\"\"Test the implementation of the shape function derivatives using the complex-step method Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" paramCoords = self . getRandParamCoord ( n , rng = rng ) coordPert = np . zeros_like ( paramCoords , dtype = \"complex128\" ) dN = self . computeShapeFunctionGradients ( paramCoords ) dNApprox = np . zeros_like ( dN ) for i in range ( self . numDim ): np . copyto ( coordPert , paramCoords ) coordPert [:, i ] += 1e-200 * 1 j dNApprox [:, i , :] = 1e200 * np . imag ( self . computeShapeFunctions ( coordPert )) return dN - dNApprox def testShapeFunctionSum ( self , n = 10 , rng = None ): \"\"\"Test the basic property that shape function values should sum to 1 everywhere within an element Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" paramCoords = self . getRandParamCoord ( n , rng = rng ) N = self . computeShapeFunctions ( paramCoords ) return np . sum ( N , axis = 1 ) def testInterpolation ( self , n = 10 , rng = None ): \"\"\"Validate that, when the element geometry matches the reference element exactly, the parametric and real coordinates are the same Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getReferenceElementCoordinates () paramCoords = self . getRandParamCoord ( n , rng = rng ) error = np . zeros (( n , self . numDim )) x = self . computeCoordinates ( paramCoords , nodeCoords ) error = x - paramCoords return error def testIdentityJacobian ( self , n = 10 , rng = None ): \"\"\"Validate that, when the element geometry matches the reference element exactly, the mapping Jacobian is the identity matrix everywhere. Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getReferenceElementCoordinates () paramCoords = self . getRandParamCoord ( n , rng = rng ) # The expected Jacobians are a stack of n identity matrices expectedJacs = np . tile ( np . eye ( self . numDim ), ( 1 , n , 1 , 1 )) Jacs = self . computeJacobians ( paramCoords , nodeCoords ) return Jacs - expectedJacs def testStateGradient ( self , n = 10 , rng = None ): \"\"\"Test that the state gradient is correctly reconstructed within the element This test works by generating random node coordinates, then computing the states at each node using the following equation: u_i = a_i * x + b_i * y + c_i * z + d_i This field has a gradient, du/dx, of [a_i, b_i, c_i] everywhere in the element, which should be exactly reproduced by the state gradient computed by the element. Parameters ---------- n : int, optional _description_, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getRandomElementCoordinates ( rng = rng ) paramCoords = self . getRandParamCoord ( n , rng = rng ) randStateGradient = rng . random (( self . numStates , self . numDim )) ExpectedStateGradients = np . tile ( randStateGradient , ( 1 , n , 1 , 1 )) nodeStates = np . zeros (( 1 , self . numNodes , self . numStates )) for ii in range ( self . numNodes ): for jj in range ( self . numStates ): nodeStates [:, ii , jj ] = np . dot ( nodeCoords [ 0 , ii ], randStateGradient [ jj ]) stateGradient = self . computeStateGradients ( paramCoords , nodeStates , nodeCoords ) return stateGradient - ExpectedStateGradients def testGetClosestPoints ( self , n = 10 , tol = 1e-10 , rng = None ): \"\"\"Test the getClosestPoints method This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getClosestPoints match the original random values. Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getRandomElementCoordinates ( rng = rng ) paramCoords = self . getRandParamCoord ( n , rng = rng ) realCoords = self . computeCoordinates ( paramCoords , nodeCoords ) error = np . zeros_like ( realCoords ) for i in range ( n ): coords , _ = self . getClosestPoints ( nodeCoords , realCoords [ 0 , i ], tol = tol ) error [ 0 , i ] = coords - paramCoords [ i ] return error","title":"Element Base Class"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.jacDet","text":"","title":"jacDet"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.jacInv","text":"","title":"jacInv"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.name","text":"","title":"name"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.numDOF","text":"","title":"numDOF"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.numDim","text":"","title":"numDim"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.numNodes","text":"","title":"numNodes"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.numStates","text":"","title":"numStates"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.paramCoordLinearConstaintLowerBounds","text":"","title":"paramCoordLinearConstaintLowerBounds"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.paramCoordLinearConstaintMat","text":"","title":"paramCoordLinearConstaintMat"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.paramCoordLinearConstaintUpperBounds","text":"","title":"paramCoordLinearConstaintUpperBounds"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.paramCoordLowerBounds","text":"","title":"paramCoordLowerBounds"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.paramCoordUpperBounds","text":"","title":"paramCoordUpperBounds"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.quadratureOrder","text":"","title":"quadratureOrder"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.__init__","text":"Instantiate an element object Parameters: Name Type Description Default numNodes int Number of nodes in the element required numDim int Number of spatial dimensions the element lives in required quadratureOrder int Integration quadrature order required numStates int , optional Number of states in the underlying PDE, a.k.a the number of DOF per node, by default uses numDim None Source code in FEMpy/Elements/Element.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __init__ ( self , numNodes , numDim , quadratureOrder , numStates = None ): \"\"\"Instantiate an element object Parameters ---------- numNodes : int Number of nodes in the element numDim : int Number of spatial dimensions the element lives in quadratureOrder : int Integration quadrature order numStates : int, optional Number of states in the underlying PDE, a.k.a the number of DOF per node, by default uses numDim \"\"\" self . numNodes = numNodes self . numDim = numDim self . numStates = numStates if numStates is not None else numDim self . numDOF = self . numNodes * self . numStates self . quadratureOrder = quadratureOrder self . name = f \" { self . numNodes } Node- { self . numStates } Disp- { self . numDim } D-Element\" # --- Parametric coordinate bounds --- # By default it is assumed that the parametric coordinates are in the range [-1, 1] in each dimension, for # elements where this is not true (e.g a 2d triangular element), these attributes should be overwritten self . paramCoordLowerBounds = - np . ones ( self . numDim ) self . paramCoordUpperBounds = np . ones ( self . numDim ) self . paramCoordLinearConstaintMat = None self . paramCoordLinearConstaintUpperBounds = None self . paramCoordLinearConstaintLowerBounds = None # --- Define fast jacobian determinant function based on number of dimensions --- if self . numDim == 1 : self . jacDet = det1 self . jacInv = inv1 elif self . numDim == 2 : self . jacDet = det2 self . jacInv = inv2 elif self . numDim == 3 : self . jacDet = det3 self . jacInv = inv3 if self . numDim not in [ 1 , 2 , 3 ]: raise ValueError ( f \"Sorry, FEMpy doesn't support { self . numDim } -dimensional problems\" )","title":"__init__()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeCoordinates","text":"Given nodal coordinates, compute the real coordinates at given parametric coordinates within the element Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to compute real coordinates of required nodeCoords numElements x numNodes x numDim array Node coordinates for each element required Source code in FEMpy/Elements/Element.py 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 def computeCoordinates ( self , paramCoords , nodeCoords ): \"\"\"Given nodal coordinates, compute the real coordinates at given parametric coordinates within the element Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute real coordinates of nodeCoords : numElements x numNodes x numDim array Node coordinates for each element \"\"\" # Compute shape functions at the given parametric coordinates N = self . computeShapeFunctions ( paramCoords ) # Then for each element, compute the states at the points, the einsum below is equivalent to: # product = np.zeros((numElements, numPoints, numStates)) # for ii in range(numElements): # product[ii] = N[:, : self.numNodes] @ nodeStates[ii] return _interpolationProduct ( N [:, : self . numNodes ], nodeCoords )","title":"computeCoordinates()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeFunction","text":"Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element Parameters: Name Type Description Default nodeCoords numElements x numNodes x numDim array Node coordinates for each element required nodeStates numElements x numNodes x numStates array State values at the nodes of each element required elementDVs dict of numElement length arrays Design variable values for each element required function callable Function to evaluate at each point within each element, must have signature f(x, u, u', dvs), where: x is an n x numDim array of coordinates u is an n x numStates array of state values u' is an n x (numStates*numDim) array of state gradients dvs is an n x numDVs array of design variable values required elementReductionType _type_ Type of reduction to do to get a single value for each element, can be: - 'sum' : sum all values - 'mean' : average all values - integrate : integrate the function over the element - 'max' : take the maximum value - 'min' : take the minimum value - 'ksmax' : Compute a smooth approximation of the maximum value using KS aggregation - 'ksmin' : Compute a smooth approximation of the minimum value using KS aggregation required Returns: Name Type Description values numElements array Value of the function for each element Source code in FEMpy/Elements/Element.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def computeFunction ( self , nodeCoords , nodeStates , elementDVs , function , elementReductionType , intOrder = None ): \"\"\"Given a function that can depend on true coordinates, the state, state gradients and some design variables, compute the value of that function over the element Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element elementDVs : dict of numElement length arrays Design variable values for each element function : callable Function to evaluate at each point within each element, must have signature f(x, u, u', dvs), where: x is an n x numDim array of coordinates u is an n x numStates array of state values u' is an n x (numStates*numDim) array of state gradients dvs is an n x numDVs array of design variable values elementReductionType : _type_ Type of reduction to do to get a single value for each element, can be: - 'sum' : sum all values - 'mean' : average all values - `integrate` : integrate the function over the element - 'max' : take the maximum value - 'min' : take the minimum value - 'ksmax' : Compute a smooth approximation of the maximum value using KS aggregation - 'ksmin' : Compute a smooth approximation of the minimum value using KS aggregation Returns ------- values : numElements array Value of the function for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , elementDVs , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"DVs\" , \"JacDet\" ], ) values = function ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) values = values . reshape (( numElements , numIntPoints )) # perform element reduction if specified if elementReductionType is not None : assert elementReductionType . lower () in [ \"sum\" , \"mean\" , \"integrate\" , \"min\" , \"max\" , \"ksmax\" , \"ksmin\" , ], \"elementReductionType not valid\" # Simple numpy reductions if elementReductionType . lower () in [ \"sum\" , \"mean\" , \"min\" , \"max\" ]: if elementReductionType . lower () == \"sum\" : reductFunc = np . sum if elementReductionType . lower () == \"mean\" : reductFunc = np . average if elementReductionType . lower () == \"min\" : reductFunc = np . min if elementReductionType . lower () == \"max\" : reductFunc = np . max return reductFunc ( values , axis = 1 ) if elementReductionType . lower () == \"integrate\" : # compute integration using weighted sum of w*values*detJ over each set of element points pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) return np . einsum ( \"ep,ep,p->e\" , values , pointQuantities [ \"JacDet\" ], intPointWeights , optimize = [ \"einsum_path\" , ( 0 , 1 ), ( 0 , 1 )], ) if elementReductionType . lower () in [ \"ksmax\" , \"ksmin\" ]: reducedValues = np . zeros ( numElements ) for i in range ( numElements ): reducedValues [ i ] = ksAgg ( values [ i , :], \"max\" ) return reducedValues if elementReductionType . lower () == \"ksmin\" : reducedValues = np . zeros ( numElements ) for i in range ( numElements ): reducedValues [ i ] = ksAgg ( values [ i , :], \"min\" ) return reducedValues return values","title":"computeFunction()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeJacobians","text":"Compute the Jacobian at a set of parametric coordinates within a set of elements This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to compute Jacobians at required nodeCoords numElements x numNodes x numDim array Node coordinates for each element required Returns: Name Type Description Jac numElements x numPoints x numDim x numDim array The Jacobians at each point in each element Source code in FEMpy/Elements/Element.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def computeJacobians ( self , paramCoords , nodeCoords ): \"\"\"Compute the Jacobian at a set of parametric coordinates within a set of elements This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute Jacobians at nodeCoords : numElements x numNodes x numDim array Node coordinates for each element Returns ------- Jac : numElements x numPoints x numDim x numDim array The Jacobians at each point in each element \"\"\" NPrimeParam = self . computeShapeFunctionGradients ( paramCoords ) # numPoints x numDim x numNodes numElements = nodeCoords . shape [ 0 ] numPoints = paramCoords . shape [ 0 ] Jac = np . zeros (( numElements , numPoints , self . numDim , self . numDim )) nodeCoords = np . ascontiguousarray ( nodeCoords ) # The function call below does the following: # for ii in range(numElements): # for jj in range(numPoints): # Jac[ii, jj] = NPrimeParam[jj] @ nodeCoords[ii] _computeNPrimeCoordProduct ( NPrimeParam , nodeCoords , Jac ) return Jac","title":"computeJacobians()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeResidualJacobians","text":"Given node coordinates and states, design variable values, and a constitutive model, compute the residual Jacobian for a bunch of elements Parameters: Name Type Description Default nodeCoords numElements x numNodes x numDim array Node coordinates for each element required nodeStates numElements x numNodes x numStates array State values at the nodes of each element required designVars dict of numElements arrays Design variable values for each element required constitutiveModel FEMpy constitutive model object The constitutive model of the element required Returns: Type Description numElement x (numNodes The local residual Jacobian matrix for each element Source code in FEMpy/Elements/Element.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 def computeResidualJacobians ( self , nodeStates , nodeCoords , designVars , constitutiveModel , intOrder = None ): \"\"\"Given node coordinates and states, design variable values, and a constitutive model, compute the residual Jacobian for a bunch of elements Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element designVars : dict of numElements arrays Design variable values for each element constitutiveModel : FEMpy constitutive model object The constitutive model of the element Returns ------- numElement x (numNodes * numStates) x (numNodes * numStates) array The local residual Jacobian matrix for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , designVars , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"JacDet\" , \"StateGradSens\" , \"DVs\" ], ) # Compute the weak residual Jacobians, dr/du' weakJacs = constitutiveModel . computeWeakResidualJacobian ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) # Compute dr/dq = du'/dq^T * dr/du' * du'/dq # Jacs = np.einsum( # \"pdn,pdsSD,pDN->pnsNS\", # pointQuantities[\"StateGradSens\"], # weakJacs, # pointQuantities[\"StateGradSens\"], # optimize=[\"einsum_path\", (0, 2), (0, 1)], # ) Jacs = np . zeros (( numElements * numIntPoints , self . numNodes , self . numStates , self . numNodes , self . numStates )) _transformResidualJacobians ( pointQuantities [ \"StateGradSens\" ], weakJacs , Jacs ) Jacs = Jacs . reshape (( numElements , numIntPoints , self . numNodes , self . numStates , self . numNodes , self . numStates )) pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) # - Compute R, weighted sum of w * r * detJ over each set of integration points dRdq = np . zeros (( numElements , self . numNodes , self . numStates , self . numNodes , self . numStates )) _integrate ( Jacs , pointQuantities [ \"JacDet\" ], intPointWeights , dRdq ) return dRdq . reshape (( numElements , self . numDOF , self . numDOF ))","title":"computeResidualJacobians()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeResiduals","text":"Compute the local residual for a series of elements Parameters: Name Type Description Default nodeCoords numElements x numNodes x numDim array Node coordinates for each element required nodeStates numElements x numNodes x numStates array State values at the nodes of each element required designVars dict of numElements arrays Design variable values for each element required constitutiveModel FEMpy constitutive model object The constitutive model of the element required Returns: Type Description numElement x numNodes x numStates array The local residuals for each element Source code in FEMpy/Elements/Element.py 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def computeResiduals ( self , nodeStates , nodeCoords , designVars , constitutiveModel , intOrder = None ): \"\"\"Compute the local residual for a series of elements Parameters ---------- nodeCoords : numElements x numNodes x numDim array Node coordinates for each element nodeStates : numElements x numNodes x numStates array State values at the nodes of each element designVars : dict of numElements arrays Design variable values for each element constitutiveModel : FEMpy constitutive model object The constitutive model of the element Returns ------- numElement x numNodes x numStates array The local residuals for each element \"\"\" numElements = nodeCoords . shape [ 0 ] nodeCoords = np . ascontiguousarray ( nodeCoords ) nodeStates = np . ascontiguousarray ( nodeStates ) # - Get integration point parametric coordinates and weights (same for all elements of same type) intOrder = self . quadratureOrder if intOrder is None else intOrder intPointWeights = self . getIntegrationPointWeights ( intOrder ) # numIntPoints intPointParamCoords = self . getIntegrationPointCoords ( intOrder ) # numIntPoints x numDim numIntPoints = len ( intPointWeights ) # Get the quantities we need for the weak residual evaluation at the integration points for each element pointQuantities = self . _computeFunctionEvaluationQuantities ( intPointParamCoords , nodeStates , nodeCoords , designVars , quantities = [ \"Coord\" , \"State\" , \"StateGrad\" , \"JacDet\" , \"StateGradSens\" , \"DVs\" ], ) weakRes = constitutiveModel . computeWeakResiduals ( pointQuantities [ \"State\" ], pointQuantities [ \"StateGrad\" ], pointQuantities [ \"Coord\" ], pointQuantities [ \"DVs\" ] ) # - Compute r = du'/dq^T * f r = np . zeros (( numElements * numIntPoints , self . numNodes , self . numStates )) _transformResidual ( pointQuantities [ \"StateGradSens\" ], weakRes , r ) r = r . reshape (( numElements , numIntPoints , self . numNodes , self . numStates )) pointQuantities [ \"JacDet\" ] = pointQuantities [ \"JacDet\" ] . reshape (( numElements , numIntPoints )) # - Compute R, weighted sum of w * r * detJ over each set of integration points # R = np.einsum( # \"epns,ep,p->ens\", r, pointQuantities[\"JacDet\"], intPointWeights, optimize=[\"einsum_path\", (1, 2), (0, 1)] # ) R = np . zeros (( numElements , self . numNodes , self . numStates )) _integrate ( r , pointQuantities [ \"JacDet\" ], intPointWeights , R ) return R","title":"computeResiduals()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeShapeFunctionGradients","text":"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at required Returns: Name Type Description NPrimeParam numPoint x numDim x numNodes array Shape function gradient values, NPrimeParam i [k] is the derivative of the kth shape function at the ith point w.r.t the jth parametric coordinate Source code in FEMpy/Elements/Element.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @abc . abstractmethod def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NPrimeParam: numPoint x numDim x numNodes array Shape function gradient values, NPrimeParam[i][j][k] is the derivative of the kth shape function at the ith point w.r.t the jth parametric coordinate \"\"\" raise NotImplementedError","title":"computeShapeFunctionGradients()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeShapeFunctions","text":"Compute the shape function values at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at required Returns: Name Type Description N numPoint x numNodes array Array of shape function values at the given parametric coordinates, N i is the value of the jth shape function at the ith parametric point Source code in FEMpy/Elements/Element.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @abc . abstractmethod def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" raise NotImplementedError","title":"computeShapeFunctions()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeStateGradients","text":"Given nodal DOF, compute the gradient of the state at given parametric coordinates within the element The gradient of the state at each point in each element is a numStates x numDim array. This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to compute state at required nodeStates numElements x numNodes x numStates array State values at the nodes of each element required nodeCoords numElements x numNodes x numDim array Node coordinates for each element required Returns: Name Type Description stateGradients numElements x numPoint x numStates x numDim array The gradient of the states at each point in each element, stateGradient[i, j, k, l] is the value of \\(du_k/dx_l\\) at the \\(j^{th}\\) point in the \\(i^{th}\\) element Source code in FEMpy/Elements/Element.py 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 def computeStateGradients ( self , paramCoords , nodeStates , nodeCoords ): \"\"\"Given nodal DOF, compute the gradient of the state at given parametric coordinates within the element The gradient of the state at each point in each element is a numStates x numDim array. This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute state at nodeStates : numElements x numNodes x numStates array State values at the nodes of each element nodeCoords : numElements x numNodes x numDim array Node coordinates for each element Returns ------- stateGradients : numElements x numPoint x numStates x numDim array The gradient of the states at each point in each element, stateGradient[i, j, k, l] is the value of $du_k/dx_l$ at the $j^{th}$ point in the $i^{th}$ element \"\"\" numElements = nodeCoords . shape [ 0 ] numPoints = paramCoords . shape [ 0 ] NPrimeParam = self . computeShapeFunctionGradients ( paramCoords ) Jac = np . zeros (( numElements , numPoints , self . numDim , self . numDim )) _computeNPrimeCoordProduct ( NPrimeParam , nodeCoords , Jac ) JacInv = self . jacInv ( np . reshape ( Jac , ( numElements * numPoints , self . numDim , self . numDim ))) JacInv = np . reshape ( JacInv , ( numElements , numPoints , self . numDim , self . numDim )) UPrime = np . zeros (( numElements , numPoints , self . numStates , self . numDim )) # The function call below is equivalent to the following # for ii in range(numElements): # for jj in range(numPoints): # result[ii, jj] = (JacInv[ii, jj] @ NPrimeParam[jj] @ nodeStates[ii]).T _computeUPrimeProduct ( JacInv , NPrimeParam , np . ascontiguousarray ( nodeStates ), UPrime ) return UPrime","title":"computeStateGradients()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.computeStates","text":"Given nodal DOF, compute the state at given parametric coordinates within the element This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to compute state at required nodeStates numElements x numNodes x numStates array State values at the nodes of each element required Returns: Name Type Description states numElements x numPoint x numStates array State values at the given parametric coordinates for each element Source code in FEMpy/Elements/Element.py 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 def computeStates ( self , paramCoords , nodeStates ): \"\"\"Given nodal DOF, compute the state at given parametric coordinates within the element This function is vectorised both across multiple elements, and multiple points within each element, but the parametric coordinates are assumed to be the same across all elements Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to compute state at nodeStates : numElements x numNodes x numStates array State values at the nodes of each element Returns ------- states : numElements x numPoint x numStates array State values at the given parametric coordinates for each element \"\"\" # Compute shape functions at the given parametric coordinates N = self . computeShapeFunctions ( paramCoords ) # Then for each element, compute the states at the points, the einsum below is equivalent to: # product = np.zeros((numElements, numPoints, numStates)) # for ii in range(numElements): # product[ii] = N @ nodeStates[ii] return _interpolationProduct ( N , nodeStates )","title":"computeStates()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getClosestPoints","text":"Given real coordinates of a point, find the parametric coordinates of the closest point on a series of elements to that point Computing the closest point is an optimization problem of the form: min ||X(x) - P||^2 s.t Ax <= b lb <= x <= ub Where X are the real coordinates of a point in the element, x the parametric coordinates of that point, and P is the target point. lb <= x <= ub and Ax <= b are a set of bounds and linear constraints on the parametric coordinates that encode the bounds of the element. Parameters: Name Type Description Default nodeCoords numElements x numNodes x numDim array The coordinates of the elements required point array of length numDim Target point coordinates required Returns: Name Type Description closestParamCoords numElements x numDim array The parametric coordinates of the closest point in each element closestDistances numElements array The distances from the closest point in each element to the target point Source code in FEMpy/Elements/Element.py 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 def getClosestPoints ( self , nodeCoords , point , ** kwargs ): \"\"\"Given real coordinates of a point, find the parametric coordinates of the closest point on a series of elements to that point Computing the closest point is an optimization problem of the form: min ||X(x) - P||^2 s.t Ax <= b lb <= x <= ub Where X are the real coordinates of a point in the element, x the parametric coordinates of that point, and P is the target point. lb <= x <= ub and Ax <= b are a set of bounds and linear constraints on the parametric coordinates that encode the bounds of the element. Parameters ---------- nodeCoords : numElements x numNodes x numDim array The coordinates of the elements point : array of length numDim Target point coordinates Returns ------- closestParamCoords : numElements x numDim array The parametric coordinates of the closest point in each element closestDistances : numElements array The distances from the closest point in each element to the target point \"\"\" numElements = nodeCoords . shape [ 0 ] closestDistances = np . zeros ( numElements ) closestParamCoords = np . zeros (( numElements , self . numDim )) paramCoordBounds = Bounds ( lb = self . paramCoordLowerBounds , ub = self . paramCoordUpperBounds ) if self . paramCoordLinearConstaintMat is not None : paramCoordLinearConstraints = LinearConstraint ( self . paramCoordLinearConstaintMat , self . paramCoordLinearConstaintLowerBounds , self . paramCoordLinearConstaintUpperBounds , keep_feasible = True , ) else : paramCoordLinearConstraints = None for ii in range ( numElements ): closestParamCoords [ ii ], closestDistances [ ii ] = self . _getClosestPoint ( nodeCoords [ ii ], point , paramCoordBounds , paramCoordLinearConstraints , ** kwargs ) return closestParamCoords , closestDistances","title":"getClosestPoints()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getIntegrationPointCoords","text":"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters: Name Type Description Default order int , optional Integration order None Returns: Type Description numIntpoint x numDim array Integration point coordinates Source code in FEMpy/Elements/Element.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @abc . abstractmethod def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int, optional Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" raise NotImplementedError","title":"getIntegrationPointCoords()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getIntegrationPointWeights","text":"Compute the integration point weights for a given quadrature order on this element Parameters: Name Type Description Default order int , optional Integration order None Returns: Type Description array of length numIntpoint Integration point weights Source code in FEMpy/Elements/Element.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 @abc . abstractmethod def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int, optional Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" raise NotImplementedError","title":"getIntegrationPointWeights()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getRandParamCoord","text":"Get a random set of parametric coordinates within the element By default this method assumes the the valid parametric coordinates are between -1 and 1 in each direction. If this is not the case for a particular element then that element should reimplemnt this method. Parameters: Name Type Description Default n int Number of points to generate required rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 def getRandParamCoord ( self , n , rng = None ): \"\"\"Get a random set of parametric coordinates within the element By default this method assumes the the valid parametric coordinates are between -1 and 1 in each direction. If this is not the case for a particular element then that element should reimplemnt this method. Parameters ---------- n : int Number of points to generate rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () return rng . random (( n , self . numDim )) * 2 - 1","title":"getRandParamCoord()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getRandomElementCoordinates","text":"Compute random node coordinates for an element The random node coordinates are computed by taking the reference element coordinates and then applying: - Random perturbations to each node - Random translation in each dimension - Random scalings in each dimension - Random rotations around each available axis Parameters: Name Type Description Default rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 def getRandomElementCoordinates ( self , rng = None ): \"\"\"Compute random node coordinates for an element The random node coordinates are computed by taking the reference element coordinates and then applying: - Random perturbations to each node - Random translation in each dimension - Random scalings in each dimension - Random rotations around each available axis Parameters ---------- rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () coords = self . getReferenceElementCoordinates () # numNodes x numDim array # Perturb coordinates by up to 10% of the maximum distance between any two nodes maxDistance , _ = _computeMaxMinDistance ( coords ) coords += rng . random ( coords . shape ) * 0.1 * maxDistance # Apply random translation for ii in range ( self . numDim ): translation = rng . random () * 2 * maxDistance - maxDistance coords [:, ii ] += translation # Scale each dimension by a random factor between 0.1 and 10 for dim in range ( self . numDim ): scalingPower = rng . random () * 2 - 1 coords [:, dim ] *= 10 ** scalingPower # Rotate the element around each axis by a random angle if self . numDim == 2 : angle = rng . random () * 4 * np . pi - 2 * np . pi c , s = np . cos ( angle ), np . sin ( angle ) R = np . array ((( c , s ), ( - s , c ))) coords = coords @ R . T elif self . numDim == 3 : R = Rotation . random ( random_state = rng ) coords = coords @ R . as_matrix () . T return coords","title":"getRandomElementCoordinates()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.getReferenceElementCoordinates","text":"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns: Type Description numNodes x numDim array Element node coordinates Source code in FEMpy/Elements/Element.py 149 150 151 152 153 154 155 156 157 158 @abc . abstractmethod def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns ------- numNodes x numDim array Element node coordinates \"\"\" raise NotImplementedError","title":"getReferenceElementCoordinates()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testGetClosestPoints","text":"Test the getClosestPoints method This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getClosestPoints match the original random values. Parameters: Name Type Description Default n int , optional Number of random coordinates to generate, by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 def testGetClosestPoints ( self , n = 10 , tol = 1e-10 , rng = None ): \"\"\"Test the getClosestPoints method This test works by generating a set of random parametric coordinates, converting them to real coordinates, and then checking that the parametric coordinates returned by getClosestPoints match the original random values. Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getRandomElementCoordinates ( rng = rng ) paramCoords = self . getRandParamCoord ( n , rng = rng ) realCoords = self . computeCoordinates ( paramCoords , nodeCoords ) error = np . zeros_like ( realCoords ) for i in range ( n ): coords , _ = self . getClosestPoints ( nodeCoords , realCoords [ 0 , i ], tol = tol ) error [ 0 , i ] = coords - paramCoords [ i ] return error","title":"testGetClosestPoints()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testIdentityJacobian","text":"Validate that, when the element geometry matches the reference element exactly, the mapping Jacobian is the identity matrix everywhere. Parameters: Name Type Description Default n int , optional Number of points to test at, by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 def testIdentityJacobian ( self , n = 10 , rng = None ): \"\"\"Validate that, when the element geometry matches the reference element exactly, the mapping Jacobian is the identity matrix everywhere. Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getReferenceElementCoordinates () paramCoords = self . getRandParamCoord ( n , rng = rng ) # The expected Jacobians are a stack of n identity matrices expectedJacs = np . tile ( np . eye ( self . numDim ), ( 1 , n , 1 , 1 )) Jacs = self . computeJacobians ( paramCoords , nodeCoords ) return Jacs - expectedJacs","title":"testIdentityJacobian()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testInterpolation","text":"Validate that, when the element geometry matches the reference element exactly, the parametric and real coordinates are the same Parameters: Name Type Description Default n int , optional Number of points to test at, by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 def testInterpolation ( self , n = 10 , rng = None ): \"\"\"Validate that, when the element geometry matches the reference element exactly, the parametric and real coordinates are the same Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getReferenceElementCoordinates () paramCoords = self . getRandParamCoord ( n , rng = rng ) error = np . zeros (( n , self . numDim )) x = self . computeCoordinates ( paramCoords , nodeCoords ) error = x - paramCoords return error","title":"testInterpolation()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testShapeFunctionDerivatives","text":"Test the implementation of the shape function derivatives using the complex-step method Parameters: Name Type Description Default n int , optional Number of random coordinates to generate, by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 def testShapeFunctionDerivatives ( self , n = 10 , rng = None ): \"\"\"Test the implementation of the shape function derivatives using the complex-step method Parameters ---------- n : int, optional Number of random coordinates to generate, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" paramCoords = self . getRandParamCoord ( n , rng = rng ) coordPert = np . zeros_like ( paramCoords , dtype = \"complex128\" ) dN = self . computeShapeFunctionGradients ( paramCoords ) dNApprox = np . zeros_like ( dN ) for i in range ( self . numDim ): np . copyto ( coordPert , paramCoords ) coordPert [:, i ] += 1e-200 * 1 j dNApprox [:, i , :] = 1e200 * np . imag ( self . computeShapeFunctions ( coordPert )) return dN - dNApprox","title":"testShapeFunctionDerivatives()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testShapeFunctionSum","text":"Test the basic property that shape function values should sum to 1 everywhere within an element Parameters: Name Type Description Default n int , optional Number of points to test at, by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def testShapeFunctionSum ( self , n = 10 , rng = None ): \"\"\"Test the basic property that shape function values should sum to 1 everywhere within an element Parameters ---------- n : int, optional Number of points to test at, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" paramCoords = self . getRandParamCoord ( n , rng = rng ) N = self . computeShapeFunctions ( paramCoords ) return np . sum ( N , axis = 1 )","title":"testShapeFunctionSum()"},{"location":"Elements/Element/#FEMpy.Elements.Element.Element.testStateGradient","text":"Test that the state gradient is correctly reconstructed within the element This test works by generating random node coordinates, then computing the states at each node using the following equation: u_i = a_i * x + b_i * y + c_i * z + d_i This field has a gradient, du/dx, of [a_i, b_i, c_i] everywhere in the element, which should be exactly reproduced by the state gradient computed by the element. Parameters: Name Type Description Default n int , optional description , by default 10 10 rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Source code in FEMpy/Elements/Element.py 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 def testStateGradient ( self , n = 10 , rng = None ): \"\"\"Test that the state gradient is correctly reconstructed within the element This test works by generating random node coordinates, then computing the states at each node using the following equation: u_i = a_i * x + b_i * y + c_i * z + d_i This field has a gradient, du/dx, of [a_i, b_i, c_i] everywhere in the element, which should be exactly reproduced by the state gradient computed by the element. Parameters ---------- n : int, optional _description_, by default 10 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call \"\"\" if rng is None : rng = np . random . default_rng () nodeCoords = np . zeros (( 1 , self . numNodes , self . numDim )) nodeCoords [ 0 ] = self . getRandomElementCoordinates ( rng = rng ) paramCoords = self . getRandParamCoord ( n , rng = rng ) randStateGradient = rng . random (( self . numStates , self . numDim )) ExpectedStateGradients = np . tile ( randStateGradient , ( 1 , n , 1 , 1 )) nodeStates = np . zeros (( 1 , self . numNodes , self . numStates )) for ii in range ( self . numNodes ): for jj in range ( self . numStates ): nodeStates [:, ii , jj ] = np . dot ( nodeCoords [ 0 , ii ], randStateGradient [ jj ]) stateGradient = self . computeStateGradients ( paramCoords , nodeStates , nodeCoords ) return stateGradient - ExpectedStateGradients","title":"testStateGradient()"},{"location":"Elements/Hex3D/","text":"3D Hex Element Bases: Element An \"arbitrary order\" 3d hexahedral finite element Like the QuadElement2D, the arbitrary order bit is in quotes because I have not figured out how to do the node reordering from the shape function ordering to the node ordering used by MeshIO for anything more than 2 nd order hex elements yet Inherits from Element : FEMpy Element class The base FEMpy element class Source code in FEMpy/Elements/HexElement3D.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 class HexElement3D ( Element ): \"\"\"An \"arbitrary order\" 3d hexahedral finite element Like the QuadElement2D, the arbitrary order bit is in quotes because I have not figured out how to do the node reordering from the shape function ordering to the node ordering used by MeshIO for anything more than 2nd order hex elements yet Inherits from ------------- Element : FEMpy Element class The base FEMpy element class \"\"\" def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 3d hexahedral finite element object Parameters ---------- order : int, optional Element order, a first order hex has 6 nodes, 2nd order 27 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 3 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 ]: raise ValueError ( \"Hex elements only support orders 1 and 2\" ) self . order = order numNodes = ( order + 1 ) ** 3 if quadratureOrder is None : shapeFuncOrder = 2 * order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 3 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeHex\" self . shapeFuncToNodeOrder = self . _getNodeReordering ( self . order ) # ============================================================================== # Public methods # ============================================================================== def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" N = LP . LagrangePoly3d ( paramCoords [:, 0 ], paramCoords [:, 1 ], paramCoords [:, 2 ], self . order + 1 ) return np . ascontiguousarray ( N [:, self . shapeFuncToNodeOrder ]) def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" NPrimeParam = LP . LagrangePoly3dDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], paramCoords [:, 2 ], self . order + 1 ) return np . ascontiguousarray ( NPrimeParam [:, :, self . shapeFuncToNodeOrder ]) def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadWeights ( self . numDim , order ) def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadPoints ( self . numDim , order ) def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns ------- numNodes x numDim array Element node coordinates \"\"\" numPoints = self . order + 1 p = np . linspace ( - 1 , 1 , numPoints ) x = np . tile ( p , numPoints ** 2 ) y = np . tile ( np . repeat ( p , numPoints ), numPoints ) z = np . repeat ( p , numPoints ** 2 ) return np . vstack (( x [ self . shapeFuncToNodeOrder ], y [ self . shapeFuncToNodeOrder ], z [ self . shapeFuncToNodeOrder ])) . T # ============================================================================== # Private methods # ============================================================================== @staticmethod def _getNodeReordering ( order ): \"\"\"Compute the reordering required between shape functions and nodes The 23d lagrange polynomial shape functions are ordered left to right, front to back and then bottom to top, but the node ordering is defined differently in finite element meshes. This method computes the reordering required to map the shape functions to the correct node ordering. As of now I have simply manually implemented this for the first few orders, but it should be possible to compute this for any order with some sort of recursion. Parameters ---------- order : int Quad element order Returns ------- np.array Reordering array, array[i] = j indicates that the ith shape function should be reordered to the jth node \"\"\" if order == 1 : return np . array ([ 0 , 1 , 3 , 2 , 4 , 5 , 7 , 6 ]) if order == 2 : return np . array ( [ 0 , 2 , 8 , 6 , 18 , 20 , 26 , 24 , 1 , 5 , 7 , 3 , 19 , 23 , 25 , 21 , 9 , 11 , 17 , 15 , 12 , 14 , 10 , 16 , 4 , 22 , 13 ] ) name = f 'Order { self . order } -LagrangeHex' instance-attribute order = order instance-attribute shapeFuncToNodeOrder = self . _getNodeReordering ( self . order ) instance-attribute __init__ ( order = 1 , numStates = None , quadratureOrder = None ) Create a new 3d hexahedral finite element object Parameters: Name Type Description Default order int , optional Element order, a first order hex has 6 nodes, 2 nd order 27 etc, currently only orders 1-3 are supported, by default 1 1 numStates int , optional Number of states in the underlying PDE, by default 3 None quadratureOrder int , optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used None Raises: Type Description ValueError Raises error if order is not 1, 2 or 3 Source code in FEMpy/Elements/HexElement3D.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 3d hexahedral finite element object Parameters ---------- order : int, optional Element order, a first order hex has 6 nodes, 2nd order 27 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 3 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 ]: raise ValueError ( \"Hex elements only support orders 1 and 2\" ) self . order = order numNodes = ( order + 1 ) ** 3 if quadratureOrder is None : shapeFuncOrder = 2 * order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 3 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeHex\" self . shapeFuncToNodeOrder = self . _getNodeReordering ( self . order ) computeShapeFunctionGradients ( paramCoords ) Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at required Returns: Name Type Description NGrad numPoint x numDim x numNodes array Shape function gradient values, NGrad i [k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate Source code in FEMpy/Elements/HexElement3D.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" NPrimeParam = LP . LagrangePoly3dDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], paramCoords [:, 2 ], self . order + 1 ) return np . ascontiguousarray ( NPrimeParam [:, :, self . shapeFuncToNodeOrder ]) computeShapeFunctions ( paramCoords ) Compute the shape function values at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at required Returns: Name Type Description N numPoint x numNodes array Array of shape function values at the given parametric coordinates, N i is the value of the jth shape function at the ith parametric point Source code in FEMpy/Elements/HexElement3D.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" N = LP . LagrangePoly3d ( paramCoords [:, 0 ], paramCoords [:, 1 ], paramCoords [:, 2 ], self . order + 1 ) return np . ascontiguousarray ( N [:, self . shapeFuncToNodeOrder ]) getIntegrationPointCoords ( order = None ) Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description numIntpoint x numDim array Integration point coordinates Source code in FEMpy/Elements/HexElement3D.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadPoints ( self . numDim , order ) getIntegrationPointWeights ( order = None ) Compute the integration point weights for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description array of length numIntpoint Integration point weights Source code in FEMpy/Elements/HexElement3D.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadWeights ( self . numDim , order ) getReferenceElementCoordinates () Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns: Type Description numNodes x numDim array Element node coordinates Source code in FEMpy/Elements/HexElement3D.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns ------- numNodes x numDim array Element node coordinates \"\"\" numPoints = self . order + 1 p = np . linspace ( - 1 , 1 , numPoints ) x = np . tile ( p , numPoints ** 2 ) y = np . tile ( np . repeat ( p , numPoints ), numPoints ) z = np . repeat ( p , numPoints ** 2 ) return np . vstack (( x [ self . shapeFuncToNodeOrder ], y [ self . shapeFuncToNodeOrder ], z [ self . shapeFuncToNodeOrder ])) . T","title":"3D Hex"},{"location":"Elements/Hex3D/#3d-hex-element","text":"Bases: Element An \"arbitrary order\" 3d hexahedral finite element Like the QuadElement2D, the arbitrary order bit is in quotes because I have not figured out how to do the node reordering from the shape function ordering to the node ordering used by MeshIO for anything more than 2 nd order hex elements yet","title":"3D Hex Element"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D--inherits-from","text":"Element : FEMpy Element class The base FEMpy element class Source code in FEMpy/Elements/HexElement3D.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 class HexElement3D ( Element ): \"\"\"An \"arbitrary order\" 3d hexahedral finite element Like the QuadElement2D, the arbitrary order bit is in quotes because I have not figured out how to do the node reordering from the shape function ordering to the node ordering used by MeshIO for anything more than 2nd order hex elements yet Inherits from ------------- Element : FEMpy Element class The base FEMpy element class \"\"\" def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 3d hexahedral finite element object Parameters ---------- order : int, optional Element order, a first order hex has 6 nodes, 2nd order 27 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 3 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 ]: raise ValueError ( \"Hex elements only support orders 1 and 2\" ) self . order = order numNodes = ( order + 1 ) ** 3 if quadratureOrder is None : shapeFuncOrder = 2 * order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 3 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeHex\" self . shapeFuncToNodeOrder = self . _getNodeReordering ( self . order ) # ============================================================================== # Public methods # ============================================================================== def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" N = LP . LagrangePoly3d ( paramCoords [:, 0 ], paramCoords [:, 1 ], paramCoords [:, 2 ], self . order + 1 ) return np . ascontiguousarray ( N [:, self . shapeFuncToNodeOrder ]) def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" NPrimeParam = LP . LagrangePoly3dDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], paramCoords [:, 2 ], self . order + 1 ) return np . ascontiguousarray ( NPrimeParam [:, :, self . shapeFuncToNodeOrder ]) def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadWeights ( self . numDim , order ) def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadPoints ( self . numDim , order ) def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns ------- numNodes x numDim array Element node coordinates \"\"\" numPoints = self . order + 1 p = np . linspace ( - 1 , 1 , numPoints ) x = np . tile ( p , numPoints ** 2 ) y = np . tile ( np . repeat ( p , numPoints ), numPoints ) z = np . repeat ( p , numPoints ** 2 ) return np . vstack (( x [ self . shapeFuncToNodeOrder ], y [ self . shapeFuncToNodeOrder ], z [ self . shapeFuncToNodeOrder ])) . T # ============================================================================== # Private methods # ============================================================================== @staticmethod def _getNodeReordering ( order ): \"\"\"Compute the reordering required between shape functions and nodes The 23d lagrange polynomial shape functions are ordered left to right, front to back and then bottom to top, but the node ordering is defined differently in finite element meshes. This method computes the reordering required to map the shape functions to the correct node ordering. As of now I have simply manually implemented this for the first few orders, but it should be possible to compute this for any order with some sort of recursion. Parameters ---------- order : int Quad element order Returns ------- np.array Reordering array, array[i] = j indicates that the ith shape function should be reordered to the jth node \"\"\" if order == 1 : return np . array ([ 0 , 1 , 3 , 2 , 4 , 5 , 7 , 6 ]) if order == 2 : return np . array ( [ 0 , 2 , 8 , 6 , 18 , 20 , 26 , 24 , 1 , 5 , 7 , 3 , 19 , 23 , 25 , 21 , 9 , 11 , 17 , 15 , 12 , 14 , 10 , 16 , 4 , 22 , 13 ] )","title":"Inherits from"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.name","text":"","title":"name"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.order","text":"","title":"order"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.shapeFuncToNodeOrder","text":"","title":"shapeFuncToNodeOrder"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.__init__","text":"Create a new 3d hexahedral finite element object Parameters: Name Type Description Default order int , optional Element order, a first order hex has 6 nodes, 2 nd order 27 etc, currently only orders 1-3 are supported, by default 1 1 numStates int , optional Number of states in the underlying PDE, by default 3 None quadratureOrder int , optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used None Raises: Type Description ValueError Raises error if order is not 1, 2 or 3 Source code in FEMpy/Elements/HexElement3D.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 3d hexahedral finite element object Parameters ---------- order : int, optional Element order, a first order hex has 6 nodes, 2nd order 27 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 3 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 ]: raise ValueError ( \"Hex elements only support orders 1 and 2\" ) self . order = order numNodes = ( order + 1 ) ** 3 if quadratureOrder is None : shapeFuncOrder = 2 * order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 3 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeHex\" self . shapeFuncToNodeOrder = self . _getNodeReordering ( self . order )","title":"__init__()"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.computeShapeFunctionGradients","text":"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at required Returns: Name Type Description NGrad numPoint x numDim x numNodes array Shape function gradient values, NGrad i [k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate Source code in FEMpy/Elements/HexElement3D.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" NPrimeParam = LP . LagrangePoly3dDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], paramCoords [:, 2 ], self . order + 1 ) return np . ascontiguousarray ( NPrimeParam [:, :, self . shapeFuncToNodeOrder ])","title":"computeShapeFunctionGradients()"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.computeShapeFunctions","text":"Compute the shape function values at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at required Returns: Name Type Description N numPoint x numNodes array Array of shape function values at the given parametric coordinates, N i is the value of the jth shape function at the ith parametric point Source code in FEMpy/Elements/HexElement3D.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" N = LP . LagrangePoly3d ( paramCoords [:, 0 ], paramCoords [:, 1 ], paramCoords [:, 2 ], self . order + 1 ) return np . ascontiguousarray ( N [:, self . shapeFuncToNodeOrder ])","title":"computeShapeFunctions()"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getIntegrationPointCoords","text":"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description numIntpoint x numDim array Integration point coordinates Source code in FEMpy/Elements/HexElement3D.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadPoints ( self . numDim , order )","title":"getIntegrationPointCoords()"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getIntegrationPointWeights","text":"Compute the integration point weights for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description array of length numIntpoint Integration point weights Source code in FEMpy/Elements/HexElement3D.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadWeights ( self . numDim , order )","title":"getIntegrationPointWeights()"},{"location":"Elements/Hex3D/#FEMpy.Elements.HexElement3D.HexElement3D.getReferenceElementCoordinates","text":"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns: Type Description numNodes x numDim array Element node coordinates Source code in FEMpy/Elements/HexElement3D.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns ------- numNodes x numDim array Element node coordinates \"\"\" numPoints = self . order + 1 p = np . linspace ( - 1 , 1 , numPoints ) x = np . tile ( p , numPoints ** 2 ) y = np . tile ( np . repeat ( p , numPoints ), numPoints ) z = np . repeat ( p , numPoints ** 2 ) return np . vstack (( x [ self . shapeFuncToNodeOrder ], y [ self . shapeFuncToNodeOrder ], z [ self . shapeFuncToNodeOrder ])) . T","title":"getReferenceElementCoordinates()"},{"location":"Elements/Quad2D/","text":"2D Quad Element Bases: Element An \"arbitrary order\" 2d quadrilateral finite element Arbitrary order is in quotes at the moment because although the shape functions can in theory be computed for an arbitrary with the current LagrangePoly implementation, I have not figured out how to element the node reordering required to reorder the shape functions into the node ordering used by MeshIO yet for anything more than 3 rd order elements. Inherits from Element : FEMpy.Element The FEMpy element base class Source code in FEMpy/Elements/QuadElement2D.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class QuadElement2D ( Element ): \"\"\"An \"arbitrary order\" 2d quadrilateral finite element Arbitrary order is in quotes at the moment because although the shape functions can in theory be computed for an arbitrary with the current LagrangePoly implementation, I have not figured out how to element the node reordering required to reorder the shape functions into the node ordering used by MeshIO yet for anything more than 3rd order elements. Inherits from ------------- Element : FEMpy.Element The FEMpy element base class \"\"\" def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 2d quadrilateral finite element object Parameters ---------- order : int, optional Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 2 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 , 3 ]: raise ValueError ( \"Quad elements only support orders 1, 2 and 3\" ) self . order = order numNodes = ( order + 1 ) ** 2 if quadratureOrder is None : shapeFuncOrder = 2 * order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 2 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeQuad\" self . shapeFuncToNodeOrder = self . _getNodeReordering ( self . order ) # ============================================================================== # Public methods # ============================================================================== def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" N = LP . LagrangePoly2d ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 ) return np . ascontiguousarray ( N [:, self . shapeFuncToNodeOrder ]) def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" NPrimeParam = LP . LagrangePoly2dDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 ) return np . ascontiguousarray ( NPrimeParam [:, :, self . shapeFuncToNodeOrder ]) def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadWeights ( self . numDim , order ) def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadPoints ( self . numDim , order ) def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns ------- numNodes x numDim array Element node coordinates \"\"\" x = np . tile ( np . linspace ( - 1 , 1 , self . order + 1 ), self . order + 1 ) y = np . repeat ( np . linspace ( - 1 , 1 , self . order + 1 ), self . order + 1 ) return np . vstack (( x [ self . shapeFuncToNodeOrder ], y [ self . shapeFuncToNodeOrder ])) . T # ============================================================================== # Private methods # ============================================================================== @staticmethod def _getNodeReordering ( order ): \"\"\"Compute the reordering required between shape functions and nodes The 2d lagrange polynomial shape functions are ordered left to right, bottom to top, but the node ordering is defined differently, (e.g for a four node element it is bottom left, bottom right, top left, top right). This method computes the reordering required to map the shape functions to the correct node ordering. As of now I have simply manually implemented this for the first few orders, but it should be possible to compute this for any order with some sort of recursion. Parameters ---------- order : int Quad element order Returns ------- np.array Reordering array, array[i] = j indicates that the ith shape function should be reordered to the jth node \"\"\" if order == 1 : return np . array ([ 0 , 1 , 3 , 2 ]) if order == 2 : return np . array ([ 0 , 2 , 8 , 6 , 1 , 5 , 7 , 3 , 4 ]) if order == 3 : return np . array ([ 0 , 3 , 15 , 12 , 1 , 2 , 7 , 11 , 14 , 13 , 8 , 4 , 5 , 6 , 10 , 9 ]) name = f 'Order { self . order } -LagrangeQuad' instance-attribute order = order instance-attribute shapeFuncToNodeOrder = self . _getNodeReordering ( self . order ) instance-attribute __init__ ( order = 1 , numStates = None , quadratureOrder = None ) Create a new 2d quadrilateral finite element object Parameters: Name Type Description Default order int , optional Element order, a first order quad has 4 nodes, 2 nd order 9, 3 rd order 16 etc, currently only orders 1-3 are supported, by default 1 1 numStates int , optional Number of states in the underlying PDE, by default 2 None quadratureOrder int , optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used None Raises: Type Description ValueError Raises error if order is not 1, 2 or 3 Source code in FEMpy/Elements/QuadElement2D.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 2d quadrilateral finite element object Parameters ---------- order : int, optional Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 2 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 , 3 ]: raise ValueError ( \"Quad elements only support orders 1, 2 and 3\" ) self . order = order numNodes = ( order + 1 ) ** 2 if quadratureOrder is None : shapeFuncOrder = 2 * order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 2 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeQuad\" self . shapeFuncToNodeOrder = self . _getNodeReordering ( self . order ) computeShapeFunctionGradients ( paramCoords ) Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at required Returns: Name Type Description NGrad numPoint x numDim x numNodes array Shape function gradient values, NGrad i [k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate Source code in FEMpy/Elements/QuadElement2D.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" NPrimeParam = LP . LagrangePoly2dDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 ) return np . ascontiguousarray ( NPrimeParam [:, :, self . shapeFuncToNodeOrder ]) computeShapeFunctions ( paramCoords ) Compute the shape function values at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at required Returns: Name Type Description N numPoint x numNodes array Array of shape function values at the given parametric coordinates, N i is the value of the jth shape function at the ith parametric point Source code in FEMpy/Elements/QuadElement2D.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" N = LP . LagrangePoly2d ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 ) return np . ascontiguousarray ( N [:, self . shapeFuncToNodeOrder ]) getIntegrationPointCoords ( order = None ) Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description numIntpoint x numDim array Integration point coordinates Source code in FEMpy/Elements/QuadElement2D.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadPoints ( self . numDim , order ) getIntegrationPointWeights ( order = None ) Compute the integration point weights for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description array of length numIntpoint Integration point weights Source code in FEMpy/Elements/QuadElement2D.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadWeights ( self . numDim , order ) getReferenceElementCoordinates () Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns: Type Description numNodes x numDim array Element node coordinates Source code in FEMpy/Elements/QuadElement2D.py 147 148 149 150 151 152 153 154 155 156 157 158 159 def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns ------- numNodes x numDim array Element node coordinates \"\"\" x = np . tile ( np . linspace ( - 1 , 1 , self . order + 1 ), self . order + 1 ) y = np . repeat ( np . linspace ( - 1 , 1 , self . order + 1 ), self . order + 1 ) return np . vstack (( x [ self . shapeFuncToNodeOrder ], y [ self . shapeFuncToNodeOrder ])) . T","title":"2D Quad"},{"location":"Elements/Quad2D/#2d-quad-element","text":"Bases: Element An \"arbitrary order\" 2d quadrilateral finite element Arbitrary order is in quotes at the moment because although the shape functions can in theory be computed for an arbitrary with the current LagrangePoly implementation, I have not figured out how to element the node reordering required to reorder the shape functions into the node ordering used by MeshIO yet for anything more than 3 rd order elements.","title":"2D Quad Element"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D--inherits-from","text":"Element : FEMpy.Element The FEMpy element base class Source code in FEMpy/Elements/QuadElement2D.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class QuadElement2D ( Element ): \"\"\"An \"arbitrary order\" 2d quadrilateral finite element Arbitrary order is in quotes at the moment because although the shape functions can in theory be computed for an arbitrary with the current LagrangePoly implementation, I have not figured out how to element the node reordering required to reorder the shape functions into the node ordering used by MeshIO yet for anything more than 3rd order elements. Inherits from ------------- Element : FEMpy.Element The FEMpy element base class \"\"\" def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 2d quadrilateral finite element object Parameters ---------- order : int, optional Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 2 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 , 3 ]: raise ValueError ( \"Quad elements only support orders 1, 2 and 3\" ) self . order = order numNodes = ( order + 1 ) ** 2 if quadratureOrder is None : shapeFuncOrder = 2 * order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 2 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeQuad\" self . shapeFuncToNodeOrder = self . _getNodeReordering ( self . order ) # ============================================================================== # Public methods # ============================================================================== def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" N = LP . LagrangePoly2d ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 ) return np . ascontiguousarray ( N [:, self . shapeFuncToNodeOrder ]) def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" NPrimeParam = LP . LagrangePoly2dDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 ) return np . ascontiguousarray ( NPrimeParam [:, :, self . shapeFuncToNodeOrder ]) def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadWeights ( self . numDim , order ) def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadPoints ( self . numDim , order ) def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns ------- numNodes x numDim array Element node coordinates \"\"\" x = np . tile ( np . linspace ( - 1 , 1 , self . order + 1 ), self . order + 1 ) y = np . repeat ( np . linspace ( - 1 , 1 , self . order + 1 ), self . order + 1 ) return np . vstack (( x [ self . shapeFuncToNodeOrder ], y [ self . shapeFuncToNodeOrder ])) . T # ============================================================================== # Private methods # ============================================================================== @staticmethod def _getNodeReordering ( order ): \"\"\"Compute the reordering required between shape functions and nodes The 2d lagrange polynomial shape functions are ordered left to right, bottom to top, but the node ordering is defined differently, (e.g for a four node element it is bottom left, bottom right, top left, top right). This method computes the reordering required to map the shape functions to the correct node ordering. As of now I have simply manually implemented this for the first few orders, but it should be possible to compute this for any order with some sort of recursion. Parameters ---------- order : int Quad element order Returns ------- np.array Reordering array, array[i] = j indicates that the ith shape function should be reordered to the jth node \"\"\" if order == 1 : return np . array ([ 0 , 1 , 3 , 2 ]) if order == 2 : return np . array ([ 0 , 2 , 8 , 6 , 1 , 5 , 7 , 3 , 4 ]) if order == 3 : return np . array ([ 0 , 3 , 15 , 12 , 1 , 2 , 7 , 11 , 14 , 13 , 8 , 4 , 5 , 6 , 10 , 9 ])","title":"Inherits from"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.name","text":"","title":"name"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.order","text":"","title":"order"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.shapeFuncToNodeOrder","text":"","title":"shapeFuncToNodeOrder"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.__init__","text":"Create a new 2d quadrilateral finite element object Parameters: Name Type Description Default order int , optional Element order, a first order quad has 4 nodes, 2 nd order 9, 3 rd order 16 etc, currently only orders 1-3 are supported, by default 1 1 numStates int , optional Number of states in the underlying PDE, by default 2 None quadratureOrder int , optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used None Raises: Type Description ValueError Raises error if order is not 1, 2 or 3 Source code in FEMpy/Elements/QuadElement2D.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 2d quadrilateral finite element object Parameters ---------- order : int, optional Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 2 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 , 3 ]: raise ValueError ( \"Quad elements only support orders 1, 2 and 3\" ) self . order = order numNodes = ( order + 1 ) ** 2 if quadratureOrder is None : shapeFuncOrder = 2 * order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 2 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeQuad\" self . shapeFuncToNodeOrder = self . _getNodeReordering ( self . order )","title":"__init__()"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.computeShapeFunctionGradients","text":"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at required Returns: Name Type Description NGrad numPoint x numDim x numNodes array Shape function gradient values, NGrad i [k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate Source code in FEMpy/Elements/QuadElement2D.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" NPrimeParam = LP . LagrangePoly2dDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 ) return np . ascontiguousarray ( NPrimeParam [:, :, self . shapeFuncToNodeOrder ])","title":"computeShapeFunctionGradients()"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.computeShapeFunctions","text":"Compute the shape function values at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at required Returns: Name Type Description N numPoint x numNodes array Array of shape function values at the given parametric coordinates, N i is the value of the jth shape function at the ith parametric point Source code in FEMpy/Elements/QuadElement2D.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" N = LP . LagrangePoly2d ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order + 1 ) return np . ascontiguousarray ( N [:, self . shapeFuncToNodeOrder ])","title":"computeShapeFunctions()"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getIntegrationPointCoords","text":"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description numIntpoint x numDim array Integration point coordinates Source code in FEMpy/Elements/QuadElement2D.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadPoints ( self . numDim , order )","title":"getIntegrationPointCoords()"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getIntegrationPointWeights","text":"Compute the integration point weights for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description array of length numIntpoint Integration point weights Source code in FEMpy/Elements/QuadElement2D.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getGaussQuadWeights ( self . numDim , order )","title":"getIntegrationPointWeights()"},{"location":"Elements/Quad2D/#FEMpy.Elements.QuadElement2D.QuadElement2D.getReferenceElementCoordinates","text":"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns: Type Description numNodes x numDim array Element node coordinates Source code in FEMpy/Elements/QuadElement2D.py 147 148 149 150 151 152 153 154 155 156 157 158 159 def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined For the quad element, the nodes of the reference element are simply in a order+1 x order+1 grid over the range [-1, 1] in both x and y, reordered as described by _getNodeReordering Returns ------- numNodes x numDim array Element node coordinates \"\"\" x = np . tile ( np . linspace ( - 1 , 1 , self . order + 1 ), self . order + 1 ) y = np . repeat ( np . linspace ( - 1 , 1 , self . order + 1 ), self . order + 1 ) return np . vstack (( x [ self . shapeFuncToNodeOrder ], y [ self . shapeFuncToNodeOrder ])) . T","title":"getReferenceElementCoordinates()"},{"location":"Elements/Tri2D/","text":"2D Triangle Element Bases: Element An up-to-3 rd -order 2d triangular element with 3, 6 or 10 nodes respectively. The node numbering follows the meshio conventions shown below: 1 st order element:: 2 |\\ | \\ | \\ | \\ | \\ 0 ----- 1 2 nd order element:: 2 |\\ | \\ 5 4 | \\ | \\ 0 -- 3 -- 1 3 rd Order:: 2 |\\ | \\ 7 6 | \\ | \\ 8 9 5 | \\ | \\ 0 -- 3 -- 4 -- 1 Source code in FEMpy/Elements/TriElement2D.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 class TriElement2D ( Element ): \"\"\" An up-to-3rd-order 2d triangular element with 3, 6 or 10 nodes respectively. The node numbering follows the meshio conventions shown below: 1st order element:: 2 |\\\\ | \\\\ | \\\\ | \\\\ | \\\\ 0-----1 2nd order element:: 2 |\\\\ | \\\\ 5 4 | \\\\ | \\\\ 0--3--1 3rd Order:: 2 |\\\\ | \\\\ 7 6 | \\\\ | \\\\ 8 9 5 | \\\\ | \\\\ 0--3--4--1 \"\"\" def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 2d triangular finite element object Parameters ---------- order : int, optional Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 2 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 , 3 ]: raise ValueError ( \"Triangular elements only support orders 1, 2 and 3\" ) self . order = order numNodes = ( order + 1 ) * ( order + 2 ) // 2 if quadratureOrder is None : shapeFuncOrder = order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 2 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeTri\" # --- Define parametric coordinate bounds --- self . paramCoordLowerBounds = - np . zeros ( self . numDim ) self . paramCoordLinearConstaintMat = np . array ([ 1.0 , 1.0 ]) self . paramCoordLinearConstaintUpperBounds = 1.0 self . paramCoordLinearConstaintLowerBounds = - np . inf def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" return LP . LagrangePolyTri ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order ) def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" return LP . LagrangePolyTriDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order ) def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getTriQuadWeights ( order ) def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getTriQuadPoints ( order ) def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns ------- numNodes x numDim array Element node coordinates \"\"\" if self . order == 1 : return np . array ([[ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ]]) elif self . order == 2 : return np . array ([[ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ], [ 0.5 , 0.0 ], [ 0.5 , 0.5 ], [ 0.0 , 0.5 ]]) elif self . order == 3 : return np . array ( [ [ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ], [ 1 / 3 , 0.0 ], [ 2 / 3 , 0.0 ], [ 2 / 3 , 1 / 3 ], [ 1 / 3 , 2 / 3 ], [ 0.0 , 2 / 3 ], [ 0.0 , 1 / 3 ], [ 1 / 3 , 1 / 3 ], ] ) def getRandParamCoord ( self , n , rng = None ): \"\"\"Generate a set of random parametric coordinates For a tri element we need u and v in range [0,1] and u + v <= 1, we can generate these points by generating random points in a square on the domain [0,1] and then reflecting any points outside the triangle to the inside. Parameters ---------- n : int, optional number of points to generate, by default 1 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call Returns ------- paramCoords : n x numDim array isoparametric coordinates, one row for each point \"\"\" if rng is None : rng = np . random . default_rng () coords = np . atleast_2d ( rng . random (( n , 2 ))) for i in range ( n ): coordSum = coords [ i , 0 ] + coords [ i , 1 ] if coordSum > 1 : coords [ i ] = 1 - coords [ i ] return coords name = f 'Order { self . order } -LagrangeTri' instance-attribute order = order instance-attribute paramCoordLinearConstaintLowerBounds = - np . inf instance-attribute paramCoordLinearConstaintMat = np . array ([ 1.0 , 1.0 ]) instance-attribute paramCoordLinearConstaintUpperBounds = 1.0 instance-attribute paramCoordLowerBounds = - np . zeros ( self . numDim ) instance-attribute __init__ ( order = 1 , numStates = None , quadratureOrder = None ) Create a new 2d triangular finite element object Parameters: Name Type Description Default order int , optional Element order, a first order quad has 4 nodes, 2 nd order 9, 3 rd order 16 etc, currently only orders 1-3 are supported, by default 1 1 numStates int , optional Number of states in the underlying PDE, by default 2 None quadratureOrder int , optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used None Raises: Type Description ValueError Raises error if order is not 1, 2 or 3 Source code in FEMpy/Elements/TriElement2D.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 2d triangular finite element object Parameters ---------- order : int, optional Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 2 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 , 3 ]: raise ValueError ( \"Triangular elements only support orders 1, 2 and 3\" ) self . order = order numNodes = ( order + 1 ) * ( order + 2 ) // 2 if quadratureOrder is None : shapeFuncOrder = order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 2 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeTri\" # --- Define parametric coordinate bounds --- self . paramCoordLowerBounds = - np . zeros ( self . numDim ) self . paramCoordLinearConstaintMat = np . array ([ 1.0 , 1.0 ]) self . paramCoordLinearConstaintUpperBounds = 1.0 self . paramCoordLinearConstaintLowerBounds = - np . inf computeShapeFunctionGradients ( paramCoords ) Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at required Returns: Name Type Description NGrad numPoint x numDim x numNodes array Shape function gradient values, NGrad i [k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate Source code in FEMpy/Elements/TriElement2D.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" return LP . LagrangePolyTriDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order ) computeShapeFunctions ( paramCoords ) Compute the shape function values at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at required Returns: Name Type Description N numPoint x numNodes array Array of shape function values at the given parametric coordinates, N i is the value of the jth shape function at the ith parametric point Source code in FEMpy/Elements/TriElement2D.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" return LP . LagrangePolyTri ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order ) getIntegrationPointCoords ( order = None ) Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description numIntpoint x numDim array Integration point coordinates Source code in FEMpy/Elements/TriElement2D.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getTriQuadPoints ( order ) getIntegrationPointWeights ( order = None ) Compute the integration point weights for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description array of length numIntpoint Integration point weights Source code in FEMpy/Elements/TriElement2D.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getTriQuadWeights ( order ) getRandParamCoord ( n , rng = None ) Generate a set of random parametric coordinates For a tri element we need u and v in range [0,1] and u + v <= 1, we can generate these points by generating random points in a square on the domain [0,1] and then reflecting any points outside the triangle to the inside. Parameters: Name Type Description Default n int , optional number of points to generate, by default 1 required rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Returns: Name Type Description paramCoords n x numDim array isoparametric coordinates, one row for each point Source code in FEMpy/Elements/TriElement2D.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def getRandParamCoord ( self , n , rng = None ): \"\"\"Generate a set of random parametric coordinates For a tri element we need u and v in range [0,1] and u + v <= 1, we can generate these points by generating random points in a square on the domain [0,1] and then reflecting any points outside the triangle to the inside. Parameters ---------- n : int, optional number of points to generate, by default 1 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call Returns ------- paramCoords : n x numDim array isoparametric coordinates, one row for each point \"\"\" if rng is None : rng = np . random . default_rng () coords = np . atleast_2d ( rng . random (( n , 2 ))) for i in range ( n ): coordSum = coords [ i , 0 ] + coords [ i , 1 ] if coordSum > 1 : coords [ i ] = 1 - coords [ i ] return coords getReferenceElementCoordinates () Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns: Type Description numNodes x numDim array Element node coordinates Source code in FEMpy/Elements/TriElement2D.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns ------- numNodes x numDim array Element node coordinates \"\"\" if self . order == 1 : return np . array ([[ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ]]) elif self . order == 2 : return np . array ([[ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ], [ 0.5 , 0.0 ], [ 0.5 , 0.5 ], [ 0.0 , 0.5 ]]) elif self . order == 3 : return np . array ( [ [ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ], [ 1 / 3 , 0.0 ], [ 2 / 3 , 0.0 ], [ 2 / 3 , 1 / 3 ], [ 1 / 3 , 2 / 3 ], [ 0.0 , 2 / 3 ], [ 0.0 , 1 / 3 ], [ 1 / 3 , 1 / 3 ], ] )","title":"2D Tri"},{"location":"Elements/Tri2D/#2d-triangle-element","text":"Bases: Element An up-to-3 rd -order 2d triangular element with 3, 6 or 10 nodes respectively. The node numbering follows the meshio conventions shown below: 1 st order element:: 2 |\\ | \\ | \\ | \\ | \\ 0 ----- 1 2 nd order element:: 2 |\\ | \\ 5 4 | \\ | \\ 0 -- 3 -- 1 3 rd Order:: 2 |\\ | \\ 7 6 | \\ | \\ 8 9 5 | \\ | \\ 0 -- 3 -- 4 -- 1 Source code in FEMpy/Elements/TriElement2D.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 class TriElement2D ( Element ): \"\"\" An up-to-3rd-order 2d triangular element with 3, 6 or 10 nodes respectively. The node numbering follows the meshio conventions shown below: 1st order element:: 2 |\\\\ | \\\\ | \\\\ | \\\\ | \\\\ 0-----1 2nd order element:: 2 |\\\\ | \\\\ 5 4 | \\\\ | \\\\ 0--3--1 3rd Order:: 2 |\\\\ | \\\\ 7 6 | \\\\ | \\\\ 8 9 5 | \\\\ | \\\\ 0--3--4--1 \"\"\" def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 2d triangular finite element object Parameters ---------- order : int, optional Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 2 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 , 3 ]: raise ValueError ( \"Triangular elements only support orders 1, 2 and 3\" ) self . order = order numNodes = ( order + 1 ) * ( order + 2 ) // 2 if quadratureOrder is None : shapeFuncOrder = order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 2 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeTri\" # --- Define parametric coordinate bounds --- self . paramCoordLowerBounds = - np . zeros ( self . numDim ) self . paramCoordLinearConstaintMat = np . array ([ 1.0 , 1.0 ]) self . paramCoordLinearConstaintUpperBounds = 1.0 self . paramCoordLinearConstaintLowerBounds = - np . inf def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" return LP . LagrangePolyTri ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order ) def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" return LP . LagrangePolyTriDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order ) def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getTriQuadWeights ( order ) def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getTriQuadPoints ( order ) def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns ------- numNodes x numDim array Element node coordinates \"\"\" if self . order == 1 : return np . array ([[ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ]]) elif self . order == 2 : return np . array ([[ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ], [ 0.5 , 0.0 ], [ 0.5 , 0.5 ], [ 0.0 , 0.5 ]]) elif self . order == 3 : return np . array ( [ [ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ], [ 1 / 3 , 0.0 ], [ 2 / 3 , 0.0 ], [ 2 / 3 , 1 / 3 ], [ 1 / 3 , 2 / 3 ], [ 0.0 , 2 / 3 ], [ 0.0 , 1 / 3 ], [ 1 / 3 , 1 / 3 ], ] ) def getRandParamCoord ( self , n , rng = None ): \"\"\"Generate a set of random parametric coordinates For a tri element we need u and v in range [0,1] and u + v <= 1, we can generate these points by generating random points in a square on the domain [0,1] and then reflecting any points outside the triangle to the inside. Parameters ---------- n : int, optional number of points to generate, by default 1 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call Returns ------- paramCoords : n x numDim array isoparametric coordinates, one row for each point \"\"\" if rng is None : rng = np . random . default_rng () coords = np . atleast_2d ( rng . random (( n , 2 ))) for i in range ( n ): coordSum = coords [ i , 0 ] + coords [ i , 1 ] if coordSum > 1 : coords [ i ] = 1 - coords [ i ] return coords","title":"2D Triangle Element"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.name","text":"","title":"name"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.order","text":"","title":"order"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.paramCoordLinearConstaintLowerBounds","text":"","title":"paramCoordLinearConstaintLowerBounds"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.paramCoordLinearConstaintMat","text":"","title":"paramCoordLinearConstaintMat"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.paramCoordLinearConstaintUpperBounds","text":"","title":"paramCoordLinearConstaintUpperBounds"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.paramCoordLowerBounds","text":"","title":"paramCoordLowerBounds"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.__init__","text":"Create a new 2d triangular finite element object Parameters: Name Type Description Default order int , optional Element order, a first order quad has 4 nodes, 2 nd order 9, 3 rd order 16 etc, currently only orders 1-3 are supported, by default 1 1 numStates int , optional Number of states in the underlying PDE, by default 2 None quadratureOrder int , optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used None Raises: Type Description ValueError Raises error if order is not 1, 2 or 3 Source code in FEMpy/Elements/TriElement2D.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def __init__ ( self , order = 1 , numStates = None , quadratureOrder = None ): \"\"\"Create a new 2d triangular finite element object Parameters ---------- order : int, optional Element order, a first order quad has 4 nodes, 2nd order 9, 3rd order 16 etc, currently only orders 1-3 are supported, by default 1 numStates : int, optional Number of states in the underlying PDE, by default 2 quadratureOrder : int, optional Quadrature order to use for numerical integration, by default None, in which case a valid order for the chosen element order is used Raises ------ ValueError Raises error if order is not 1, 2 or 3 \"\"\" if order not in [ 1 , 2 , 3 ]: raise ValueError ( \"Triangular elements only support orders 1, 2 and 3\" ) self . order = order numNodes = ( order + 1 ) * ( order + 2 ) // 2 if quadratureOrder is None : shapeFuncOrder = order quadratureOrder = int ( np . ceil (( shapeFuncOrder + 1 ) / 2 )) super () . __init__ ( numNodes , numDim = 2 , quadratureOrder = quadratureOrder , numStates = numStates ) self . name = f \"Order { self . order } -LagrangeTri\" # --- Define parametric coordinate bounds --- self . paramCoordLowerBounds = - np . zeros ( self . numDim ) self . paramCoordLinearConstaintMat = np . array ([ 1.0 , 1.0 ]) self . paramCoordLinearConstaintUpperBounds = 1.0 self . paramCoordLinearConstaintLowerBounds = - np . inf","title":"__init__()"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.computeShapeFunctionGradients","text":"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at required Returns: Name Type Description NGrad numPoint x numDim x numNodes array Shape function gradient values, NGrad i [k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate Source code in FEMpy/Elements/TriElement2D.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def computeShapeFunctionGradients ( self , paramCoords ): \"\"\"Compute the derivatives of the shape functions with respect to the parametric coordinates at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape function gradients at Returns ------- NGrad: numPoint x numDim x numNodes array Shape function gradient values, NGrad[i][j][k] is the value of the kth shape function at the ith point w.r.t the kth parametric coordinate \"\"\" return LP . LagrangePolyTriDeriv ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order )","title":"computeShapeFunctionGradients()"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.computeShapeFunctions","text":"Compute the shape function values at a given set of parametric coordinates Parameters: Name Type Description Default paramCoords numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at required Returns: Name Type Description N numPoint x numNodes array Array of shape function values at the given parametric coordinates, N i is the value of the jth shape function at the ith parametric point Source code in FEMpy/Elements/TriElement2D.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def computeShapeFunctions ( self , paramCoords ): \"\"\"Compute the shape function values at a given set of parametric coordinates Parameters ---------- paramCoords : numPoint x numDim array Array of parametric point coordinates to evaluate shape functions at Returns ------- N: numPoint x numNodes array Array of shape function values at the given parametric coordinates, N[i][j] is the value of the jth shape function at the ith parametric point \"\"\" return LP . LagrangePolyTri ( paramCoords [:, 0 ], paramCoords [:, 1 ], self . order )","title":"computeShapeFunctions()"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getIntegrationPointCoords","text":"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description numIntpoint x numDim array Integration point coordinates Source code in FEMpy/Elements/TriElement2D.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def getIntegrationPointCoords ( self , order = None ): \"\"\"Compute the integration point parameteric coordinates for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- numIntpoint x numDim array Integration point coordinates \"\"\" if order is None : order = self . quadratureOrder return getTriQuadPoints ( order )","title":"getIntegrationPointCoords()"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getIntegrationPointWeights","text":"Compute the integration point weights for a given quadrature order on this element Parameters: Name Type Description Default order int Integration order None Returns: Type Description array of length numIntpoint Integration point weights Source code in FEMpy/Elements/TriElement2D.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def getIntegrationPointWeights ( self , order = None ): \"\"\"Compute the integration point weights for a given quadrature order on this element Parameters ---------- order : int Integration order Returns ------- array of length numIntpoint Integration point weights \"\"\" if order is None : order = self . quadratureOrder return getTriQuadWeights ( order )","title":"getIntegrationPointWeights()"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getRandParamCoord","text":"Generate a set of random parametric coordinates For a tri element we need u and v in range [0,1] and u + v <= 1, we can generate these points by generating random points in a square on the domain [0,1] and then reflecting any points outside the triangle to the inside. Parameters: Name Type Description Default n int , optional number of points to generate, by default 1 required rng numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call None Returns: Name Type Description paramCoords n x numDim array isoparametric coordinates, one row for each point Source code in FEMpy/Elements/TriElement2D.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def getRandParamCoord ( self , n , rng = None ): \"\"\"Generate a set of random parametric coordinates For a tri element we need u and v in range [0,1] and u + v <= 1, we can generate these points by generating random points in a square on the domain [0,1] and then reflecting any points outside the triangle to the inside. Parameters ---------- n : int, optional number of points to generate, by default 1 rng : numpy random Generator, optional Random number generator to use, useful for creating consistent test behaviour, by default None, in which case a new one is created for this call Returns ------- paramCoords : n x numDim array isoparametric coordinates, one row for each point \"\"\" if rng is None : rng = np . random . default_rng () coords = np . atleast_2d ( rng . random (( n , 2 ))) for i in range ( n ): coordSum = coords [ i , 0 ] + coords [ i , 1 ] if coordSum > 1 : coords [ i ] = 1 - coords [ i ] return coords","title":"getRandParamCoord()"},{"location":"Elements/Tri2D/#FEMpy.Elements.TriElement2D.TriElement2D.getReferenceElementCoordinates","text":"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns: Type Description numNodes x numDim array Element node coordinates Source code in FEMpy/Elements/TriElement2D.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def getReferenceElementCoordinates ( self ): \"\"\"Get the node coordinates for the reference element, a.k.a the element on which the shape functions are defined Returns ------- numNodes x numDim array Element node coordinates \"\"\" if self . order == 1 : return np . array ([[ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ]]) elif self . order == 2 : return np . array ([[ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ], [ 0.5 , 0.0 ], [ 0.5 , 0.5 ], [ 0.0 , 0.5 ]]) elif self . order == 3 : return np . array ( [ [ 0.0 , 0.0 ], [ 1.0 , 0.0 ], [ 0.0 , 1.0 ], [ 1 / 3 , 0.0 ], [ 2 / 3 , 0.0 ], [ 2 / 3 , 1 / 3 ], [ 1 / 3 , 2 / 3 ], [ 0.0 , 2 / 3 ], [ 0.0 , 1 / 3 ], [ 1 / 3 , 1 / 3 ], ] )","title":"getReferenceElementCoordinates()"},{"location":"Theory/Theory/","text":"Finite Element Theory (or FEMpy's version of it at least) Isoparametric Elements In FEMpy, elements defining the mapping between the discrete and continuous. An element has a certain number of nodes which have coordinates in real space (reffered to as \\(\\vec{x}\\) ), and at which the state, \\(u\\) is defined. Depending on the PDE being modelled, the state can be a scalar or a vector, (a single temperature value, or a 3-component displacement).","title":"Theory"},{"location":"Theory/Theory/#finite-element-theory-or-fempys-version-of-it-at-least","text":"","title":"Finite Element Theory (or FEMpy's version of it at least)"},{"location":"Theory/Theory/#isoparametric-elements","text":"In FEMpy, elements defining the mapping between the discrete and continuous. An element has a certain number of nodes which have coordinates in real space (reffered to as \\(\\vec{x}\\) ), and at which the state, \\(u\\) is defined. Depending on the PDE being modelled, the state can be a scalar or a vector, (a single temperature value, or a 3-component displacement).","title":"Isoparametric Elements"}]}